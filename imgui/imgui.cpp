// dear imgui, v1.83 WIP
// (main code and documentation)

// Help:
// - Read FAQ at http://dearimgui.org/faq
// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.
// Read imgui.cpp for details, links and comments.

// Resources:
// - FAQ                   http://dearimgui.org/faq
// - Homepage & latest     https://github.com/ocornut/imgui
// - Releases & changelog  https://github.com/ocornut/imgui/releases
// - Gallery               https://github.com/ocornut/imgui/issues/3793 (please post your screenshots/video there!)
// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)
// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary
// - Issues & support      https://github.com/ocornut/imgui/issues
// - Discussions           https://github.com/ocornut/imgui/discussions

// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// See LICENSE.txt for copyright and licensing details (standard MIT License).
// This library is free but needs your support to sustain development and maintenance.
// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to "contact AT dearimgui.com".
// Individuals: you can support continued development via donations. See docs/README or web page.

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- END-USER GUIDE
- PROGRAMMER GUIDE
  - READ FIRST
  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
  - HOW A SIMPLE APPLICATION MAY LOOK LIKE
  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ)
  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] INCLUDES
// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
// [SECTION] MISC HELPERS/UTILITIES (File functions)
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] ImGuiStorage
// [SECTION] ImGuiTextFilter
// [SECTION] ImGuiTextBuffer
// [SECTION] ImGuiListClipper
// [SECTION] STYLING
// [SECTION] RENDER HELPERS
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] ERROR CHECKING
// [SECTION] LAYOUT
// [SECTION] SCROLLING
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
// [SECTION] DOCKING
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUGGER WINDOW

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
 - Easy to hack and improve.
 - Minimize setup and maintenance.
 - Minimize state storage on user side.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption.

 Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:

 - Doesn't look fancy, doesn't animate.
 - Limited layout features, intricate layouts are typically crafted in code.


 END-USER GUIDE
 ==============

 - Double-click on title bar to collapse window.
 - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().
 - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).
 - Click and drag on any empty space to move window.
 - TAB/SHIFT+TAB to cycle through keyboard editable fields.
 - CTRL+Click on a slider or drag box to input value as text.
 - Use mouse wheel to scroll.
 - Text editor:
   - Hold SHIFT or use mouse to select text.
   - CTRL+Left/Right to word jump.
   - CTRL+Shift+Left/Right to select words.
   - CTRL+A our Double-Click to select all.
   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/
   - CTRL+Z,CTRL+Y to undo/redo.
   - ESCAPE to revert text to its original value.
   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)
   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.
 - General Keyboard controls: enable with ImGuiConfigFlags_NavEnableKeyboard.
 - General Gamepad controls: enable with ImGuiConfigFlags_NavEnableGamepad. See suggested mappings in imgui.h ImGuiNavInput_ + download PNG/PSD at http://dearimgui.org/controls_sheets


 PROGRAMMER GUIDE
 ================

 READ FIRST
 ----------
 - Remember to check the wonderful Wiki (https://github.com/ocornut/imgui/wiki)
 - Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction or
   destruction steps, less superfluous data retention on your side, less state duplication, less state synchronization, fewer bugs.
 - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
 - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
 - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links in Wiki.
 - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.
   For every application frame, your UI code will be called only once. This is in contrast to e.g. Unity's implementation of an IMGUI,
   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
 - Our origin is on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
 - This codebase is also optimized to yield decent performances with typical "Debug" builds settings.
 - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
   If you get an assert, read the messages and comments around the assert.
 - C++: this is a very C-ish codebase: we don't rely on C++11, we don't include any C++ headers, and ImGui:: is a namespace.
 - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.
   See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.
   However, imgui_internal.h can optionally export math operators for ImVec2/ImVec4, which we use in this codebase.
 - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction (avoid using it in your code!).


 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
 ----------------------------------------------
 - Overwrite all the sources files except for imconfig.h (if you have modified your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified as a top-most commit which you can regularly rebase over "master".
 - You can also use '#define IMGUI_USER_CONFIG "my_config_file.h" to redirect configuration to your own file.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - To find out usage of old API, you can add '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in your configuration file.
 - Try to keep your copy of Dear ImGui reasonably up to date.


 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
 ---------------------------------------------------------------
 - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
 - In the majority of cases you should be able to use unmodified backends files available in the backends/ folder.
 - Add the Dear ImGui source files + selected backend source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and NOT as a shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating Dear ImGui types with your own maths types.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering information is stored into command-lists that you will retrieve after calling ImGui::Render().
 - Refer to the backends and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.


 HOW A SIMPLE APPLICATION MAY LOOK LIKE
 --------------------------------------
 EXHIBIT 1: USING THE EXAMPLE BACKENDS (= imgui_impl_XXX.cpp files from the backends/ folder).
 The sub-folders in examples/ contain examples applications following this structure.

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer backends (here we are using imgui_impl_win32.cpp and imgui_impl_dx11.cpp)
     ImGui_ImplWin32_Init(hwnd);
     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear imgui, start new frame
         ImGui_ImplDX11_NewFrame();
         ImGui_ImplWin32_NewFrame();
         ImGui::NewFrame();

         // Any application code here
         ImGui::Text("Hello, world!");

         // Render dear imgui into screen
         ImGui::Render();
         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }

     // Shutdown
     ImGui_ImplDX11_Shutdown();
     ImGui_ImplWin32_Shutdown();
     ImGui::DestroyContext();

 EXHIBIT 2: IMPLEMENTING CUSTOM BACKEND / CUSTOM ENGINE

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
     int width, height;
     unsigned char* pixels = NULL;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that to your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ for details about ImTextureID.
     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts->SetTexID((void*)texture);

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform Backends)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0f;             // set the current display width
        io.DisplaySize.y = 1280.0f;             // set the current display height here
        io.MousePos = my_mouse_pos;             // set the mouse position
        io.MouseDown[0] = my_mouse_buttons[0];  // set the mouse button states
        io.MouseDown[1] = my_mouse_buttons[1];

        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your main loop to be able to use Dear ImGui everywhere)
        ImGui::NewFrame();

        // Most of your application code here
        ImGui::Text("Hello, world!");
        MyGameUpdate(); // may use any Dear ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        MyGameRender(); // may use any Dear ImGui functions as well!

        // Render dear imgui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use Dear ImGui in your own game rendering code)
        ImGui::EndFrame();
        ImGui::Render();
        ImDrawData* draw_data = ImGui::GetDrawData();
        MyImGuiRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     ImGui::DestroyContext();

 To decide whether to dispatch mouse/keyboard inputs to Dear ImGui to the rest of your application,
 you should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 Please read the FAQ and example applications for details about this!


 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
 ---------------------------------------------
 The backends in impl_impl_XXX.cpp files contain many working implementations of a rendering function.

    void void MyImGuiRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       for (int n = 0; n < draw_data->CmdListsCount; n++)
       {
          const ImDrawList* cmd_list = draw_data->CmdLists[n];
          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui
          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // The texture for the draw call is specified by pcmd->TextureId.
                 // The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture((MyTexture*)pcmd->TextureId);

                 // We are using scissoring to clip some objects. All low-level graphics API should support it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
                 // - Clipping coordinates are provided in imgui coordinates space:
                 //   - For a given viewport, draw_data->DisplayPos == viewport->Pos and draw_data->DisplaySize == viewport->Size
                 //   - In a single viewport application, draw_data->DisplayPos == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.
                 //   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),
                 //     always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 ImVec2 pos = draw_data->DisplayPos;
                 MyEngineScissor((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);
             }
             idx_buffer += pcmd->ElemCount;
          }
       }
    }


 USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS
 ------------------------------------------
 - The gamepad/keyboard navigation is fairly functional and keeps being improved.
 - Gamepad support is particularly useful to use Dear ImGui on a console system (e.g. PS4, Switch, XB1) without a mouse!
 - You can ask questions and report issues at https://github.com/ocornut/imgui/issues/787
 - The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.
 - Keyboard:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable.
      NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
    - When keyboard navigation is active (io.NavActive + ImGuiConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag
      will be set. For more advanced uses, you may want to read from:
       - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
       - io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).
       - or query focus information with e.g. IsWindowFocused(ImGuiFocusedFlags_AnyWindow), IsItemFocused() etc. functions.
      Please reach out if you think the game vs navigation input sharing could be improved.
 - Gamepad:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable.
    - Backend: Set io.BackendFlags |= ImGuiBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().
      Note that io.NavInputs[] is cleared by EndFrame().
    - See 'enum ImGuiNavInput_' in imgui.h for a description of inputs. For each entry of io.NavInputs[], set the following values:
         0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.
    - We use a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.
      Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
    - You can download PNG/PSD files depicting the gamepad controls for common controllers at: http://dearimgui.org/controls_sheets
    - If you need to share inputs between your game and the imgui parts, the easiest approach is to go all-or-nothing, with a buttons combo
      to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.
 - Mouse:
    - PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.
    - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.
    - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.
      Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs dear imgui to move your mouse cursor along with navigation movements.
      When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
      When that happens your backend NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the backends in examples/ do that.
      (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, imgui will misbehave as it will see your mouse moving back and forth!)
      (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
       to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about an old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

(Docking/Viewport Branch)
 - 2021/XX/XX (1.XX) - when multi-viewports are enabled, all positions will be in your natural OS coordinates space. It means that:
                        - reference to hard-coded positions such as in SetNextWindowPos(ImVec2(0,0)) are probably not what you want anymore.
                          you may use GetMainViewport()->Pos to offset hard-coded positions, e.g. SetNextWindowPos(GetMainViewport()->Pos)
                        - likewise io.MousePos and GetMousePos() will use OS coordinates.
                          If you query mouse positions to interact with non-imgui coordinates you will need to offset them, e.g. subtract GetWindowViewport()->Pos.
 - 2021/XX/XX (1.XX) - Moved IME support functions from io.ImeSetInputScreenPosFn, io.ImeWindowHandle to the PlatformIO api.


 - 2021/03/12 (1.82) - upgraded ImDrawList::AddRect(), AddRectFilled(), PathRect() to use ImDrawFlags instead of ImDrawCornersFlags.
                        - ImDrawCornerFlags_TopLeft  -> use ImDrawFlags_RoundCornersTopLeft
                        - ImDrawCornerFlags_BotRight -> use ImDrawFlags_RoundCornersBottomRight
                        - ImDrawCornerFlags_None     -> use ImDrawFlags_RoundCornersNone etc.
                       flags now sanely defaults to 0 instead of 0x0F, consistent with all other flags in the API.
                       breaking: the default with rounding > 0.0f is now "round all corners" vs old implicit "round no corners":
                        - rounding == 0.0f + flags == 0 --> meant no rounding  --> unchanged (common use)
                        - rounding  > 0.0f + flags != 0 --> meant rounding     --> unchanged (common use)
                        - rounding == 0.0f + flags != 0 --> meant no rounding  --> unchanged (unlikely use)
                        - rounding  > 0.0f + flags == 0 --> meant no rounding  --> BREAKING (unlikely use): will now round all corners --> use ImDrawFlags_RoundCornersNone or rounding == 0.0f.
                       this ONLY matters for hard coded use of 0 + rounding > 0.0f. Use of named ImDrawFlags_RoundCornersNone (new) or ImDrawCornerFlags_None (old) are ok.
                       the old ImDrawCornersFlags used awkward default values of ~0 or 0xF (4 lower bits set) to signify "round all corners" and we sometimes encouraged using them as shortcuts.
                       legacy path still support use of hard coded ~0 or any value from 0x1 or 0xF. They will behave the same with legacy paths enabled (will assert otherwise).
 - 2021/03/11 (1.82) - removed redirecting functions/enums names that were marked obsolete in 1.66 (September 2018):
                        - ImGui::SetScrollHere()              -> use ImGui::SetScrollHereY()
 - 2021/03/11 (1.82) - clarified that ImDrawList::PathArcTo(), ImDrawList::PathArcToFast() won't render with radius < 0.0f. Previously it sorts of accidentally worked but would generally lead to counter-clockwise paths and have an effect on anti-aliasing.
 - 2021/03/10 (1.82) - upgraded ImDrawList::AddPolyline() and PathStroke() "bool closed" parameter to "ImDrawFlags flags". The matching ImDrawFlags_Closed value is guaranteed to always stay == 1 in the future.
 - 2021/02/22 (1.82) - win32+mingw: Re-enabled IME functions by default even under MinGW. In July 2016, issue #738 had me incorrectly disable those default functions for MinGW. MinGW users should: either link with -limm32, either set their imconfig file  with '#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS'.
 - 2021/02/17 (1.82) - renamed rarely used style.CircleSegmentMaxError (old default = 1.60f) to style.CircleTessellationMaxError (new default = 0.30f) as the meaning of the value changed.
 - 2021/02/03 (1.81) - renamed ListBoxHeader(const char* label, ImVec2 size) to BeginListBox(). Kept inline redirection function (will obsolete).
                     - removed ListBoxHeader(const char* label, int items_count, int height_in_items = -1) in favor of specifying size. Kept inline redirection function (will obsolete).
                     - renamed ListBoxFooter() to EndListBox(). Kept inline redirection function (will obsolete).
 - 2021/01/26 (1.81) - removed ImGuiFreeType::BuildFontAtlas(). Kept inline redirection function. Prefer using '#define IMGUI_ENABLE_FREETYPE', but there's a runtime selection path available too. The shared extra flags parameters (very rarely used) are now stored in ImFontAtlas::FontBuilderFlags.
                     - renamed ImFontConfig::RasterizerFlags (used by FreeType) to ImFontConfig::FontBuilderFlags.
                     - renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.63 (August 2018):
                        - ImGui::IsItemDeactivatedAfterChange() -> use ImGui::IsItemDeactivatedAfterEdit().
                        - ImGuiCol_ModalWindowDarkening       -> use ImGuiCol_ModalWindowDimBg
                        - ImGuiInputTextCallback              -> use ImGuiTextEditCallback
                        - ImGuiInputTextCallbackData          -> use ImGuiTextEditCallbackData
 - 2020/12/21 (1.80) - renamed ImDrawList::AddBezierCurve() to AddBezierCubic(), and PathBezierCurveTo() to PathBezierCubicCurveTo(). Kept inline redirection function (will obsolete).
 - 2020/12/04 (1.80) - added imgui_tables.cpp file! Manually constructed project files will need the new file added!
 - 2020/11/18 (1.80) - renamed undocumented/internals ImGuiColumnsFlags_* to ImGuiOldColumnFlags_* in prevision of incoming Tables API.
 - 2020/11/03 (1.80) - renamed io.ConfigWindowsMemoryCompactTimer to io.ConfigMemoryCompactTimer as the feature will apply to other data structures
 - 2020/10/14 (1.80) - backends: moved all backends files (imgui_impl_XXXX.cpp, imgui_impl_XXXX.h) from examples/ to backends/.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.60 (April 2018):
                        - io.RenderDrawListsFn pointer        -> use ImGui::GetDrawData() value and call the render function of your backend
                        - ImGui::IsAnyWindowFocused()         -> use ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow)
                        - ImGui::IsAnyWindowHovered()         -> use ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
                        - ImGuiStyleVar_Count_                -> use ImGuiStyleVar_COUNT
                        - ImGuiMouseCursor_Count_             -> use ImGuiMouseCursor_COUNT
                      - removed redirecting functions names that were marked obsolete in 1.61 (May 2018):
                        - InputFloat (... int decimal_precision ...) -> use InputFloat (... const char* format ...) with format = "%.Xf" where X is your value for decimal_precision.
                        - same for InputFloat2()/InputFloat3()/InputFloat4() variants taking a `int decimal_precision` parameter.
 - 2020/10/05 (1.79) - removed ImGuiListClipper: Renamed constructor parameters which created an ambiguous alternative to using the ImGuiListClipper::Begin() function, with misleading edge cases (note: imgui_memory_editor <0.40 from imgui_club/ used this old clipper API. Update your copy if needed).
 - 2020/09/25 (1.79) - renamed ImGuiSliderFlags_ClampOnInput to ImGuiSliderFlags_AlwaysClamp. Kept redirection enum (will obsolete sooner because previous name was added recently).
 - 2020/09/25 (1.79) - renamed style.TabMinWidthForUnselectedCloseButton to style.TabMinWidthForCloseButton.
 - 2020/09/21 (1.79) - renamed OpenPopupContextItem() back to OpenPopupOnItemClick(), reverting the change from 1.77. For varieties of reason this is more self-explanatory.
 - 2020/09/21 (1.79) - removed return value from OpenPopupOnItemClick() - returned true on mouse release on an item - because it is inconsistent with other popup APIs and makes others misleading. It's also and unnecessary: you can use IsWindowAppearing() after BeginPopup() for a similar result.
 - 2020/09/17 (1.79) - removed ImFont::DisplayOffset in favor of ImFontConfig::GlyphOffset. DisplayOffset was applied after scaling and not very meaningful/useful outside of being needed by the default ProggyClean font. If you scaled this value after calling AddFontDefault(), this is now done automatically. It was also getting in the way of better font scaling, so let's get rid of it now!
 - 2020/08/17 (1.78) - obsoleted use of the trailing 'float power=1.0f' parameter for DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(), DragFloatRange2(), DragScalar(), DragScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(), SliderScalar(), SliderScalarN(), VSliderFloat() and VSliderScalar().
                       replaced the 'float power=1.0f' argument with integer-based flags defaulting to 0 (as with all our flags).
                       worked out a backward-compatibility scheme so hopefully most C++ codebase should not be affected. in short, when calling those functions:
                       - if you omitted the 'power' parameter (likely!), you are not affected.
                       - if you set the 'power' parameter to 1.0f (same as previous default value): 1/ your compiler may warn on float>int conversion, 2/ everything else will work. 3/ you can replace the 1.0f value with 0 to fix the warning, and be technically correct.
                       - if you set the 'power' parameter to >1.0f (to enable non-linear editing): 1/ your compiler may warn on float>int conversion, 2/ code will assert at runtime, 3/ in case asserts are disabled, the code will not crash and enable the _Logarithmic flag. 4/ you can replace the >1.0f value with ImGuiSliderFlags_Logarithmic to fix the warning/assert and get a _similar_ effect as previous uses of power >1.0f.
                       see https://github.com/ocornut/imgui/issues/3361 for all details.
                       kept inline redirection functions (will obsolete) apart for: DragFloatRange2(), VSliderFloat(), VSliderScalar(). For those three the 'float power=1.0f' version was removed directly as they were most unlikely ever used.
                       for shared code, you can version check at compile-time with `#if IMGUI_VERSION_NUM >= 17704`.
                     - obsoleted use of v_min > v_max in DragInt, DragFloat, DragScalar to lock edits (introduced in 1.73, was not demoed nor documented very), will be replaced by a more generic ReadOnly feature. You may use the ImGuiSliderFlags_ReadOnly internal flag in the meantime.
 - 2020/06/23 (1.77) - removed BeginPopupContextWindow(const char*, int mouse_button, bool also_over_items) in favor of BeginPopupContextWindow(const char*, ImGuiPopupFlags flags) with ImGuiPopupFlags_NoOverItems.
 - 2020/06/15 (1.77) - renamed OpenPopupOnItemClick() to OpenPopupContextItem(). Kept inline redirection function (will obsolete). [NOTE: THIS WAS REVERTED IN 1.79]
 - 2020/06/15 (1.77) - removed CalcItemRectClosestPoint() entry point which was made obsolete and asserting in December 2017.
 - 2020/04/23 (1.77) - removed unnecessary ID (first arg) of ImFontAtlas::AddCustomRectRegular().
 - 2020/01/22 (1.75) - ImDrawList::AddCircle()/AddCircleFilled() functions don't accept negative radius any more.
 - 2019/12/17 (1.75) - [undid this change in 1.76] made Columns() limited to 64 columns by asserting above that limit. While the current code technically supports it, future code may not so we're putting the restriction ahead.
 - 2019/12/13 (1.75) - [imgui_internal.h] changed ImRect() default constructor initializes all fields to 0.0f instead of (FLT_MAX,FLT_MAX,-FLT_MAX,-FLT_MAX). If you used ImRect::Add() to create bounding boxes by adding multiple points into it, you may need to fix your initial value.
 - 2019/12/08 (1.75) - removed redirecting functions/enums that were marked obsolete in 1.53 (December 2017):
                       - ShowTestWindow()                    -> use ShowDemoWindow()
                       - IsRootWindowFocused()               -> use IsWindowFocused(ImGuiFocusedFlags_RootWindow)
                       - IsRootWindowOrAnyChildFocused()     -> use IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows)
                       - SetNextWindowContentWidth(w)        -> use SetNextWindowContentSize(ImVec2(w, 0.0f)
                       - GetItemsLineHeightWithSpacing()     -> use GetFrameHeightWithSpacing()
                       - ImGuiCol_ChildWindowBg              -> use ImGuiCol_ChildBg
                       - ImGuiStyleVar_ChildWindowRounding   -> use ImGuiStyleVar_ChildRounding
                       - ImGuiTreeNodeFlags_AllowOverlapMode -> use ImGuiTreeNodeFlags_AllowItemOverlap
                       - IMGUI_DISABLE_TEST_WINDOWS          -> use IMGUI_DISABLE_DEMO_WINDOWS
 - 2019/12/08 (1.75) - obsoleted calling ImDrawList::PrimReserve() with a negative count (which was vaguely documented and rarely if ever used). Instead, we added an explicit PrimUnreserve() API.
 - 2019/12/06 (1.75) - removed implicit default parameter to IsMouseDragging(int button = 0) to be consistent with other mouse functions (none of the other functions have it).
 - 2019/11/21 (1.74) - ImFontAtlas::AddCustomRectRegular() now requires an ID larger than 0x110000 (instead of 0x10000) to conform with supporting Unicode planes 1-16 in a future update. ID below 0x110000 will now assert.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS to IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS for consistency.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_MATH_FUNCTIONS to IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS for consistency.
 - 2019/10/22 (1.74) - removed redirecting functions/enums that were marked obsolete in 1.52 (October 2017):
                       - Begin() [old 5 args version]        -> use Begin() [3 args], use SetNextWindowSize() SetNextWindowBgAlpha() if needed
                       - IsRootWindowOrAnyChildHovered()     -> use IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
                       - AlignFirstTextHeightToWidgets()     -> use AlignTextToFramePadding()
                       - SetNextWindowPosCenter()            -> use SetNextWindowPos() with a pivot of (0.5f, 0.5f)
                       - ImFont::Glyph                       -> use ImFontGlyph
 - 2019/10/14 (1.74) - inputs: Fixed a miscalculation in the keyboard/mouse "typematic" repeat delay/rate calculation, used by keys and e.g. repeating mouse buttons as well as the GetKeyPressedAmount() function.
                       if you were using a non-default value for io.KeyRepeatRate (previous default was 0.250), you can add +io.KeyRepeatDelay to it to compensate for the fix.
                       The function was triggering on: 0.0 and (delay+rate*N) where (N>=1). Fixed formula responds to (N>=0). Effectively it made io.KeyRepeatRate behave like it was set to (io.KeyRepeatRate + io.KeyRepeatDelay).
                       If you never altered io.KeyRepeatRate nor used GetKeyPressedAmount() this won't affect you.
 - 2019/07/15 (1.72) - removed TreeAdvanceToLabelPos() which is rarely used and only does SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()). Kept redirection function (will obsolete).
 - 2019/07/12 (1.72) - renamed ImFontAtlas::CustomRect to ImFontAtlasCustomRect. Kept redirection typedef (will obsolete).
 - 2019/06/14 (1.72) - removed redirecting functions/enums names that were marked obsolete in 1.51 (June 2017): ImGuiCol_Column*, ImGuiSetCond_*, IsItemHoveredRect(), IsPosHoveringAnyWindow(), IsMouseHoveringAnyWindow(), IsMouseHoveringWindow(), IMGUI_ONCE_UPON_A_FRAME. Grep this log for details and new names, or see how they were implemented until 1.71.
 - 2019/06/07 (1.71) - rendering of child window outer decorations (bg color, border, scrollbars) is now performed as part of the parent window. If you have
                       overlapping child windows in a same parent, and relied on their relative z-order to be mapped to their submission order, this will affect your rendering.
                       This optimization is disabled if the parent window has no visual output, because it appears to be the most common situation leading to the creation of overlapping child windows.
                       Please reach out if you are affected.
 - 2019/05/13 (1.71) - renamed SetNextTreeNodeOpen() to SetNextItemOpen(). Kept inline redirection function (will obsolete).
 - 2019/05/11 (1.71) - changed io.AddInputCharacter(unsigned short c) signature to io.AddInputCharacter(unsigned int c).
 - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0f) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.
 - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).
 - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).
 - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).
 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with an arbitrarily small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
 - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Kept redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.
                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the imgui_impl_XXX files have been split to separate platform (Win32, GLFW, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
                       old backends will still work as is, however prefer using the separated backends as they will be updated to support multi-viewports.
                       when adopting new backends follow the main.cpp code of your preferred examples/ folder to know which functions to call.
                       in particular, note that old backends called ImGui::NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some backend ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
                         IsItemHoveredRect()        --> IsItemHovered(ImGuiHoveredFlags_RectOnly)
                         IsMouseHoveringAnyWindow() --> IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
                         IsMouseHoveringWindow()    --> IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) [weird, old behavior]
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Kept redirection typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your backend if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame type.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol_Column to ImGuiCol_Separator, ImGuiCol_ColumnHovered to ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive to ImGuiCol_SeparatorActive. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_Always to ImGuiCond_Always, ImGuiSetCond_Once to ImGuiCond_Once, ImGuiSetCond_FirstUseEver to ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing to ImGuiCond_Appearing. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0, 0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetID() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully, breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you, otherwise if <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color:
                       ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col) { float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a; return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a); }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref GitHub issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the imgui_impl_XXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
 - 2015/01/11 (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       - old:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); [..Upload texture to GPU..];
                       - new:  unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); [..Upload texture to GPU..]; io.Fonts->SetTexID(YourTexIdentifier);
                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs. It is now recommended that you sample the font texture with bilinear interpolation.
 - 2015/01/11 (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to call io.Fonts->SetTexID()
 - 2015/01/11 (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
 - 2015/01/11 (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ)
 ================================

 Read all answers online:
   https://www.dearimgui.org/faq or https://github.com/ocornut/imgui/blob/master/docs/FAQ.md (same url)
 Read all answers locally (with a text editor or ideally a Markdown viewer):
   docs/FAQ.md
 Some answers are copied down here to facilitate searching in code.

 Q&A: Basics
 ===========

 Q: Where is the documentation?
 A: This library is poorly documented at the moment and expects the user to be acquainted with C/C++.
    - Run the examples/ and explore them.
    - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function.
    - The demo covers most features of Dear ImGui, so you can read the code and see its output.
    - See documentation and comments at the top of imgui.cpp + effectively imgui.h.
    - Dozens of standalone example applications using e.g. OpenGL/DirectX are provided in the
      examples/ folder to explain how to integrate Dear ImGui with your own engine/application.
    - The Wiki (https://github.com/ocornut/imgui/wiki) has many resources and links.
    - The Glossary (https://github.com/ocornut/imgui/wiki/Glossary) page also may be useful.
    - Your programming IDE is your friend, find the type or function declaration to find comments
      associated with it.

 Q: What is this library called?
 Q: Which version should I get?
 >> This library is called "Dear ImGui", please don't call it "ImGui" :)
 >> See https://www.dearimgui.org/faq for details.

 Q&A: Integration
 ================

 Q: How to get started?
 A: Read 'PROGRAMMER GUIDE' above. Read examples/README.txt.

 Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?
 A: You should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 >> See https://www.dearimgui.org/faq for a fully detailed answer. You really want to read this.

 Q. How can I enable keyboard controls?
 Q: How can I use this without a mouse, without a keyboard or without a screen? (gamepad, input share, remote display)
 Q: I integrated Dear ImGui in my engine and little squares are showing instead of text...
 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around...
 Q: I integrated Dear ImGui in my engine and some elements are displaying outside their expected windows boundaries...
 >> See https://www.dearimgui.org/faq

 Q&A: Usage
 ----------

 Q: Why is my widget not reacting when I click on it?
 Q: How can I have widgets with an empty label?
 Q: How can I have multiple widgets with the same label?
 Q: How can I display an image? What is ImTextureID, how does it works?
 Q: How can I use my own math types instead of ImVec2/ImVec4?
 Q: How can I interact with standard C++ types (such as std::string and std::vector)?
 Q: How can I display custom shapes? (using low-level ImDrawList API)
 >> See https://www.dearimgui.org/faq

 Q&A: Fonts, Text
 ================

 Q: How should I handle DPI in my application?
 Q: How can I load a different font than the default?
 Q: How can I easily use icons in my application?
 Q: How can I load multiple fonts?
 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 >> See https://www.dearimgui.org/faq and https://github.com/ocornut/imgui/edit/master/docs/FONTS.md

 Q&A: Concerns
 =============

 Q: Who uses Dear ImGui?
 Q: Can you create elaborate/serious tools with Dear ImGui?
 Q: Can you reskin the look of Dear ImGui?
 Q: Why using C++ (as opposed to C)?
 >> See https://www.dearimgui.org/faq

 Q&A: Community
 ==============

 Q: How can I help?
 A: - Businesses: please reach out to "contact AT dearimgui.com" if you work in a place using Dear ImGui!
      We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts.
      This is among the most useful thing you can do for Dear ImGui. With increased funding, we can hire more people working on this project.
    - Individuals: you can support continued development via PayPal donations. See README.
    - If you are experienced with Dear ImGui and C++, look at the GitHub issues, look at the Wiki, read docs/TODO.txt
      and see how you want to help and can help!
    - Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads. Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear imgui helps the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on GitHub or privately).

*/

//-------------------------------------------------------------------------
// [SECTION] INCLUDES
//-------------------------------------------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DISABLE

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

// System includes
#include <ctype.h>      // toupper
#include <stdio.h>      // vsnprintf, sscanf, printf
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// [Windows] OS specific includes (optional)
#if defined(_WIN32) && defined(IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
#define IMGUI_DISABLE_WIN32_FUNCTIONS
#endif
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef __MINGW32__
#include <Windows.h>        // _wfopen, OpenClipboard
#else
#include <windows.h>
#endif
#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP) // UWP doesn't have all Win32 functions
#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS
#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
#endif
#endif

// [Apple] OS specific includes
#if defined(__APPLE__)
#include <TargetConditionals.h>
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)             // condition expression is constant
#pragma warning (disable: 4996)             // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922   // MSVC 2019 16.2 or later
#pragma warning (disable: 5054)             // operator '|': deprecated between enumerations of different types
#endif
#pragma warning (disable: 26451)            // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning (disable: 26495)            // [Static Analyzer] Variable 'XXX' is uninitialized. Always initialize a member variable (type.6).
#pragma warning (disable: 26812)            // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wexit-time-destructors"          // warning: declaration requires an exit-time destructor     // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wglobal-constructors"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.
#pragma clang diagnostic ignored "-Wsign-conversion"                // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wformat-pedantic"                // warning: format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"       // warning: cast to 'void *' from smaller integer type 'int'
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
#elif defined(__GNUC__)
// We disable -Wpragmas because GCC doesn't provide an has_warning equivalent and some forks/patches may not following the warning/version association.
#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

// Debug options
#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL
#define IMGUI_DEBUG_NAV_RECTS       0   // Display the reference navigation rectangle for each window
#define IMGUI_DEBUG_INI_SETTINGS    0   // Save additional comments in .ini file (particularly helps for Docking, but makes saving slower)

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
static const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    // Time before the highlight and screen dimming starts fading in
static const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    // Time before the window list starts to appear

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by backend)
static const float WINDOWS_HOVER_PADDING                    = 4.0f;     // Extend outside window for hovering/resizing (maxxed with TouchPadding) and inside windows for borders. Affect FindHoveredWindow().
static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.
static const float WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER    = 2.00f;    // Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certain time, unless mouse moved.

// Docking
static const float DOCKING_TRANSPARENT_PAYLOAD_ALPHA        = 0.50f;    // For use with io.ConfigDockingTransparentPayload. Apply to Viewport _or_ WindowBg in host viewport.
static const float DOCKING_SPLITTER_SIZE                    = 2.0f;

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

static void             SetCurrentWindow(ImGuiWindow* window);
static void             FindHoveredWindow();
static ImGuiWindow*     CreateNewWindow(const char* name, ImGuiWindowFlags flags);
static ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window);

static void             AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);
static void             AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);

// Settings
static void             WindowSettingsHandler_ClearAll(ImGuiContext*, ImGuiSettingsHandler*);
static void*            WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);
static void             WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);
static void             WindowSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*);
static void             WindowSettingsHandler_WriteAll(ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer* buf);

// Platform Dependents default implementation for IO functions
static const char*      GetClipboardTextFn_DefaultImpl(void* user_data);
static void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);

namespace ImGui
{
// Navigation
static void             NavUpdate();
static void             NavUpdateWindowing();
static void             NavUpdateWindowingOverlay();
static void             NavUpdateMoveResult();
static void             NavUpdateInitResult();
static float            NavUpdatePageUpPageDown();
static inline void      NavUpdateAnyRequestFlag();
static void             NavEndFrame();
static bool             NavScoreItem(ImGuiNavItemData* result, ImRect cand);
static void             NavApplyItemToResult(ImGuiNavItemData* result, ImGuiWindow* window, ImGuiID id, const ImRect& nav_bb_rel);
static void             NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, ImGuiID id);
static ImVec2           NavCalcPreferredRefPos();
static void             NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window);
static ImGuiWindow*     NavRestoreLastChildNavWindow(ImGuiWindow* window);
static void             NavRestoreLayer(ImGuiNavLayer layer);
static int              FindWindowFocusIndex(ImGuiWindow* window);

// Error Checking
static void             ErrorCheckNewFrameSanityChecks();
static void             ErrorCheckEndFrameSanityChecks();

// Misc
static void             UpdateSettings();
static void             UpdateMouseInputs();
static void             UpdateMouseWheel();
static void             UpdateTabFocus();
static void             UpdateDebugToolItemPicker();
static bool             UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect);
static void             RenderWindowOuterBorders(ImGuiWindow* window);
static void             RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size);
static void             RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open);
static void             EndFrameDrawDimmedBackgrounds();

// Viewports
const ImGuiID           IMGUI_VIEWPORT_DEFAULT_ID = 0x11111111; // Using an arbitrary constant instead of e.g. ImHashStr("ViewportDefault", 0); so it's easier to spot in the debugger. The exact value doesn't matter.
static ImGuiViewportP*  AddUpdateViewport(ImGuiWindow* window, ImGuiID id, const ImVec2& platform_pos, const ImVec2& size, ImGuiViewportFlags flags);
static void             UpdateViewportsNewFrame();
static void             UpdateViewportsEndFrame();
static void             UpdateSelectWindowViewport(ImGuiWindow* window);
static bool             UpdateTryMergeWindowIntoHostViewport(ImGuiWindow* window, ImGuiViewportP* host_viewport);
static bool             UpdateTryMergeWindowIntoHostViewports(ImGuiWindow* window);
static bool             GetWindowAlwaysWantOwnViewport(ImGuiWindow* window);
static int              FindPlatformMonitorForPos(const ImVec2& pos);
static int              FindPlatformMonitorForRect(const ImRect& r);
static void             UpdateViewportPlatformMonitor(ImGuiViewportP* viewport);

}

//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// DLL users:
// - Heaps and globals are not shared across DLL boundaries!
// - You will need to call SetCurrentContext() + SetAllocatorFunctions() for each static/DLL boundary you are calling from.
// - Same applies for hot-reloading mechanisms that are reliant on reloading DLL (note that many hot-reloading mechanisms work without DLL).
// - Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
// - Confused? In a debugger: add GImGui to your watch window and notice how its value changes depending on your current location (which DLL boundary you are in).

// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
// - ImGui::CreateContext() will automatically set this pointer if it is NULL.
//   Change to a different context by calling ImGui::SetCurrentContext().
// - Important: Dear ImGui functions are not thread-safe because of this pointer.
//   If you want thread-safety to allow N threads to access N different contexts:
//   - Change this variable to use thread local storage so each thread can refer to a different context, in your imconfig.h:
//         struct ImGuiContext;
//         extern thread_local ImGuiContext* MyImGuiTLS;
//         #define GImGui MyImGuiTLS
//     And then define MyImGuiTLS in one of your cpp files. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
//   - Future development aims to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
//   - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from a different namespace.
// - DLL users: read comments above.
#ifndef GImGui
ImGuiContext*   GImGui = NULL;
#endif

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// - You probably don't want to modify that mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
// - DLL users: read comments above.
#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
#else
static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }
static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }
#endif
static ImGuiMemAllocFunc    GImAllocatorAllocFunc = MallocWrapper;
static ImGuiMemFreeFunc     GImAllocatorFreeFunc = FreeWrapper;
static void*                GImAllocatorUserData = NULL;

//-----------------------------------------------------------------------------
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
//-----------------------------------------------------------------------------

ImGuiStyle::ImGuiStyle()
{
    Alpha                   = 1.0f;             // Global alpha applies to everything in ImGui
    WindowPadding           = ImVec2(8,8);      // Padding within a window
    WindowRounding          = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    WindowMinSize           = ImVec2(32,32);    // Minimum window size
    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text
    WindowMenuButtonPosition= ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
    CellPadding             = ImVec2(4,2);      // Padding within a table cell
    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
    ScrollbarSize           = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar
    GrabMinSize             = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar
    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    LogSliderDeadzone       = 4.0f;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
    TabRounding             = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    TabBorderSize           = 0.0f;             // Thickness of border around tabs.
    TabMinWidthForCloseButton = 0.0f;           // Minimum width for close button to appears on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
    ColorButtonPosition     = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
    SelectableTextAlign     = ImVec2(0.0f,0.0f);// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
    DisplayWindowPadding    = ImVec2(19,19);    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    AntiAliasedLines        = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
    AntiAliasedLinesUseTex  = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering.
    AntiAliasedFill         = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
    CircleTessellationMaxError = 0.30f;         // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.

    // Default theme
    ImGui::StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
void ImGuiStyle::ScaleAllSizes(float scale_factor)
{
    WindowPadding = ImFloor(WindowPadding * scale_factor);
    WindowRounding = ImFloor(WindowRounding * scale_factor);
    WindowMinSize = ImFloor(WindowMinSize * scale_factor);
    ChildRounding = ImFloor(ChildRounding * scale_factor);
    PopupRounding = ImFloor(PopupRounding * scale_factor);
    FramePadding = ImFloor(FramePadding * scale_factor);
    FrameRounding = ImFloor(FrameRounding * scale_factor);
    ItemSpacing = ImFloor(ItemSpacing * scale_factor);
    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);
    CellPadding = ImFloor(CellPadding * scale_factor);
    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);
    IndentSpacing = ImFloor(IndentSpacing * scale_factor);
    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);
    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);
    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);
    GrabMinSize = ImFloor(GrabMinSize * scale_factor);
    GrabRounding = ImFloor(GrabRounding * scale_factor);
    LogSliderDeadzone = ImFloor(LogSliderDeadzone * scale_factor);
    TabRounding = ImFloor(TabRounding * scale_factor);
    TabMinWidthForCloseButton = (TabMinWidthForCloseButton != FLT_MAX) ? ImFloor(TabMinWidthForCloseButton * scale_factor) : FLT_MAX;
    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);
    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);
    MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);
}

ImGuiIO::ImGuiIO()
{
    // Most fields are initialized with zero
    memset(this, 0, sizeof(*this));
    IM_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT); // Our pre-C++11 IM_STATIC_ASSERT() macros triggers warning on modern compilers so we don't use it here.

    // Settings
    ConfigFlags = ImGuiConfigFlags_None;
    BackendFlags = ImGuiBackendFlags_None;
    DisplaySize = ImVec2(-1.0f, -1.0f);
    DeltaTime = 1.0f / 60.0f;
    IniSavingRate = 5.0f;
    IniFilename = "imgui.ini";
    LogFilename = "imgui_log.txt";
    MouseDoubleClickTime = 0.30f;
    MouseDoubleClickMaxDist = 6.0f;
    for (int i = 0; i < ImGuiKey_COUNT; i++)
        KeyMap[i] = -1;
    KeyRepeatDelay = 0.275f;
    KeyRepeatRate = 0.050f;
    UserData = NULL;

    Fonts = NULL;
    FontGlobalScale = 1.0f;
    FontDefault = NULL;
    FontAllowUserScaling = false;
    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);

    // Docking options (when ImGuiConfigFlags_DockingEnable is set)
    ConfigDockingNoSplit = false;
    ConfigDockingAlwaysTabBar = false;
    ConfigDockingTransparentPayload = false;

    // Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
    ConfigViewportsNoAutoMerge = false;
    ConfigViewportsNoTaskBarIcon = false;
    ConfigViewportsNoDecoration = true;
    ConfigViewportsNoDefaultParent = false;

    // Miscellaneous options
    MouseDrawCursor = false;
#ifdef __APPLE__
    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
    ConfigMacOSXBehaviors = false;
#endif
    ConfigInputTextCursorBlink = true;
    ConfigWindowsResizeFromEdges = true;
    ConfigWindowsMoveFromTitleBarOnly = false;
    ConfigMemoryCompactTimer = 60.0f;

    // Platform Functions
    BackendPlatformName = BackendRendererName = NULL;
    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
    ClipboardUserData = NULL;

    // Input (NB: we already have memset zero the entire structure!)
    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
    MouseDragThreshold = 6.0f;
    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i]  = KeysDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
void ImGuiIO::AddInputCharacter(unsigned int c)
{
    if (c != 0)
        InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
}

// UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
// we should save the high surrogate.
void ImGuiIO::AddInputCharacterUTF16(ImWchar16 c)
{
    if (c == 0 && InputQueueSurrogate == 0)
        return;

    if ((c & 0xFC00) == 0xD800) // High surrogate, must save
    {
        if (InputQueueSurrogate != 0)
            InputQueueCharacters.push_back(IM_UNICODE_CODEPOINT_INVALID);
        InputQueueSurrogate = c;
        return;
    }

    ImWchar cp = c;
    if (InputQueueSurrogate != 0)
    {
        if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate
        {
            InputQueueCharacters.push_back(IM_UNICODE_CODEPOINT_INVALID);
        }
        else
        {
#if IM_UNICODE_CODEPOINT_MAX == 0xFFFF
            cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
#else
            cp = (ImWchar)(((InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000);
#endif
        }

        InputQueueSurrogate = 0;
    }
    InputQueueCharacters.push_back(cp);
}

void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
{
    while (*utf8_chars != 0)
    {
        unsigned int c = 0;
        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
        if (c != 0)
            InputQueueCharacters.push_back((ImWchar)c);
    }
}

void ImGuiIO::ClearInputCharacters()
{
    InputQueueCharacters.resize(0);
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
//-----------------------------------------------------------------------------

ImVec2 ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments)
{
    IM_ASSERT(num_segments > 0); // Use ImBezierCubicClosestPointCasteljau()
    ImVec2 p_last = p1;
    ImVec2 p_closest;
    float p_closest_dist2 = FLT_MAX;
    float t_step = 1.0f / (float)num_segments;
    for (int i_step = 1; i_step <= num_segments; i_step++)
    {
        ImVec2 p_current = ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step);
        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);
        float dist2 = ImLengthSqr(p - p_line);
        if (dist2 < p_closest_dist2)
        {
            p_closest = p_line;
            p_closest_dist2 = dist2;
        }
        p_last = p_current;
    }
    return p_closest;
}

// Closely mimics PathBezierToCasteljau() in imgui_draw.cpp
static void ImBezierCubicClosestPointCasteljauStep(const ImVec2& p, ImVec2& p_closest, ImVec2& p_last, float& p_closest_dist2, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
{
    float dx = x4 - x1;
    float dy = y4 - y1;
    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);
    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);
    d2 = (d2 >= 0) ? d2 : -d2;
    d3 = (d3 >= 0) ? d3 : -d3;
    if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))
    {
        ImVec2 p_current(x4, y4);
        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);
        float dist2 = ImLengthSqr(p - p_line);
        if (dist2 < p_closest_dist2)
        {
            p_closest = p_line;
            p_closest_dist2 = dist2;
        }
        p_last = p_current;
    }
    else if (level < 10)
    {
        float x12 = (x1 + x2)*0.5f,       y12 = (y1 + y2)*0.5f;
        float x23 = (x2 + x3)*0.5f,       y23 = (y2 + y3)*0.5f;
        float x34 = (x3 + x4)*0.5f,       y34 = (y3 + y4)*0.5f;
        float x123 = (x12 + x23)*0.5f,    y123 = (y12 + y23)*0.5f;
        float x234 = (x23 + x34)*0.5f,    y234 = (y23 + y34)*0.5f;
        float x1234 = (x123 + x234)*0.5f, y1234 = (y123 + y234)*0.5f;
        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);
        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);
    }
}

// tess_tol is generally the same value you would find in ImGui::GetStyle().CurveTessellationTol
// Because those ImXXX functions are lower-level than ImGui:: we cannot access this value automatically.
ImVec2 ImBezierCubicClosestPointCasteljau(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol)
{
    IM_ASSERT(tess_tol > 0.0f);
    ImVec2 p_last = p1;
    ImVec2 p_closest;
    float p_closest_dist2 = FLT_MAX;
    ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, tess_tol, 0);
    return p_closest;
}

ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)
{
    ImVec2 ap = p - a;
    ImVec2 ab_dir = b - a;
    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
    if (dot < 0.0f)
        return a;
    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
    if (dot > ab_len_sqr)
        return b;
    return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
    return ((b1 == b2) && (b2 == b3));
}

void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)
{
    ImVec2 v0 = b - a;
    ImVec2 v1 = c - a;
    ImVec2 v2 = p - a;
    const float denom = v0.x * v1.y - v1.x * v0.y;
    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
    out_u = 1.0f - out_v - out_w;
}

ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);
    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);
    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);
    float dist2_ab = ImLengthSqr(p - proj_ab);
    float dist2_bc = ImLengthSqr(p - proj_bc);
    float dist2_ca = ImLengthSqr(p - proj_ca);
    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
    if (m == dist2_ab)
        return proj_ab;
    if (m == dist2_bc)
        return proj_bc;
    return proj_ca;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
//-----------------------------------------------------------------------------

// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
int ImStricmp(const char* str1, const char* str2)
{
    int d;
    while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }
    return d;
}

int ImStrnicmp(const char* str1, const char* str2, size_t count)
{
    int d = 0;
    while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }
    return d;
}

void ImStrncpy(char* dst, const char* src, size_t count)
{
    if (count < 1)
        return;
    if (count > 1)
        strncpy(dst, src, count - 1);
    dst[count - 1] = 0;
}

char* ImStrdup(const char* str)
{
    size_t len = strlen(str);
    void* buf = IM_ALLOC(len + 1);
    return (char*)memcpy(buf, (const void*)str, len + 1);
}

char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)
{
    size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
    size_t src_size = strlen(src) + 1;
    if (dst_buf_size < src_size)
    {
        IM_FREE(dst);
        dst = (char*)IM_ALLOC(src_size);
        if (p_dst_size)
            *p_dst_size = src_size;
    }
    return (char*)memcpy(dst, (const void*)src, src_size);
}

const char* ImStrchrRange(const char* str, const char* str_end, char c)
{
    const char* p = (const char*)memchr(str, (int)c, str_end - str);
    return p;
}

int ImStrlenW(const ImWchar* str)
{
    //return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit
    int n = 0;
    while (*str++) n++;
    return n;
}

// Find end-of-line. Return pointer will point to either first \n, either str_end.
const char* ImStreolRange(const char* str, const char* str_end)
{
    const char* p = (const char*)memchr(str, '\n', str_end - str);
    return p ? p : str_end;
}

const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line
{
    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
        buf_mid_line--;
    return buf_mid_line;
}

const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
{
    if (!needle_end)
        needle_end = needle + strlen(needle);

    const char un0 = (char)toupper(*needle);
    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))
    {
        if (toupper(*haystack) == un0)
        {
            const char* b = needle + 1;
            for (const char* a = haystack + 1; b < needle_end; a++, b++)
                if (toupper(*a) != toupper(*b))
                    break;
            if (b == needle_end)
                return haystack;
        }
        haystack++;
    }
    return NULL;
}

// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
void ImStrTrimBlanks(char* buf)
{
    char* p = buf;
    while (p[0] == ' ' || p[0] == '\t')     // Leading blanks
        p++;
    char* p_start = p;
    while (*p != 0)                         // Find end of string
        p++;
    while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks
        p--;
    if (p_start != buf)                     // Copy memory if we had leading blanks
        memmove(buf, p_start, p - p_start);
    buf[p - p_start] = 0;                   // Zero terminate
}

const char* ImStrSkipBlank(const char* str)
{
    while (str[0] == ' ' || str[0] == '\t')
        str++;
    return str;
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
#ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

// We support stb_sprintf which is much faster (see: https://github.com/nothings/stb/blob/master/stb_sprintf.h)
// You may set IMGUI_USE_STB_SPRINTF to use our default wrapper, or set IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
// and setup the wrapper yourself. (FIXME-OPT: Some of our high-level operations such as ImGuiTextBuffer::appendfv() are
// designed using two-passes worst case, which probably could be improved using the stbsp_vsprintfcb() function.)
#ifdef IMGUI_USE_STB_SPRINTF
#define STB_SPRINTF_IMPLEMENTATION
#include "stb_sprintf.h"
#endif

#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf _vsnprintf
#endif

int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
#ifdef IMGUI_USE_STB_SPRINTF
    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
    int w = vsnprintf(buf, buf_size, fmt, args);
#endif
    va_end(args);
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}

int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
{
#ifdef IMGUI_USE_STB_SPRINTF
    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
    int w = vsnprintf(buf, buf_size, fmt, args);
#endif
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}
#endif // #ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
static const ImU32 GCrc32LookupTable[256] =
{
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
};

// Known size hash
// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImGuiID ImHashData(const void* data_p, size_t data_size, ImU32 seed)
{
    ImU32 crc = ~seed;
    const unsigned char* data = (const unsigned char*)data_p;
    const ImU32* crc32_lut = GCrc32LookupTable;
    while (data_size-- != 0)
        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
    return ~crc;
}

// Zero-terminated string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
// Because this syntax is rarely used we are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImGuiID ImHashStr(const char* data_p, size_t data_size, ImU32 seed)
{
    seed = ~seed;
    ImU32 crc = seed;
    const unsigned char* data = (const unsigned char*)data_p;
    const ImU32* crc32_lut = GCrc32LookupTable;
    if (data_size != 0)
    {
        while (data_size-- != 0)
        {
            unsigned char c = *data++;
            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    else
    {
        while (unsigned char c = *data++)
        {
            if (c == '#' && data[0] == '#' && data[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    return ~crc;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (File functions)
//-----------------------------------------------------------------------------

// Default file functions
#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS

ImFileHandle ImFileOpen(const char* filename, const char* mode)
{
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(__CYGWIN__) && !defined(__GNUC__)
    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames.
    // Previously we used ImTextCountCharsFromUtf8/ImTextStrFromUtf8 here but we now need to support ImWchar16 and ImWchar32!
    const int filename_wsize = ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);
    const int mode_wsize = ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, NULL, 0);
    ImVector<ImWchar> buf;
    buf.resize(filename_wsize + mode_wsize);
    ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, (wchar_t*)&buf[0], filename_wsize);
    ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, (wchar_t*)&buf[filename_wsize], mode_wsize);
    return ::_wfopen((const wchar_t*)&buf[0], (const wchar_t*)&buf[filename_wsize]);
#else
    return fopen(filename, mode);
#endif
}

// We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.
bool    ImFileClose(ImFileHandle f)     { return fclose(f) == 0; }
ImU64   ImFileGetSize(ImFileHandle f)   { long off = 0, sz = 0; return ((off = ftell(f)) != -1 && !fseek(f, 0, SEEK_END) && (sz = ftell(f)) != -1 && !fseek(f, off, SEEK_SET)) ? (ImU64)sz : (ImU64)-1; }
ImU64   ImFileRead(void* data, ImU64 sz, ImU64 count, ImFileHandle f)           { return fread(data, (size_t)sz, (size_t)count, f); }
ImU64   ImFileWrite(const void* data, ImU64 sz, ImU64 count, ImFileHandle f)    { return fwrite(data, (size_t)sz, (size_t)count, f); }
#endif // #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS

// Helper: Load file content into memory
// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
// This can't really be used with "rt" because fseek size won't match read size.
void*   ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size, int padding_bytes)
{
    IM_ASSERT(filename && mode);
    if (out_file_size)
        *out_file_size = 0;

    ImFileHandle f;
    if ((f = ImFileOpen(filename, mode)) == NULL)
        return NULL;

    size_t file_size = (size_t)ImFileGetSize(f);
    if (file_size == (size_t)-1)
    {
        ImFileClose(f);
        return NULL;
    }

    void* file_data = IM_ALLOC(file_size + padding_bytes);
    if (file_data == NULL)
    {
        ImFileClose(f);
        return NULL;
    }
    if (ImFileRead(file_data, 1, file_size, f) != file_size)
    {
        ImFileClose(f);
        IM_FREE(file_data);
        return NULL;
    }
    if (padding_bytes > 0)
        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);

    ImFileClose(f);
    if (out_file_size)
        *out_file_size = file_size;

    return file_data;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------

// Convert UTF-8 to 32-bit character, process single character input.
// A nearly-branchless UTF-8 decoder, based on work of Christopher Wellons (https://github.com/skeeto/branchless-utf8).
// We handle UTF-8 decoding error by skipping forward.
int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
{
    static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
    static const int masks[]  = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
    static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
    static const int shiftc[] = { 0, 18, 12, 6, 0 };
    static const int shifte[] = { 0, 6, 4, 2, 0 };
    int len = lengths[*(const unsigned char*)in_text >> 3];
    int wanted = len + !len;

    if (in_text_end == NULL)
        in_text_end = in_text + wanted; // Max length, nulls will be taken into account.

    // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
    // so it is fast even with excessive branching.
    unsigned char s[4];
    s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
    s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
    s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
    s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;

    // Assume a four-byte character and load four bytes. Unused bits are shifted out.
    *out_char  = (uint32_t)(s[0] & masks[len]) << 18;
    *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
    *out_char |= (uint32_t)(s[2] & 0x3f) <<  6;
    *out_char |= (uint32_t)(s[3] & 0x3f) <<  0;
    *out_char >>= shiftc[len];

    // Accumulate the various error conditions.
    int e = 0;
    e  = (*out_char < mins[len]) << 6; // non-canonical encoding
    e |= ((*out_char >> 11) == 0x1b) << 7;  // surrogate half?
    e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8;  // out of range?
    e |= (s[1] & 0xc0) >> 2;
    e |= (s[2] & 0xc0) >> 4;
    e |= (s[3]       ) >> 6;
    e ^= 0x2a; // top two bits of each tail byte correct?
    e >>= shifte[len];

    if (e)
    {
        // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
        // One byte is consumed in case of invalid first byte of in_text.
        // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
        // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
        wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
        *out_char = IM_UNICODE_CODEPOINT_INVALID;
    }

    return wanted;
}

int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
{
    ImWchar* buf_out = buf;
    ImWchar* buf_end = buf + buf_size;
    while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        *buf_out++ = (ImWchar)c;
    }
    *buf_out = 0;
    if (in_text_remaining)
        *in_text_remaining = in_text;
    return (int)(buf_out - buf);
}

int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
{
    int char_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        char_count++;
    }
    return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)
{
    if (c < 0x80)
    {
        buf[0] = (char)c;
        return 1;
    }
    if (c < 0x800)
    {
        if (buf_size < 2) return 0;
        buf[0] = (char)(0xc0 + (c >> 6));
        buf[1] = (char)(0x80 + (c & 0x3f));
        return 2;
    }
    if (c < 0x10000)
    {
        if (buf_size < 3) return 0;
        buf[0] = (char)(0xe0 + (c >> 12));
        buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[2] = (char)(0x80 + ((c ) & 0x3f));
        return 3;
    }
    if (c <= 0x10FFFF)
    {
        if (buf_size < 4) return 0;
        buf[0] = (char)(0xf0 + (c >> 18));
        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[3] = (char)(0x80 + ((c ) & 0x3f));
        return 4;
    }
    // Invalid code point, the max unicode is 0x10FFFF
    return 0;
}

// Not optimal but we very rarely use this function.
int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)
{
    unsigned int unused = 0;
    return ImTextCharFromUtf8(&unused, in_text, in_text_end);
}

static inline int ImTextCountUtf8BytesFromChar(unsigned int c)
{
    if (c < 0x80) return 1;
    if (c < 0x800) return 2;
    if (c < 0x10000) return 3;
    if (c <= 0x10FFFF) return 4;
    return 3;
}

int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
{
    char* buf_out = buf;
    const char* buf_end = buf + buf_size;
    while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            *buf_out++ = (char)c;
        else
            buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end - buf_out - 1), c);
    }
    *buf_out = 0;
    return (int)(buf_out - buf);
}

int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)
{
    int bytes_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            bytes_count++;
        else
            bytes_count += ImTextCountUtf8BytesFromChar(c);
    }
    return bytes_count;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

IMGUI_API ImU32 ImAlphaBlendColors(ImU32 col_a, ImU32 col_b)
{
    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;
    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);
    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);
    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);
    return IM_COL32(r, g, b, 0xFF);
}

ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)
{
    float s = 1.0f / 255.0f;
    return ImVec4(
        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
}

ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
{
    ImU32 out;
    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
    return out;
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
{
    float K = 0.f;
    if (g < b)
    {
        ImSwap(g, b);
        K = -1.f;
    }
    if (r < g)
    {
        ImSwap(r, g);
        K = -2.f / 6.f - K;
    }

    const float chroma = r - (g < b ? g : b);
    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));
    out_s = chroma / (r + 1e-20f);
    out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)
{
    if (s == 0.0f)
    {
        // gray
        out_r = out_g = out_b = v;
        return;
    }

    h = ImFmod(h, 1.0f) / (60.0f / 360.0f);
    int   i = (int)h;
    float f = h - (float)i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));

    switch (i)
    {
    case 0: out_r = v; out_g = t; out_b = p; break;
    case 1: out_r = q; out_g = v; out_b = p; break;
    case 2: out_r = p; out_g = v; out_b = t; break;
    case 3: out_r = p; out_g = q; out_b = v; break;
    case 4: out_r = t; out_g = p; out_b = v; break;
    case 5: default: out_r = v; out_g = p; out_b = q; break;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
static ImGuiStorage::ImGuiStoragePair* LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>& data, ImGuiID key)
{
    ImGuiStorage::ImGuiStoragePair* first = data.Data;
    ImGuiStorage::ImGuiStoragePair* last = data.Data + data.Size;
    size_t count = (size_t)(last - first);
    while (count > 0)
    {
        size_t count2 = count >> 1;
        ImGuiStorage::ImGuiStoragePair* mid = first + count2;
        if (mid->key < key)
        {
            first = ++mid;
            count -= count2 + 1;
        }
        else
        {
            count = count2;
        }
    }
    return first;
}

// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
void ImGuiStorage::BuildSortByKey()
{
    struct StaticFunc
    {
        static int IMGUI_CDECL PairCompareByID(const void* lhs, const void* rhs)
        {
            // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
            if (((const ImGuiStoragePair*)lhs)->key > ((const ImGuiStoragePair*)rhs)->key) return +1;
            if (((const ImGuiStoragePair*)lhs)->key < ((const ImGuiStoragePair*)rhs)->key) return -1;
            return 0;
        }
    };
    if (Data.Size > 1)
        ImQsort(Data.Data, (size_t)Data.Size, sizeof(ImGuiStoragePair), StaticFunc::PairCompareByID);
}

int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
{
    ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_i;
}

bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
{
    return GetInt(key, default_val ? 1 : 0) != 0;
}

float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
{
    ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_f;
}

void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
{
    ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return NULL;
    return it->val_p;
}

// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, ImGuiStoragePair(key, default_val));
    return &it->val_i;
}

bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
{
    return (bool*)GetIntRef(key, default_val ? 1 : 0);
}

float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, ImGuiStoragePair(key, default_val));
    return &it->val_f;
}

void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, ImGuiStoragePair(key, default_val));
    return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
void ImGuiStorage::SetInt(ImGuiID key, int val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, ImGuiStoragePair(key, val));
        return;
    }
    it->val_i = val;
}

void ImGuiStorage::SetBool(ImGuiID key, bool val)
{
    SetInt(key, val ? 1 : 0);
}

void ImGuiStorage::SetFloat(ImGuiID key, float val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, ImGuiStoragePair(key, val));
        return;
    }
    it->val_f = val;
}

void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, ImGuiStoragePair(key, val));
        return;
    }
    it->val_p = val;
}

void ImGuiStorage::SetAllInt(int v)
{
    for (int i = 0; i < Data.Size; i++)
        Data[i].val_i = v;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)
{
    if (default_filter)
    {
        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
        Build();
    }
    else
    {
        InputBuf[0] = 0;
        CountGrep = 0;
    }
}

bool ImGuiTextFilter::Draw(const char* label, float width)
{
    if (width != 0.0f)
        ImGui::SetNextItemWidth(width);
    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));
    if (value_changed)
        Build();
    return value_changed;
}

void ImGuiTextFilter::ImGuiTextRange::split(char separator, ImVector<ImGuiTextRange>* out) const
{
    out->resize(0);
    const char* wb = b;
    const char* we = wb;
    while (we < e)
    {
        if (*we == separator)
        {
            out->push_back(ImGuiTextRange(wb, we));
            wb = we + 1;
        }
        we++;
    }
    if (wb != we)
        out->push_back(ImGuiTextRange(wb, we));
}

void ImGuiTextFilter::Build()
{
    Filters.resize(0);
    ImGuiTextRange input_range(InputBuf, InputBuf + strlen(InputBuf));
    input_range.split(',', &Filters);

    CountGrep = 0;
    for (int i = 0; i != Filters.Size; i++)
    {
        ImGuiTextRange& f = Filters[i];
        while (f.b < f.e && ImCharIsBlankA(f.b[0]))
            f.b++;
        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))
            f.e--;
        if (f.empty())
            continue;
        if (Filters[i].b[0] != '-')
            CountGrep += 1;
    }
}

bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const
{
    if (Filters.empty())
        return true;

    if (text == NULL)
        text = "";

    for (int i = 0; i != Filters.Size; i++)
    {
        const ImGuiTextRange& f = Filters[i];
        if (f.empty())
            continue;
        if (f.b[0] == '-')
        {
            // Subtract
            if (ImStristr(text, text_end, f.b + 1, f.e) != NULL)
                return false;
        }
        else
        {
            // Grep
            if (ImStristr(text, text_end, f.b, f.e) != NULL)
                return true;
        }
    }

    // Implicit * grep
    if (CountGrep == 0)
        return true;

    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextBuffer
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
#ifndef va_copy
#if defined(__GNUC__) || defined(__clang__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#else
#define va_copy(dest, src) (dest = src)
#endif
#endif

char ImGuiTextBuffer::EmptyString[1] = { 0 };

void ImGuiTextBuffer::append(const char* str, const char* str_end)
{
    int len = str_end ? (int)(str_end - str) : (int)strlen(str);

    // Add zero-terminator the first time
    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    memcpy(&Buf[write_off - 1], str, (size_t)len);
    Buf[write_off - 1 + len] = 0;
}

void ImGuiTextBuffer::appendf(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    appendfv(fmt, args);
    va_end(args);
}

// Helper: Text buffer for logging/accumulating text
void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)
{
    va_list args_copy;
    va_copy(args_copy, args);

    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
    if (len <= 0)
    {
        va_end(args_copy);
        return;
    }

    // Add zero-terminator the first time
    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
    va_end(args_copy);
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiListClipper
// This is currently not as flexible/powerful as it should be and really confusing/spaghetti, mostly because we changed
// the API mid-way through development and support two ways to using the clipper, needs some rework (see TODO)
//-----------------------------------------------------------------------------

// FIXME-TABLE: This prevents us from using ImGuiListClipper _inside_ a table cell.
// The problem we have is that without a Begin/End scheme for rows using the clipper is ambiguous.
static bool GetSkipItemForListClipping()
{
    ImGuiContext& g = *GImGui;
    return (g.CurrentTable ? g.CurrentTable->HostSkipItems : g.CurrentWindow->SkipItems);
}

// Helper to calculate coarse clipping of large list of evenly sized items.
// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.
// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX
void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.LogEnabled)
    {
        // If logging is active, do not perform any clipping
        *out_items_display_start = 0;
        *out_items_display_end = items_count;
        return;
    }
    if (GetSkipItemForListClipping())
    {
        *out_items_display_start = *out_items_display_end = 0;
        return;
    }

    // We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect
    ImRect unclipped_rect = window->ClipRect;
    if (g.NavMoveRequest)
        unclipped_rect.Add(g.NavScoringRect);
    if (g.NavJustMovedToId && window->NavLastIds[0] == g.NavJustMovedToId)
        unclipped_rect.Add(ImRect(window->Pos + window->NavRectRel[0].Min, window->Pos + window->NavRectRel[0].Max));

    const ImVec2 pos = window->DC.CursorPos;
    int start = (int)((unclipped_rect.Min.y - pos.y) / items_height);
    int end = (int)((unclipped_rect.Max.y - pos.y) / items_height);

    // When performing a navigation request, ensure we have one item extra in the direction we are moving to
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Up)
        start--;
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Down)
        end++;

    start = ImClamp(start, 0, items_count);
    end = ImClamp(end + 1, start, items_count);
    *out_items_display_start = start;
    *out_items_display_end = end;
}

static void SetCursorPosYAndSetupForPrevLine(float pos_y, float line_height)
{
    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
    // The clipper should probably have a 4th step to display the last item in a regular manner.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    float off_y = pos_y - window->DC.CursorPos.y;
    window->DC.CursorPos.y = pos_y;
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, pos_y);
    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;  // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
    window->DC.PrevLineSize.y = (line_height - g.Style.ItemSpacing.y);      // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
    if (ImGuiOldColumns* columns = window->DC.CurrentColumns)
        columns->LineMinY = window->DC.CursorPos.y;                         // Setting this so that cell Y position are set properly
    if (ImGuiTable* table = g.CurrentTable)
    {
        if (table->IsInsideRow)
            ImGui::TableEndRow(table);
        table->RowPosY2 = window->DC.CursorPos.y;
        const int row_increase = (int)((off_y / line_height) + 0.5f);
        //table->CurrentRow += row_increase; // Can't do without fixing TableEndRow()
        table->RowBgColorCounter += row_increase;
    }
}

ImGuiListClipper::ImGuiListClipper()
{
    memset(this, 0, sizeof(*this));
    ItemsCount = -1;
}

ImGuiListClipper::~ImGuiListClipper()
{
    IM_ASSERT(ItemsCount == -1 && "Forgot to call End(), or to Step() until false?");
}

// Use case A: Begin() called from constructor with items_height<0, then called again from Step() in StepNo 1
// Use case B: Begin() called from constructor with items_height>0
// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.
void ImGuiListClipper::Begin(int items_count, float items_height)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (ImGuiTable* table = g.CurrentTable)
        if (table->IsInsideRow)
            ImGui::TableEndRow(table);

    StartPosY = window->DC.CursorPos.y;
    ItemsHeight = items_height;
    ItemsCount = items_count;
    ItemsFrozen = 0;
    StepNo = 0;
    DisplayStart = -1;
    DisplayEnd = 0;
}

void ImGuiListClipper::End()
{
    if (ItemsCount < 0) // Already ended
        return;

    // In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
    if (ItemsCount < INT_MAX && DisplayStart >= 0)
        SetCursorPosYAndSetupForPrevLine(StartPosY + (ItemsCount - ItemsFrozen) * ItemsHeight, ItemsHeight);
    ItemsCount = -1;
    StepNo = 3;
}

bool ImGuiListClipper::Step()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    ImGuiTable* table = g.CurrentTable;
    if (table && table->IsInsideRow)
        ImGui::TableEndRow(table);

    // No items
    if (ItemsCount == 0 || GetSkipItemForListClipping())
    {
        End();
        return false;
    }

    // Step 0: Let you process the first element (regardless of it being visible or not, so we can measure the element height)
    if (StepNo == 0)
    {
        // While we are in frozen row state, keep displaying items one by one, unclipped
        // FIXME: Could be stored as a table-agnostic state.
        if (table != NULL && !table->IsUnfrozenRows)
        {
            DisplayStart = ItemsFrozen;
            DisplayEnd = ItemsFrozen + 1;
            ItemsFrozen++;
            return true;
        }

        StartPosY = window->DC.CursorPos.y;
        if (ItemsHeight <= 0.0f)
        {
            // Submit the first item so we can measure its height (generally it is 0..1)
            DisplayStart = ItemsFrozen;
            DisplayEnd = ItemsFrozen + 1;
            StepNo = 1;
            return true;
        }

        // Already has item height (given by user in Begin): skip to calculating step
        DisplayStart = DisplayEnd;
        StepNo = 2;
    }

    // Step 1: the clipper infer height from first element
    if (StepNo == 1)
    {
        IM_ASSERT(ItemsHeight <= 0.0f);
        if (table)
        {
            const float pos_y1 = table->RowPosY1;   // Using this instead of StartPosY to handle clipper straddling the frozen row
            const float pos_y2 = table->RowPosY2;   // Using this instead of CursorPos.y to take account of tallest cell.
            ItemsHeight = pos_y2 - pos_y1;
            window->DC.CursorPos.y = pos_y2;
        }
        else
        {
            ItemsHeight = window->DC.CursorPos.y - StartPosY;
        }
        IM_ASSERT(ItemsHeight > 0.0f && "Unable to calculate item height! First item hasn't moved the cursor vertically!");
        StepNo = 2;
    }

    // Reached end of list
    if (DisplayEnd >= ItemsCount)
    {
        End();
        return false;
    }

    // Step 2: calculate the actual range of elements to display, and position the cursor before the first element
    if (StepNo == 2)
    {
        IM_ASSERT(ItemsHeight > 0.0f);

        int already_submitted = DisplayEnd;
        ImGui::CalcListClipping(ItemsCount - already_submitted, ItemsHeight, &DisplayStart, &DisplayEnd);
        DisplayStart += already_submitted;
        DisplayEnd += already_submitted;

        // Seek cursor
        if (DisplayStart > already_submitted)
            SetCursorPosYAndSetupForPrevLine(StartPosY + (DisplayStart - ItemsFrozen) * ItemsHeight, ItemsHeight);

        StepNo = 3;
        return true;
    }

    // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd),
    // Advance the cursor to the end of the list and then returns 'false' to end the loop.
    if (StepNo == 3)
    {
        // Seek cursor
        if (ItemsCount < INT_MAX)
            SetCursorPosYAndSetupForPrevLine(StartPosY + (ItemsCount - ItemsFrozen) * ItemsHeight, ItemsHeight); // advance cursor
        ItemsCount = -1;
        return false;
    }

    IM_ASSERT(0);
    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] STYLING
//-----------------------------------------------------------------------------

ImGuiStyle& ImGui::GetStyle()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
    return GImGui->Style;
}

ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = style.Colors[idx];
    c.w *= style.Alpha * alpha_mul;
    return ColorConvertFloat4ToU32(c);
}

ImU32 ImGui::GetColorU32(const ImVec4& col)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = col;
    c.w *= style.Alpha;
    return ColorConvertFloat4ToU32(c);
}

const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)
{
    ImGuiStyle& style = GImGui->Style;
    return style.Colors[idx];
}

ImU32 ImGui::GetColorU32(ImU32 col)
{
    ImGuiStyle& style = GImGui->Style;
    if (style.Alpha >= 1.0f)
        return col;
    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
    a = (ImU32)(a * style.Alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.
    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorStack.push_back(backup);
    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorStack.push_back(backup);
    g.Style.Colors[idx] = col;
}

void ImGui::PopStyleColor(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        ImGuiColorMod& backup = g.ColorStack.back();
        g.Style.Colors[backup.Col] = backup.BackupValue;
        g.ColorStack.pop_back();
        count--;
    }
}

struct ImGuiStyleVarInfo
{
    ImGuiDataType   Type;
    ImU32           Count;
    ImU32           Offset;
    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const ImGuiCol GWindowDockStyleColors[ImGuiWindowDockStyleCol_COUNT] =
{
    ImGuiCol_Text, ImGuiCol_Tab, ImGuiCol_TabHovered, ImGuiCol_TabActive, ImGuiCol_TabUnfocused, ImGuiCol_TabUnfocusedActive
};

static const ImGuiStyleVarInfo GStyleVarInfo[] =
{
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, Alpha) },               // ImGuiStyleVar_Alpha
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowPadding) },       // ImGuiStyleVar_WindowPadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowRounding) },      // ImGuiStyleVar_WindowRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowBorderSize) },    // ImGuiStyleVar_WindowBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowMinSize) },       // ImGuiStyleVar_WindowMinSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowTitleAlign) },    // ImGuiStyleVar_WindowTitleAlign
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildRounding) },       // ImGuiStyleVar_ChildRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildBorderSize) },     // ImGuiStyleVar_ChildBorderSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupRounding) },       // ImGuiStyleVar_PopupRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupBorderSize) },     // ImGuiStyleVar_PopupBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, FramePadding) },        // ImGuiStyleVar_FramePadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameRounding) },       // ImGuiStyleVar_FrameRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameBorderSize) },     // ImGuiStyleVar_FrameBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemSpacing) },         // ImGuiStyleVar_ItemSpacing
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemInnerSpacing) },    // ImGuiStyleVar_ItemInnerSpacing
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, IndentSpacing) },       // ImGuiStyleVar_IndentSpacing
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, CellPadding) },         // ImGuiStyleVar_CellPadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarSize) },       // ImGuiStyleVar_ScrollbarSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarRounding) },   // ImGuiStyleVar_ScrollbarRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabMinSize) },         // ImGuiStyleVar_GrabMinSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabRounding) },        // ImGuiStyleVar_GrabRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, TabRounding) },         // ImGuiStyleVar_TabRounding
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ButtonTextAlign) },     // ImGuiStyleVar_ButtonTextAlign
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, SelectableTextAlign) }, // ImGuiStyleVar_SelectableTextAlign
};

static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)
{
    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
    return &GStyleVarInfo[idx];
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
    {
        ImGuiContext& g = *GImGui;
        float* pvar = (float*)var_info->GetVarPtr(&g.Style);
        g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0 && "Called PushStyleVar() float variant but variable is not a float!");
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
    {
        ImGuiContext& g = *GImGui;
        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
        g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0 && "Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!");
}

void ImGui::PopStyleVar(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
        ImGuiStyleMod& backup = g.StyleVarStack.back();
        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
        void* data = info->GetVarPtr(&g.Style);
        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
        g.StyleVarStack.pop_back();
        count--;
    }
}

const char* ImGui::GetStyleColorName(ImGuiCol idx)
{
    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
    switch (idx)
    {
    case ImGuiCol_Text: return "Text";
    case ImGuiCol_TextDisabled: return "TextDisabled";
    case ImGuiCol_WindowBg: return "WindowBg";
    case ImGuiCol_ChildBg: return "ChildBg";
    case ImGuiCol_PopupBg: return "PopupBg";
    case ImGuiCol_Border: return "Border";
    case ImGuiCol_BorderShadow: return "BorderShadow";
    case ImGuiCol_FrameBg: return "FrameBg";
    case ImGuiCol_FrameBgHovered: return "FrameBgHovered";
    case ImGuiCol_FrameBgActive: return "FrameBgActive";
    case ImGuiCol_TitleBg: return "TitleBg";
    case ImGuiCol_TitleBgActive: return "TitleBgActive";
    case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";
    case ImGuiCol_MenuBarBg: return "MenuBarBg";
    case ImGuiCol_ScrollbarBg: return "ScrollbarBg";
    case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";
    case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";
    case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";
    case ImGuiCol_CheckMark: return "CheckMark";
    case ImGuiCol_SliderGrab: return "SliderGrab";
    case ImGuiCol_SliderGrabActive: return "SliderGrabActive";
    case ImGuiCol_Button: return "Button";
    case ImGuiCol_ButtonHovered: return "ButtonHovered";
    case ImGuiCol_ButtonActive: return "ButtonActive";
    case ImGuiCol_Header: return "Header";
    case ImGuiCol_HeaderHovered: return "HeaderHovered";
    case ImGuiCol_HeaderActive: return "HeaderActive";
    case ImGuiCol_Separator: return "Separator";
    case ImGuiCol_SeparatorHovered: return "SeparatorHovered";
    case ImGuiCol_SeparatorActive: return "SeparatorActive";
    case ImGuiCol_ResizeGrip: return "ResizeGrip";
    case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";
    case ImGuiCol_ResizeGripActive: return "ResizeGripActive";
    case ImGuiCol_Tab: return "Tab";
    case ImGuiCol_TabHovered: return "TabHovered";
    case ImGuiCol_TabActive: return "TabActive";
    case ImGuiCol_TabUnfocused: return "TabUnfocused";
    case ImGuiCol_TabUnfocusedActive: return "TabUnfocusedActive";
    case ImGuiCol_DockingPreview: return "DockingPreview";
    case ImGuiCol_DockingEmptyBg: return "DockingEmptyBg";
    case ImGuiCol_PlotLines: return "PlotLines";
    case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";
    case ImGuiCol_PlotHistogram: return "PlotHistogram";
    case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";
    case ImGuiCol_TableHeaderBg: return "TableHeaderBg";
    case ImGuiCol_TableBorderStrong: return "TableBorderStrong";
    case ImGuiCol_TableBorderLight: return "TableBorderLight";
    case ImGuiCol_TableRowBg: return "TableRowBg";
    case ImGuiCol_TableRowBgAlt: return "TableRowBgAlt";
    case ImGuiCol_TextSelectedBg: return "TextSelectedBg";
    case ImGuiCol_DragDropTarget: return "DragDropTarget";
    case ImGuiCol_NavHighlight: return "NavHighlight";
    case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight";
    case ImGuiCol_NavWindowingDimBg: return "NavWindowingDimBg";
    case ImGuiCol_ModalWindowDimBg: return "ModalWindowDimBg";
    }
    IM_ASSERT(0);
    return "Unknown";
}


//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,
// we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.
// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.
//-----------------------------------------------------------------------------

const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
{
    const char* text_display_end = text;
    if (!text_end)
        text_end = (const char*)-1;

    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
        text_display_end++;
    return text_display_end;
}

// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // Hide anything after a '##' string
    const char* text_display_end;
    if (hide_text_after_hash)
    {
        text_display_end = FindRenderedTextEnd(text, text_end);
    }
    else
    {
        if (!text_end)
            text_end = text + strlen(text); // FIXME-OPT
        text_display_end = text_end;
    }

    if (text != text_display_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_display_end);
    }
}

void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = text + strlen(text); // FIXME-OPT

    if (text != text_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_end);
    }
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
    // Perform CPU side clipping for single clipped element to avoid using scissor state
    ImVec2 pos = pos_min;
    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

    // Render
    if (need_clipping)
    {
        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
    }
    else
    {
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
    }
}

void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
    // Hide anything after a '##' string
    const char* text_display_end = FindRenderedTextEnd(text, text_end);
    const int text_len = (int)(text_display_end - text);
    if (text_len == 0)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
    if (g.LogEnabled)
        LogRenderedText(&pos_min, text, text_display_end);
}


// Another overly complex function until we reorganize everything into a nice all-in-one helper.
// This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.
// This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.
void ImGui::RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end_full, const ImVec2* text_size_if_known)
{
    ImGuiContext& g = *GImGui;
    if (text_end_full == NULL)
        text_end_full = FindRenderedTextEnd(text);
    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_end_full, false, 0.0f);

    //draw_list->AddLine(ImVec2(pos_max.x, pos_min.y - 4), ImVec2(pos_max.x, pos_max.y + 4), IM_COL32(0, 0, 255, 255));
    //draw_list->AddLine(ImVec2(ellipsis_max_x, pos_min.y-2), ImVec2(ellipsis_max_x, pos_max.y+2), IM_COL32(0, 255, 0, 255));
    //draw_list->AddLine(ImVec2(clip_max_x, pos_min.y), ImVec2(clip_max_x, pos_max.y), IM_COL32(255, 0, 0, 255));
    // FIXME: We could technically remove (last_glyph->AdvanceX - last_glyph->X1) from text_size.x here and save a few pixels.
    if (text_size.x > pos_max.x - pos_min.x)
    {
        // Hello wo...
        // |       |   |
        // min   max   ellipsis_max
        //          <-> this is generally some padding value

        const ImFont* font = draw_list->_Data->Font;
        const float font_size = draw_list->_Data->FontSize;
        const char* text_end_ellipsis = NULL;

        ImWchar ellipsis_char = font->EllipsisChar;
        int ellipsis_char_count = 1;
        if (ellipsis_char == (ImWchar)-1)
        {
            ellipsis_char = (ImWchar)'.';
            ellipsis_char_count = 3;
        }
        const ImFontGlyph* glyph = font->FindGlyph(ellipsis_char);

        float ellipsis_glyph_width = glyph->X1;                 // Width of the glyph with no padding on either side
        float ellipsis_total_width = ellipsis_glyph_width;      // Full width of entire ellipsis

        if (ellipsis_char_count > 1)
        {
            // Full ellipsis size without free spacing after it.
            const float spacing_between_dots = 1.0f * (draw_list->_Data->FontSize / font->FontSize);
            ellipsis_glyph_width = glyph->X1 - glyph->X0 + spacing_between_dots;
            ellipsis_total_width = ellipsis_glyph_width * (float)ellipsis_char_count - spacing_between_dots;
        }

        // We can now claim the space between pos_max.x and ellipsis_max.x
        const float text_avail_width = ImMax((ImMax(pos_max.x, ellipsis_max_x) - ellipsis_total_width) - pos_min.x, 1.0f);
        float text_size_clipped_x = font->CalcTextSizeA(font_size, text_avail_width, 0.0f, text, text_end_full, &text_end_ellipsis).x;
        if (text == text_end_ellipsis && text_end_ellipsis < text_end_full)
        {
            // Always display at least 1 character if there's no room for character + ellipsis
            text_end_ellipsis = text + ImTextCountUtf8BytesFromChar(text, text_end_full);
            text_size_clipped_x = font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text, text_end_ellipsis).x;
        }
        while (text_end_ellipsis > text && ImCharIsBlankA(text_end_ellipsis[-1]))
        {
            // Trim trailing space before ellipsis (FIXME: Supporting non-ascii blanks would be nice, for this we need a function to backtrack in UTF-8 text)
            text_end_ellipsis--;
            text_size_clipped_x -= font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text_end_ellipsis, text_end_ellipsis + 1).x; // Ascii blanks are always 1 byte
        }

        // Render text, render ellipsis
        RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_ellipsis, &text_size, ImVec2(0.0f, 0.0f));
        float ellipsis_x = pos_min.x + text_size_clipped_x;
        if (ellipsis_x + ellipsis_total_width <= ellipsis_max_x)
            for (int i = 0; i < ellipsis_char_count; i++)
            {
                font->RenderChar(draw_list, font_size, ImVec2(ellipsis_x, pos_min.y), GetColorU32(ImGuiCol_Text), ellipsis_char);
                ellipsis_x += ellipsis_glyph_width;
            }
    }
    else
    {
        RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_full, &text_size, ImVec2(0.0f, 0.0f));
    }

    if (g.LogEnabled)
        LogRenderedText(&pos_min, text, text_end_full);
}

// Render a rectangle shaped with optional rounding and borders
void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
    const float border_size = g.Style.FrameBorderSize;
    if (border && border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
    }
}

void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const float border_size = g.Style.FrameBorderSize;
    if (border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
    }
}

void ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (id != g.NavId)
        return;
    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
        return;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->DC.NavHideHighlightOneFrame)
        return;

    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
    ImRect display_rect = bb;
    display_rect.ClipWith(window->ClipRect);
    if (flags & ImGuiNavHighlightFlags_TypeDefault)
    {
        const float THICKNESS = 2.0f;
        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
        display_rect.Expand(ImVec2(DISTANCE, DISTANCE));
        bool fully_visible = window->ClipRect.Contains(display_rect);
        if (!fully_visible)
            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), display_rect.Max - ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, 0, THICKNESS);
        if (!fully_visible)
            window->DrawList->PopClipRect();
    }
    if (flags & ImGuiNavHighlightFlags_TypeThin)
    {
        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, 0, 1.0f);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
ImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name) : DrawListInst(NULL)
{
    memset(this, 0, sizeof(*this));
    Name = ImStrdup(name);
    NameBufLen = (int)strlen(name) + 1;
    ID = ImHashStr(name);
    IDStack.push_back(ID);
    ViewportAllowPlatformMonitorExtend = -1;
    ViewportPos = ImVec2(FLT_MAX, FLT_MAX);
    MoveId = GetID("#MOVE");
    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
    AutoFitFramesX = AutoFitFramesY = -1;
    AutoPosLastDirection = ImGuiDir_None;
    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = SetWindowDockAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);
    LastFrameActive = -1;
    LastFrameJustFocused = -1;
    LastTimeActive = -1.0f;
    FontWindowScale = FontDpiScale = 1.0f;
    SettingsOffset = -1;
    DockOrder = -1;
    DrawList = &DrawListInst;
    DrawList->_Data = &context->DrawListSharedData;
    DrawList->_OwnerName = Name;
}

ImGuiWindow::~ImGuiWindow()
{
    IM_ASSERT(DrawList == &DrawListInst);
    IM_DELETE(Name);
    for (int i = 0; i != ColumnsStorage.Size; i++)
        ColumnsStorage[i].~ImGuiOldColumns();
}

ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
    ImGui::KeepAliveID(id);
#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiContext& g = *GImGui;
    IMGUI_TEST_ENGINE_ID_INFO2(id, ImGuiDataType_String, str, str_end);
#endif
    return id;
}

ImGuiID ImGuiWindow::GetID(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);
    ImGui::KeepAliveID(id);
#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiContext& g = *GImGui;
    IMGUI_TEST_ENGINE_ID_INFO(id, ImGuiDataType_Pointer, ptr);
#endif
    return id;
}

ImGuiID ImGuiWindow::GetID(int n)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashData(&n, sizeof(n), seed);
    ImGui::KeepAliveID(id);
#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiContext& g = *GImGui;
    IMGUI_TEST_ENGINE_ID_INFO(id, ImGuiDataType_S32, (intptr_t)n);
#endif
    return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiContext& g = *GImGui;
    IMGUI_TEST_ENGINE_ID_INFO2(id, ImGuiDataType_String, str, str_end);
#endif
    return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);
#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiContext& g = *GImGui;
    IMGUI_TEST_ENGINE_ID_INFO(id, ImGuiDataType_Pointer, ptr);
#endif
    return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(int n)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashData(&n, sizeof(n), seed);
#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiContext& g = *GImGui;
    IMGUI_TEST_ENGINE_ID_INFO(id, ImGuiDataType_S32, (intptr_t)n);
#endif
    return id;
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)
{
    ImGuiID seed = IDStack.back();
    const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };
    ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);
    ImGui::KeepAliveID(id);
    return id;
}

static void SetCurrentWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow = window;
    g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;
    if (window)
        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void ImGui::GcCompactTransientMiscBuffers()
{
    ImGuiContext& g = *GImGui;
    g.ItemFlagsStack.clear();
    g.GroupStack.clear();
    TableGcCompactSettings();
}

// Free up/compact internal window buffers, we can use this when a window becomes unused.
// Not freed:
// - ImGuiWindow, ImGuiWindowSettings, Name, StateStorage, ColumnsStorage (may hold useful data)
// This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.
void ImGui::GcCompactTransientWindowBuffers(ImGuiWindow* window)
{
    window->MemoryCompacted = true;
    window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
    window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
    window->IDStack.clear();
    window->DrawList->_ClearFreeMemory();
    window->DC.ChildWindows.clear();
    window->DC.ItemWidthStack.clear();
    window->DC.TextWrapPosStack.clear();
}

void ImGui::GcAwakeTransientWindowBuffers(ImGuiWindow* window)
{
    // We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
    // The other buffers tends to amortize much faster.
    window->MemoryCompacted = false;
    window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);
    window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);
    window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
}

void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.ActiveIdIsJustActivated = (g.ActiveId != id);
    if (g.ActiveIdIsJustActivated)
    {
        g.ActiveIdTimer = 0.0f;
        g.ActiveIdHasBeenPressedBefore = false;
        g.ActiveIdHasBeenEditedBefore = false;
        g.ActiveIdMouseButton = -1;
        if (id != 0)
        {
            g.LastActiveId = id;
            g.LastActiveIdTimer = 0.0f;
        }
    }
    g.ActiveId = id;
    g.ActiveIdAllowOverlap = false;
    g.ActiveIdNoClearOnFocusLoss = false;
    g.ActiveIdWindow = window;
    g.ActiveIdHasBeenEditedThisFrame = false;
    if (id)
    {
        g.ActiveIdIsAlive = id;
        g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
    }

    // Clear declaration of inputs claimed by the widget
    // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
    g.ActiveIdUsingMouseWheel = false;
    g.ActiveIdUsingNavDirMask = 0x00;
    g.ActiveIdUsingNavInputMask = 0x00;
    g.ActiveIdUsingKeyInputMask = 0x00;
}

void ImGui::ClearActiveID()
{
    SetActiveID(0, NULL); // g.ActiveId = 0;
}

void ImGui::SetHoveredID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.HoveredId = id;
    g.HoveredIdAllowOverlap = false;
    g.HoveredIdUsingMouseWheel = false;
    if (id != 0 && g.HoveredIdPreviousFrame != id)
        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
}

ImGuiID ImGui::GetHoveredID()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

void ImGui::KeepAliveID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
        g.ActiveIdIsAlive = id;
    if (g.ActiveIdPreviousFrame == id)
        g.ActiveIdPreviousFrameIsAlive = true;
}

void ImGui::MarkItemEdited(ImGuiID id)
{
    // This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().
    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);
    IM_UNUSED(id); // Avoid unused variable warnings when asserts are compiled out.
    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
    g.ActiveIdHasBeenEditedThisFrame = true;
    g.ActiveIdHasBeenEditedBefore = true;
    g.CurrentWindow->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;
}

static inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)
{
    // An active popup disable hovering on other windows (apart from its own children)
    // FIXME-OPT: This could be cached/stored within the window.
    ImGuiContext& g = *GImGui;
    if (g.NavWindow)
        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindowDockTree)
            if (focused_root_window->WasActive && focused_root_window != window->RootWindowDockTree)
            {
                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
                // NB: The order of those two tests is important because Modal windows are also Popups.
                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
                    return false;
                if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
                    return false;
            }

    // Filter by viewport
    if (window->Viewport != g.MouseViewport)
        if (g.MovingWindow == NULL || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree)
            return false;

    return true;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavDisableMouseHover && !g.NavDisableHighlight)
        return IsItemFocused();

    // Test for bounding box overlap, as updated as ItemAdd()
    ImGuiItemStatusFlags status_flags = window->DC.LastItemStatusFlags;
    if (!(status_flags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function

    // Test if we are hovering the right window (our window could be behind another window)
    // [2021/03/02] Reworked / reverted the revert, finally. Note we want e.g. BeginGroup/ItemAdd/EndGroup to work as well. (#3851)
    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable
    // to use IsItemHovered() after EndChild() itself. Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was
    // the test that has been running for a long while.
    if (g.HoveredWindow != window && (status_flags & ImGuiItemStatusFlags_HoveredWindow) == 0)
        if ((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0)
            return false;

    // Test if another item is active (e.g. being dragged)
    if ((flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) == 0)
        if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)
            return false;

    // Test if interactions on this window are blocked by an active popup or modal.
    // The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.
    if (!IsWindowContentHoverable(window, flags))
        return false;

    // Test if the item is disabled
    if ((g.CurrentItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
        return false;

    // Special handling for calling after Begin() which represent the title bar or tab.
    // When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
    if ((window->DC.LastItemId == window->ID || window->DC.LastItemId == window->MoveId) && window->WriteAccessed)
        return false;
    return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow != window)
        return false;
    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        return false;
    if (!IsMouseHoveringRect(bb.Min, bb.Max))
        return false;
    if (g.NavDisableMouseHover)
        return false;
    if (!IsWindowContentHoverable(window, ImGuiHoveredFlags_None) || (g.CurrentItemFlags & ImGuiItemFlags_Disabled))
    {
        g.HoveredIdDisabled = true;
        return false;
    }

    // We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
    // hover test in widgets code. We could also decide to split this function is two.
    if (id != 0)
    {
        SetHoveredID(id);

        // [DEBUG] Item Picker tool!
        // We perform the check here because SetHoveredID() is not frequently called (1~ time a frame), making
        // the cost of this tool near-zero. We can get slightly better call-stack and support picking non-hovered
        // items if we perform the test in ItemAdd(), but that would incur a small runtime cost.
        // #define IMGUI_DEBUG_TOOL_ITEM_PICKER_EX in imconfig.h if you want this check to also be performed in ItemAdd().
        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
            GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
        if (g.DebugItemPickerBreakId == id)
            IM_DEBUG_BREAK();
    }

    return true;
}

bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!bb.Overlaps(window->ClipRect))
        if (id == 0 || (id != g.ActiveId && id != g.NavId))
            if (clip_even_when_logged || !g.LogEnabled)
                return true;
    return false;
}

// This is also inlined in ItemAdd()
// Note: if ImGuiItemStatusFlags_HasDisplayRect is set, user needs to set window->DC.LastItemDisplayRect!
void ImGui::SetLastItemData(ImGuiWindow* window, ImGuiID item_id, ImGuiItemStatusFlags item_flags, const ImRect& item_rect)
{
    window->DC.LastItemId = item_id;
    window->DC.LastItemStatusFlags = item_flags;
    window->DC.LastItemRect = item_rect;
}

// Process TAB/Shift+TAB. Be mindful that this function may _clear_ the ActiveID when tabbing out.
void ImGui::ItemFocusable(ImGuiWindow* window, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(id != 0 && id == window->DC.LastItemId);

    // Increment counters
    // FIXME: ImGuiItemFlags_Disabled should disable more.
    const bool is_tab_stop = (g.CurrentItemFlags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;
    window->DC.FocusCounterRegular++;
    if (is_tab_stop)
    {
        window->DC.FocusCounterTabStop++;
        if (g.NavId == id)
            g.NavIdTabCounter = window->DC.FocusCounterTabStop;
    }

    // Process TAB/Shift-TAB to tab *OUT* of the currently focused item.
    // (Note that we can always TAB out of a widget that doesn't allow tabbing in)
    if (g.ActiveId == id && g.TabFocusPressed && !IsActiveIdUsingKey(ImGuiKey_Tab) && g.TabFocusRequestNextWindow == NULL)
    {
        g.TabFocusRequestNextWindow = window;
        g.TabFocusRequestNextCounterTabStop = window->DC.FocusCounterTabStop + (g.IO.KeyShift ? (is_tab_stop ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.
    }

    // Handle focus requests
    if (g.TabFocusRequestCurrWindow == window)
    {
        if (window->DC.FocusCounterRegular == g.TabFocusRequestCurrCounterRegular)
        {
            window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_FocusedByCode;
            return;
        }
        if (is_tab_stop && window->DC.FocusCounterTabStop == g.TabFocusRequestCurrCounterTabStop)
        {
            g.NavJustTabbedId = id;
            window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_FocusedByTabbing;
            return;
        }

        // If another item is about to be focused, we clear our own active id
        if (g.ActiveId == id)
            ClearActiveID();
    }
}

float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
{
    if (wrap_pos_x < 0.0f)
        return 0.0f;

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (wrap_pos_x == 0.0f)
    {
        // We could decide to setup a default wrapping max point for auto-resizing windows,
        // or have auto-wrap (with unspecified wrapping pos) behave as a ContentSize extending function?
        //if (window->Hidden && (window->Flags & ImGuiWindowFlags_AlwaysAutoResize))
        //    wrap_pos_x = ImMax(window->WorkRect.Min.x + g.FontSize * 10.0f, window->WorkRect.Max.x);
        //else
        wrap_pos_x = window->WorkRect.Max.x;
    }
    else if (wrap_pos_x > 0.0f)
    {
        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space
    }

    return ImMax(wrap_pos_x - pos.x, 1.0f);
}

// IM_ALLOC() == ImGui::MemAlloc()
void* ImGui::MemAlloc(size_t size)
{
    if (ImGuiContext* ctx = GImGui)
        ctx->IO.MetricsActiveAllocations++;
    return (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
}

// IM_FREE() == ImGui::MemFree()
void ImGui::MemFree(void* ptr)
{
    if (ptr)
        if (ImGuiContext* ctx = GImGui)
            ctx->IO.MetricsActiveAllocations--;
    return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
}

const char* ImGui::GetClipboardText()
{
    ImGuiContext& g = *GImGui;
    return g.IO.GetClipboardTextFn ? g.IO.GetClipboardTextFn(g.IO.ClipboardUserData) : "";
}

void ImGui::SetClipboardText(const char* text)
{
    ImGuiContext& g = *GImGui;
    if (g.IO.SetClipboardTextFn)
        g.IO.SetClipboardTextFn(g.IO.ClipboardUserData, text);
}

const char* ImGui::GetVersion()
{
    return IMGUI_VERSION;
}

// Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
ImGuiContext* ImGui::GetCurrentContext()
{
    return GImGui;
}

void ImGui::SetCurrentContext(ImGuiContext* ctx)
{
#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
#else
    GImGui = ctx;
#endif
}

void ImGui::SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data)
{
    GImAllocatorAllocFunc = alloc_func;
    GImAllocatorFreeFunc = free_func;
    GImAllocatorUserData = user_data;
}

// This is provided to facilitate copying allocators from one static/DLL boundary to another (e.g. retrieve default allocator of your executable address space)
void ImGui::GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data)
{
    *p_alloc_func = GImAllocatorAllocFunc;
    *p_free_func = GImAllocatorFreeFunc;
    *p_user_data = GImAllocatorUserData;
}

ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
{
    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
    if (GImGui == NULL)
        SetCurrentContext(ctx);
    Initialize(ctx);
    return ctx;
}

void ImGui::DestroyContext(ImGuiContext* ctx)
{
    if (ctx == NULL)
        ctx = GImGui;
    Shutdown(ctx);
    if (GImGui == ctx)
        SetCurrentContext(NULL);
    IM_DELETE(ctx);
}

// No specific ordering/dependency support, will see as needed
ImGuiID ImGui::AddContextHook(ImGuiContext* ctx, const ImGuiContextHook* hook)
{
    ImGuiContext& g = *ctx;
    IM_ASSERT(hook->Callback != NULL && hook->HookId == 0 && hook->Type != ImGuiContextHookType_PendingRemoval_);
    g.Hooks.push_back(*hook);
    g.Hooks.back().HookId = ++g.HookIdNext;
    return g.HookIdNext;
}

// Deferred removal, avoiding issue with changing vector while iterating it
void ImGui::RemoveContextHook(ImGuiContext* ctx, ImGuiID hook_id)
{
    ImGuiContext& g = *ctx;
    IM_ASSERT(hook_id != 0);
    for (int n = 0; n < g.Hooks.Size; n++)
        if (g.Hooks[n].HookId == hook_id)
            g.Hooks[n].Type = ImGuiContextHookType_PendingRemoval_;
}

// Call context hooks (used by e.g. test engine)
// We assume a small number of hooks so all stored in same array
void ImGui::CallContextHooks(ImGuiContext* ctx, ImGuiContextHookType hook_type)
{
    ImGuiContext& g = *ctx;
    for (int n = 0; n < g.Hooks.Size; n++)
        if (g.Hooks[n].Type == hook_type)
            g.Hooks[n].Callback(&g, &g.Hooks[n]);
}

ImGuiIO& ImGui::GetIO()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
    return GImGui->IO;
}

ImGuiPlatformIO& ImGui::GetPlatformIO()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    return GImGui->PlatformIO;
}

// Pass this to your backend rendering function! Valid after Render() and until the next call to NewFrame()
ImDrawData* ImGui::GetDrawData()
{
    ImGuiContext& g = *GImGui;
    ImGuiViewportP* viewport = g.Viewports[0];
    return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
}

double ImGui::GetTime()
{
    return GImGui->Time;
}

int ImGui::GetFrameCount()
{
    return GImGui->FrameCount;
}

static ImDrawList* GetViewportDrawList(ImGuiViewportP* viewport, size_t drawlist_no, const char* drawlist_name)
{
    // Create the draw list on demand, because they are not frequently used for all viewports
    ImGuiContext& g = *GImGui;
    IM_ASSERT(drawlist_no < IM_ARRAYSIZE(viewport->DrawLists));
    ImDrawList* draw_list = viewport->DrawLists[drawlist_no];
    if (draw_list == NULL)
    {
        draw_list = IM_NEW(ImDrawList)(&g.DrawListSharedData);
        draw_list->_OwnerName = drawlist_name;
        viewport->DrawLists[drawlist_no] = draw_list;
    }

    // Our ImDrawList system requires that there is always a command
    if (viewport->DrawListsLastFrame[drawlist_no] != g.FrameCount)
    {
        draw_list->_ResetForNewFrame();
        draw_list->PushTextureID(g.IO.Fonts->TexID);
        draw_list->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size, false);
        viewport->DrawListsLastFrame[drawlist_no] = g.FrameCount;
    }
    return draw_list;
}

ImDrawList* ImGui::GetBackgroundDrawList(ImGuiViewport* viewport)
{
    return GetViewportDrawList((ImGuiViewportP*)viewport, 0, "##Background");
}

ImDrawList* ImGui::GetBackgroundDrawList()
{
    ImGuiContext& g = *GImGui;
    return GetBackgroundDrawList(g.CurrentWindow->Viewport);
}

ImDrawList* ImGui::GetForegroundDrawList(ImGuiViewport* viewport)
{
    return GetViewportDrawList((ImGuiViewportP*)viewport, 1, "##Foreground");
}

ImDrawList* ImGui::GetForegroundDrawList()
{
    ImGuiContext& g = *GImGui;
    return GetForegroundDrawList(g.CurrentWindow->Viewport);
}

ImDrawListSharedData* ImGui::GetDrawListSharedData()
{
    return &GImGui->DrawListSharedData;
}

void ImGui::StartMouseMovingWindow(ImGuiWindow* window)
{
    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
    // This is because we want ActiveId to be set even when the window is not permitted to move.
    ImGuiContext& g = *GImGui;
    FocusWindow(window);
    SetActiveID(window->MoveId, window);
    g.NavDisableHighlight = true;
    g.ActiveIdNoClearOnFocusLoss = true;
    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindowDockTree->Pos;

    bool can_move_window = true;
    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoMove))
        can_move_window = false;
    if (ImGuiDockNode* node = window->DockNodeAsHost)
        if (node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove))
            can_move_window = false;
    if (can_move_window)
        g.MovingWindow = window;
}

// We use 'undock_floating_node == false' when dragging from title bar to allow moving groups of floating nodes without undocking them.
// - undock_floating_node == true: when dragging from a floating node within a hierarchy, always undock the node.
// - undock_floating_node == false: when dragging from a floating node within a hierarchy, move root window.
void ImGui::StartMouseMovingWindowOrNode(ImGuiWindow* window, ImGuiDockNode* node, bool undock_floating_node)
{
    ImGuiContext& g = *GImGui;
    bool can_undock_node = false;
    if (node != NULL && node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove) == 0)
    {
        // Can undock if:
        // - part of a floating node hierarchy with more than one visible node (if only one is visible, we'll just move the whole hierarchy)
        // - part of a dockspace node hierarchy (trivia: undocking from a fixed/central node will create a new node and copy windows)
        ImGuiDockNode* root_node = DockNodeGetRootNode(node);
        if (root_node->OnlyNodeWithWindows != node || root_node->CentralNode != NULL)   // -V1051 PVS-Studio thinks node should be root_node and is wrong about that.
            if (undock_floating_node || root_node->IsDockSpace())
                can_undock_node = true;
    }

    const bool clicked = IsMouseClicked(0);
    const bool dragging = IsMouseDragging(0, g.IO.MouseDragThreshold * 1.70f);
    if (can_undock_node && dragging)
        DockContextQueueUndockNode(&g, node); // Will lead to DockNodeStartMouseMovingWindow() -> StartMouseMovingWindow() being called next frame
    else if (!can_undock_node && (clicked || dragging) && g.MovingWindow != window)
        StartMouseMovingWindow(window);
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
// FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow->MoveId.
// This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,
// but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.
void ImGui::UpdateMouseMovingWindowNewFrame()
{
    ImGuiContext& g = *GImGui;
    if (g.MovingWindow != NULL)
    {
        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
        KeepAliveID(g.ActiveId);
        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindowDockTree);
        ImGuiWindow* moving_window = g.MovingWindow->RootWindowDockTree;
        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))
        {
            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
            {
                MarkIniSettingsDirty(moving_window);
                SetWindowPos(moving_window, pos, ImGuiCond_Always);
                if (moving_window->ViewportOwned) // Synchronize viewport immediately because some overlays may relies on clipping rectangle before we Begin() into the window.
                {
                    moving_window->Viewport->Pos = pos;
                    moving_window->Viewport->UpdateWorkRect();
                }
            }
            FocusWindow(g.MovingWindow);
        }
        else
        {
            // Try to merge the window back into the main viewport.
            // This works because MouseViewport should be != MovingWindow->Viewport on release (as per code in UpdateViewports)
            if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
                UpdateTryMergeWindowIntoHostViewport(moving_window, g.MouseViewport);

            // Restore the mouse viewport so that we don't hover the viewport _under_ the moved window during the frame we released the mouse button.
            if (!IsDragDropPayloadBeingAccepted())
                g.MouseViewport = moving_window->Viewport;

            // Clear the NoInput window flag set by the Viewport system
            moving_window->Viewport->Flags &= ~ImGuiViewportFlags_NoInputs; // FIXME-VIEWPORT: Test engine managed to crash here because Viewport was NULL.

            ClearActiveID();
            g.MovingWindow = NULL;
        }
    }
    else
    {
        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
        {
            KeepAliveID(g.ActiveId);
            if (!g.IO.MouseDown[0])
                ClearActiveID();
        }
    }
}

// Initiate moving window when clicking on empty space or title bar.
// Handle left-click and right-click focus.
void ImGui::UpdateMouseMovingWindowEndFrame()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId != 0 || g.HoveredId != 0)
        return;

    // Unless we just made a window/popup appear
    if (g.NavWindow && g.NavWindow->Appearing)
        return;

    // Click on empty space to focus window and start moving
    // (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
    if (g.IO.MouseClicked[0])
    {
        // Handle the edge case of a popup being closed while clicking in its empty space.
        // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
        ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
        const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);

        if (root_window != NULL && !is_closed_popup)
        {
            StartMouseMovingWindow(g.HoveredWindow); //-V595

            // Cancel moving if clicked outside of title bar
            if (g.IO.ConfigWindowsMoveFromTitleBarOnly)
                if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar) || root_window->DockIsActive)
                    if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
                        g.MovingWindow = NULL;

            // Cancel moving if clicked over an item which was disabled or inhibited by popups (note that we know HoveredId == 0 already)
            if (g.HoveredIdDisabled)
                g.MovingWindow = NULL;
        }
        else if (root_window == NULL && g.NavWindow != NULL && GetTopMostPopupModal() == NULL)
        {
            // Clicking on void disable focus
            FocusWindow(NULL);
        }
    }

    // With right mouse button we close popups without changing focus based on where the mouse is aimed
    // Instead, focus will be restored to the window under the bottom-most closed popup.
    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
    if (g.IO.MouseClicked[1])
    {
        // Find the top-most window between HoveredWindow and the top-most Modal Window.
        // This is where we can trim the popup stack.
        ImGuiWindow* modal = GetTopMostPopupModal();
        bool hovered_window_above_modal = g.HoveredWindow && IsWindowAbove(g.HoveredWindow, modal);
        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
    }
}

static void TranslateWindow(ImGuiWindow* window, const ImVec2& delta)
{
    window->Pos += delta;
    window->ClipRect.Translate(delta);
    window->OuterRectClipped.Translate(delta);
    window->InnerRect.Translate(delta);
    window->DC.CursorPos += delta;
    window->DC.CursorStartPos += delta;
    window->DC.CursorMaxPos += delta;
    window->DC.LastItemRect.Translate(delta);
    window->DC.LastItemDisplayRect.Translate(delta);
}

static void ScaleWindow(ImGuiWindow* window, float scale)
{
    ImVec2 origin = window->Viewport->Pos;
    window->Pos = ImFloor((window->Pos - origin) * scale + origin);
    window->Size = ImFloor(window->Size * scale);
    window->SizeFull = ImFloor(window->SizeFull * scale);
    window->ContentSize = ImFloor(window->ContentSize * scale);
}

static bool IsWindowActiveAndVisible(ImGuiWindow* window)
{
    return (window->Active) && (!window->Hidden);
}

static void ImGui::UpdateMouseInputs()
{
    ImGuiContext& g = *GImGui;

    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
    if (IsMousePosValid(&g.IO.MousePos))
        g.IO.MousePos = g.LastValidMousePos = ImFloor(g.IO.MousePos);

    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
    if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))
        g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;
    else
        g.IO.MouseDelta = ImVec2(0.0f, 0.0f);
    if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)
        g.NavDisableMouseHover = false;

    g.IO.MousePosPrev = g.IO.MousePos;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;
        g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;
        g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];
        g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;
        g.IO.MouseDoubleClicked[i] = false;
        if (g.IO.MouseClicked[i])
        {
            if ((float)(g.Time - g.IO.MouseClickedTime[i]) < g.IO.MouseDoubleClickTime)
            {
                ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
                if (ImLengthSqr(delta_from_click_pos) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)
                    g.IO.MouseDoubleClicked[i] = true;
                g.IO.MouseClickedTime[i] = -g.IO.MouseDoubleClickTime * 2.0f; // Mark as "old enough" so the third click isn't turned into a double-click
            }
            else
            {
                g.IO.MouseClickedTime[i] = g.Time;
            }
            g.IO.MouseClickedPos[i] = g.IO.MousePos;
            g.IO.MouseDownWasDoubleClick[i] = g.IO.MouseDoubleClicked[i];
            g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;
        }
        else if (g.IO.MouseDown[i])
        {
            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
            ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
            g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
            g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
        }
        if (!g.IO.MouseDown[i] && !g.IO.MouseReleased[i])
            g.IO.MouseDownWasDoubleClick[i] = false;
        if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
            g.NavDisableMouseHover = false;
    }
}

static void StartLockWheelingWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.WheelingWindow == window)
        return;
    g.WheelingWindow = window;
    g.WheelingWindowRefMousePos = g.IO.MousePos;
    g.WheelingWindowTimer = WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER;
}

void ImGui::UpdateMouseWheel()
{
    ImGuiContext& g = *GImGui;

    // Reset the locked window if we move the mouse or after the timer elapses
    if (g.WheelingWindow != NULL)
    {
        g.WheelingWindowTimer -= g.IO.DeltaTime;
        if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
            g.WheelingWindowTimer = 0.0f;
        if (g.WheelingWindowTimer <= 0.0f)
        {
            g.WheelingWindow = NULL;
            g.WheelingWindowTimer = 0.0f;
        }
    }

    if (g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f)
        return;

    if ((g.ActiveId != 0 && g.ActiveIdUsingMouseWheel) || (g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrameUsingMouseWheel))
        return;

    ImGuiWindow* window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
    if (!window || window->Collapsed)
        return;

    // Zoom / Scale window
    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
    if (g.IO.MouseWheel != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
    {
        StartLockWheelingWindow(window);
        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
        const float scale = new_font_scale / window->FontWindowScale;
        window->FontWindowScale = new_font_scale;
        if (window == window->RootWindow)
        {
            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
            SetWindowPos(window, window->Pos + offset, 0);
            window->Size = ImFloor(window->Size * scale);
            window->SizeFull = ImFloor(window->SizeFull * scale);
        }
        return;
    }

    // Mouse wheel scrolling
    // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent
    if (g.IO.KeyCtrl)
        return;

    // As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
    // (we avoid doing it on OSX as it the OS input layer handles this already)
    const bool swap_axis = g.IO.KeyShift && !g.IO.ConfigMacOSXBehaviors;
    const float wheel_y = swap_axis ? 0.0f : g.IO.MouseWheel;
    const float wheel_x = swap_axis ? g.IO.MouseWheel : g.IO.MouseWheelH;

    // Vertical Mouse Wheel scrolling
    if (wheel_y != 0.0f)
    {
        StartLockWheelingWindow(window);
        while ((window->Flags & ImGuiWindowFlags_ChildWindow) && ((window->ScrollMax.y == 0.0f) || ((window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))))
            window = window->ParentWindow;
        if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
        {
            float max_step = window->InnerRect.GetHeight() * 0.67f;
            float scroll_step = ImFloor(ImMin(5 * window->CalcFontSize(), max_step));
            SetScrollY(window, window->Scroll.y - wheel_y * scroll_step);
        }
    }

    // Horizontal Mouse Wheel scrolling, or Vertical Mouse Wheel w/ Shift held
    if (wheel_x != 0.0f)
    {
        StartLockWheelingWindow(window);
        while ((window->Flags & ImGuiWindowFlags_ChildWindow) && ((window->ScrollMax.x == 0.0f) || ((window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))))
            window = window->ParentWindow;
        if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
        {
            float max_step = window->InnerRect.GetWidth() * 0.67f;
            float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step));
            SetScrollX(window, window->Scroll.x - wheel_x * scroll_step);
        }
    }
}

void ImGui::UpdateTabFocus()
{
    ImGuiContext& g = *GImGui;

    // Pressing TAB activate widget focus
    g.TabFocusPressed = (g.NavWindow && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab));
    if (g.ActiveId == 0 && g.TabFocusPressed)
    {
        // - This path is only taken when no widget are active/tabbed-into yet.
        //   Subsequent tabbing will be processed by FocusableItemRegister()
        // - Note that SetKeyboardFocusHere() sets the Next fields mid-frame. To be consistent we also
        //   manipulate the Next fields here even though they will be turned into Curr fields below.
        g.TabFocusRequestNextWindow = g.NavWindow;
        g.TabFocusRequestNextCounterRegular = INT_MAX;
        if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)
            g.TabFocusRequestNextCounterTabStop = g.NavIdTabCounter + (g.IO.KeyShift ? -1 : 0);
        else
            g.TabFocusRequestNextCounterTabStop = g.IO.KeyShift ? -1 : 0;
    }

    // Turn queued focus request into current one
    g.TabFocusRequestCurrWindow = NULL;
    g.TabFocusRequestCurrCounterRegular = g.TabFocusRequestCurrCounterTabStop = INT_MAX;
    if (g.TabFocusRequestNextWindow != NULL)
    {
        ImGuiWindow* window = g.TabFocusRequestNextWindow;
        g.TabFocusRequestCurrWindow = window;
        if (g.TabFocusRequestNextCounterRegular != INT_MAX && window->DC.FocusCounterRegular != -1)
            g.TabFocusRequestCurrCounterRegular = ImModPositive(g.TabFocusRequestNextCounterRegular, window->DC.FocusCounterRegular + 1);
        if (g.TabFocusRequestNextCounterTabStop != INT_MAX && window->DC.FocusCounterTabStop != -1)
            g.TabFocusRequestCurrCounterTabStop = ImModPositive(g.TabFocusRequestNextCounterTabStop, window->DC.FocusCounterTabStop + 1);
        g.TabFocusRequestNextWindow = NULL;
        g.TabFocusRequestNextCounterRegular = g.TabFocusRequestNextCounterTabStop = INT_MAX;
    }

    g.NavIdTabCounter = INT_MAX;
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
void ImGui::UpdateHoveredWindowAndCaptureFlags()
{
    ImGuiContext& g = *GImGui;
    g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));

    // Find the window hovered by mouse:
    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
    bool clear_hovered_windows = false;
    FindHoveredWindow();
    IM_ASSERT(g.HoveredWindow == NULL || g.HoveredWindow == g.MovingWindow || g.HoveredWindow->Viewport == g.MouseViewport);

    // Modal windows prevents mouse from hovering behind them.
    ImGuiWindow* modal_window = GetTopMostPopupModal();
    if (modal_window && g.HoveredWindow && !IsWindowChildOf(g.HoveredWindow->RootWindowDockTree, modal_window))
        clear_hovered_windows = true;

    // Disabled mouse?
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse)
        clear_hovered_windows = true;

    // We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.
    int mouse_earliest_button_down = -1;
    bool mouse_any_down = false;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        if (g.IO.MouseClicked[i])
            g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (g.OpenPopupStack.Size > 0);
        mouse_any_down |= g.IO.MouseDown[i];
        if (g.IO.MouseDown[i])
            if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])
                mouse_earliest_button_down = i;
    }
    const bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];

    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
    if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)
        clear_hovered_windows = true;

    if (clear_hovered_windows)
        g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;

    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to Dear ImGui + app)
    if (g.WantCaptureMouseNextFrame != -1)
        g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);
    else
        g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (g.OpenPopupStack.Size > 0);

    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to Dear ImGui + app)
    if (g.WantCaptureKeyboardNextFrame != -1)
        g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
    else
        g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
    if (g.IO.NavActive && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
        g.IO.WantCaptureKeyboard = true;

    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
}

ImGuiKeyModFlags ImGui::GetMergedKeyModFlags()
{
    ImGuiContext& g = *GImGui;
    ImGuiKeyModFlags key_mod_flags = ImGuiKeyModFlags_None;
    if (g.IO.KeyCtrl)   { key_mod_flags |= ImGuiKeyModFlags_Ctrl; }
    if (g.IO.KeyShift)  { key_mod_flags |= ImGuiKeyModFlags_Shift; }
    if (g.IO.KeyAlt)    { key_mod_flags |= ImGuiKeyModFlags_Alt; }
    if (g.IO.KeySuper)  { key_mod_flags |= ImGuiKeyModFlags_Super; }
    return key_mod_flags;
}

void ImGui::NewFrame()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
    ImGuiContext& g = *GImGui;

    // Remove pending delete hooks before frame start.
    // This deferred removal avoid issues of removal while iterating the hook vector
    for (int n = g.Hooks.Size - 1; n >= 0; n--)
        if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
            g.Hooks.erase(&g.Hooks[n]);

    CallContextHooks(&g, ImGuiContextHookType_NewFramePre);

    // Check and assert for various common IO and Configuration mistakes
    g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame;
    ErrorCheckNewFrameSanityChecks();
    g.ConfigFlagsCurrFrame = g.IO.ConfigFlags;

    // Load settings on first frame, save settings when modified (after a delay)
    UpdateSettings();

    g.Time += g.IO.DeltaTime;
    g.WithinFrameScope = true;
    g.FrameCount += 1;
    g.TooltipOverrideCount = 0;
    g.WindowsActiveCount = 0;
    g.MenusIdSubmittedThisFrame.resize(0);

    // Calculate frame-rate for the user, as a purely luxurious feature
    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame))) : FLT_MAX;

    UpdateViewportsNewFrame();

    // Setup current font and draw list shared data
    // FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
    g.IO.Fonts->Locked = true;
    SetCurrentFont(GetDefaultFont());
    IM_ASSERT(g.Font->IsLoaded());
    ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
    for (int n = 0; n < g.Viewports.Size; n++)
        virtual_space.Add(g.Viewports[n]->GetMainRect());
    g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
    g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
    g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
    if (g.Style.AntiAliasedLines)
        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
    if (g.Style.AntiAliasedLinesUseTex && !(g.Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines))
        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
    if (g.Style.AntiAliasedFill)
        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
    if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;

    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        viewport->DrawData = NULL;
        viewport->DrawDataP.Clear();
    }

    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
        KeepAliveID(g.DragDropPayload.SourceId);

    // Update HoveredId data
    if (!g.HoveredIdPreviousFrame)
        g.HoveredIdTimer = 0.0f;
    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
        g.HoveredIdNotActiveTimer = 0.0f;
    if (g.HoveredId)
        g.HoveredIdTimer += g.IO.DeltaTime;
    if (g.HoveredId && g.ActiveId != g.HoveredId)
        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
    g.HoveredIdPreviousFrame = g.HoveredId;
    g.HoveredIdPreviousFrameUsingMouseWheel = g.HoveredIdUsingMouseWheel;
    g.HoveredId = 0;
    g.HoveredIdAllowOverlap = false;
    g.HoveredIdUsingMouseWheel = false;
    g.HoveredIdDisabled = false;

    // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
    if (g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)
        ClearActiveID();
    if (g.ActiveId)
        g.ActiveIdTimer += g.IO.DeltaTime;
    g.LastActiveIdTimer += g.IO.DeltaTime;
    g.ActiveIdPreviousFrame = g.ActiveId;
    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
    g.ActiveIdIsAlive = 0;
    g.ActiveIdHasBeenEditedThisFrame = false;
    g.ActiveIdPreviousFrameIsAlive = false;
    g.ActiveIdIsJustActivated = false;
    if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
        g.TempInputId = 0;
    if (g.ActiveId == 0)
    {
        g.ActiveIdUsingNavDirMask = 0x00;
        g.ActiveIdUsingNavInputMask = 0x00;
        g.ActiveIdUsingKeyInputMask = 0x00;
    }

    // Drag and drop
    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
    g.DragDropAcceptIdCurr = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropWithinSource = false;
    g.DragDropWithinTarget = false;
    g.DragDropHoldJustPressedId = 0;

    // Update keyboard input state
    // Synchronize io.KeyMods with individual modifiers io.KeyXXX bools
    g.IO.KeyMods = GetMergedKeyModFlags();
    memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)
        g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Update gamepad/keyboard navigation
    NavUpdate();

    // Update mouse input state
    UpdateMouseInputs();

    // Undocking
    // (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
    DockContextNewFrameUpdateUndocking(&g);

    // Find hovered window
    // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
    UpdateHoveredWindowAndCaptureFlags();

    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
    UpdateMouseMovingWindowNewFrame();

    // Background darkening/whitening
    if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
    else
        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

    g.MouseCursor = ImGuiMouseCursor_Arrow;
    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
    g.PlatformImePos = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default
    g.PlatformImePosViewport = NULL;

    // Mouse wheel scrolling, scale
    UpdateMouseWheel();

    // Update legacy TAB focus
    UpdateTabFocus();

    // Mark all windows as not visible and compact unused memory.
    IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
    const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        window->WasActive = window->Active;
        window->BeginCount = 0;
        window->Active = false;
        window->WriteAccessed = false;

        // Garbage collect transient buffers of recently unused windows
        if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
            GcCompactTransientWindowBuffers(window);
    }

    // Garbage collect transient buffers of recently unused tables
    for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
        if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
            TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
    if (g.GcCompactAll)
        GcCompactTransientMiscBuffers();
    g.GcCompactAll = false;

    // Closing the focused window restore focus to the first active root window in descending z-order
    if (g.NavWindow && !g.NavWindow->WasActive)
        FocusTopMostWindowUnderOne(NULL, NULL);

    // No window should be open at the beginning of the frame.
    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
    g.CurrentWindowStack.resize(0);
    g.BeginPopupStack.resize(0);
    g.ItemFlagsStack.resize(0);
    g.ItemFlagsStack.push_back(ImGuiItemFlags_None);
    g.GroupStack.resize(0);
    ClosePopupsOverWindow(g.NavWindow, false);

    // Docking
    DockContextNewFrameUpdateDocking(&g);

    // [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
    UpdateDebugToolItemPicker();

    // Create implicit/fallback window - which we will only render it if the user has added something to it.
    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
    // This fallback is particularly important as it avoid ImGui:: calls from crashing.
    g.WithinFrameScopeWithImplicitWindow = true;
    SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
    Begin("Debug##Default");
    IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);

    CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
}

// [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
void ImGui::UpdateDebugToolItemPicker()
{
    ImGuiContext& g = *GImGui;
    g.DebugItemPickerBreakId = 0;
    if (g.DebugItemPickerActive)
    {
        const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
        if (ImGui::IsKeyPressedMap(ImGuiKey_Escape))
            g.DebugItemPickerActive = false;
        if (ImGui::IsMouseClicked(0) && hovered_id)
        {
            g.DebugItemPickerBreakId = hovered_id;
            g.DebugItemPickerActive = false;
        }
        ImGui::SetNextWindowBgAlpha(0.60f);
        ImGui::BeginTooltip();
        ImGui::Text("HoveredId: 0x%08X", hovered_id);
        ImGui::Text("Press ESC to abort picking.");
        ImGui::TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled), "Click to break in debugger!");
        ImGui::EndTooltip();
    }
}

void ImGui::Initialize(ImGuiContext* context)
{
    ImGuiContext& g = *context;
    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);

    // Add .ini handle for ImGuiWindow type
    {
        ImGuiSettingsHandler ini_handler;
        ini_handler.TypeName = "Window";
        ini_handler.TypeHash = ImHashStr("Window");
        ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
        ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
        ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
        ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
        ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
        g.SettingsHandlers.push_back(ini_handler);
    }

#ifdef IMGUI_HAS_TABLE
    // Add .ini handle for ImGuiTable type
    TableSettingsInstallHandler(context);
#endif // #ifdef IMGUI_HAS_TABLE

    // Create default viewport
    ImGuiViewportP* viewport = IM_NEW(ImGuiViewportP)();
    viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;
    viewport->Idx = 0;
    viewport->PlatformWindowCreated = true;
    viewport->Flags = ImGuiViewportFlags_OwnedByApp;
    g.Viewports.push_back(viewport);
    g.PlatformIO.Viewports.push_back(g.Viewports[0]);

#ifdef IMGUI_HAS_DOCK
    // Initialize Docking
    DockContextInitialize(&g);
#endif

    g.Initialized = true;
}

// This function is merely here to free heap allocations.
void ImGui::Shutdown(ImGuiContext* context)
{
    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
    ImGuiContext& g = *context;
    if (g.IO.Fonts && g.FontAtlasOwnedByContext)
    {
        g.IO.Fonts->Locked = false;
        IM_DELETE(g.IO.Fonts);
    }
    g.IO.Fonts = NULL;

    // Cleanup of other data are conditional on actually having initialized Dear ImGui.
    if (!g.Initialized)
        return;

    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
    if (g.SettingsLoaded && g.IO.IniFilename != NULL)
    {
        ImGuiContext* backup_context = GImGui;
        SetCurrentContext(&g);
        SaveIniSettingsToDisk(g.IO.IniFilename);
        SetCurrentContext(backup_context);
    }

    // Destroy platform windows
    ImGuiContext* backup_context = ImGui::GetCurrentContext();
    SetCurrentContext(context);
    DestroyPlatformWindows();
    SetCurrentContext(backup_context);

    // Shutdown extensions
    DockContextShutdown(&g);

    CallContextHooks(&g, ImGuiContextHookType_Shutdown);

    // Clear everything else
    for (int i = 0; i < g.Windows.Size; i++)
        IM_DELETE(g.Windows[i]);
    g.Windows.clear();
    g.WindowsFocusOrder.clear();
    g.WindowsTempSortBuffer.clear();
    g.CurrentWindow = NULL;
    g.CurrentWindowStack.clear();
    g.WindowsById.Clear();
    g.NavWindow = NULL;
    g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
    g.MovingWindow = NULL;
    g.ColorStack.clear();
    g.StyleVarStack.clear();
    g.FontStack.clear();
    g.OpenPopupStack.clear();
    g.BeginPopupStack.clear();

    g.CurrentViewport = g.MouseViewport = g.MouseLastHoveredViewport = NULL;
    for (int i = 0; i < g.Viewports.Size; i++)
        IM_DELETE(g.Viewports[i]);
    g.Viewports.clear();

    g.TabBars.Clear();
    g.CurrentTabBarStack.clear();
    g.ShrinkWidthBuffer.clear();

    g.Tables.Clear();
    g.CurrentTableStack.clear();
    g.DrawChannelsTempMergeBuffer.clear();

    g.ClipboardHandlerData.clear();
    g.MenusIdSubmittedThisFrame.clear();
    g.InputTextState.ClearFreeMemory();

    g.SettingsWindows.clear();
    g.SettingsHandlers.clear();

    if (g.LogFile)
    {
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
        if (g.LogFile != stdout)
#endif
            ImFileClose(g.LogFile);
        g.LogFile = NULL;
    }
    g.LogBuffer.clear();

    g.Initialized = false;
}

// FIXME: Add a more explicit sort order in the window structure.
static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
{
    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;
    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;
    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
        return d;
    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
        return d;
    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
{
    out_sorted_windows->push_back(window);
    if (window->Active)
    {
        int count = window->DC.ChildWindows.Size;
        if (count > 1)
            ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
        for (int i = 0; i < count; i++)
        {
            ImGuiWindow* child = window->DC.ChildWindows[i];
            if (child->Active)
                AddWindowToSortBuffer(out_sorted_windows, child);
        }
    }
}

static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
{
    // Remove trailing command if unused.
    // Technically we could return directly instead of popping, but this make things looks neat in Metrics/Debugger window as well.
    draw_list->_PopUnusedDrawCmd();
    if (draw_list->CmdBuffer.Size == 0)
        return;

    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
    // May trigger for you if you are using PrimXXX functions incorrectly.
    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
    if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
        IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
    // If this assert triggers because you are drawing lots of stuff manually:
    // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
    //   Be mindful that the ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
    // - If you want large meshes with more than 64K vertices, you can either:
    //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
    //       Most example backends already support this from 1.71. Pre-1.71 backends won't.
    //       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
    //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
    //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
    //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
    //       Your own engine or render API may use different parameters or function calls to specify index sizes.
    //       2 and 4 bytes indices are generally supported by most graphics API.
    // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
    //   the 64K limit to split your draw commands in multiple draw lists.
    if (sizeof(ImDrawIdx) == 2)
        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");

    out_list->push_back(draw_list);
}

static void AddWindowToDrawData(ImGuiWindow* window, int layer)
{
    ImGuiContext& g = *GImGui;
    ImGuiViewportP* viewport = window->Viewport;
    g.IO.MetricsRenderWindows++;
    AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[layer], window->DrawList);
    for (int i = 0; i < window->DC.ChildWindows.Size; i++)
    {
        ImGuiWindow* child = window->DC.ChildWindows[i];
        if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active
            AddWindowToDrawData(child, layer);
    }
}

// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
static void AddRootWindowToDrawData(ImGuiWindow* window)
{
    int layer = (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
    AddWindowToDrawData(window, layer);
}

void ImDrawDataBuilder::FlattenIntoSingleLayer()
{
    int n = Layers[0].Size;
    int size = n;
    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)
        size += Layers[i].Size;
    Layers[0].resize(size);
    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)
    {
        ImVector<ImDrawList*>& layer = Layers[layer_n];
        if (layer.empty())
            continue;
        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
        n += layer.Size;
        layer.resize(0);
    }
}

static void SetupViewportDrawData(ImGuiViewportP* viewport, ImVector<ImDrawList*>* draw_lists)
{
    // When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
    // and to allow applications/backends to easily skip rendering.
    // FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
    // This is because the work has been done already, and its wasted! We should fix that and add optimizations for
    // it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
    const bool is_minimized = (viewport->Flags & ImGuiViewportFlags_Minimized) != 0;

    ImGuiIO& io = ImGui::GetIO();
    ImDrawData* draw_data = &viewport->DrawDataP;
    viewport->DrawData = draw_data; // Make publicly accessible
    draw_data->Valid = true;
    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;
    draw_data->CmdListsCount = draw_lists->Size;
    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
    draw_data->DisplayPos = viewport->Pos;
    draw_data->DisplaySize = is_minimized ? ImVec2(0.0f, 0.0f) : viewport->Size;
    draw_data->FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
    draw_data->OwnerViewport = viewport;
    for (int n = 0; n < draw_lists->Size; n++)
    {
        draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;
        draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;
    }
}

// Push a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.
// - When using this function it is sane to ensure that float are perfectly rounded to integer values,
//   so that e.g. (int)(max.x-min.x) in user's render produce correct result.
// - If the code here changes, may need to update code of functions like NextColumn() and PushColumnClipRect():
//   some frequently called functions which to modify both channels and clipping simultaneously tend to use the
//   more specialized SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of underlying ImDrawCmds.
void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void ImGui::PopClipRect()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PopClipRect();
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

static ImGuiWindow* FindFrontMostVisibleChildWindow(ImGuiWindow* window)
{
    for (int n = window->DC.ChildWindows.Size - 1; n >= 0; n--)
        if (IsWindowActiveAndVisible(window->DC.ChildWindows[n]))
            return FindFrontMostVisibleChildWindow(window->DC.ChildWindows[n]);
    return window;
}

static void ImGui::EndFrameDrawDimmedBackgrounds()
{
    ImGuiContext& g = *GImGui;

    // Draw modal whitening background on _other_ viewports than the one the modal is one
    ImGuiWindow* modal_window = GetTopMostPopupModal();
    const bool dim_bg_for_modal = (modal_window != NULL);
    const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL);
    if (dim_bg_for_modal || dim_bg_for_window_list)
        for (int viewport_n = 0; viewport_n < g.Viewports.Size; viewport_n++)
        {
            ImGuiViewportP* viewport = g.Viewports[viewport_n];
            if (modal_window && viewport == modal_window->Viewport)
                continue;
            if (g.NavWindowingListWindow && viewport == g.NavWindowingListWindow->Viewport)
                continue;
            if (g.NavWindowingTargetAnim && viewport == g.NavWindowingTargetAnim->Viewport)
                continue;
            if (viewport->Window && modal_window && IsWindowAbove(viewport->Window, modal_window))
                continue;
            ImDrawList* draw_list = GetForegroundDrawList(viewport);
            const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
            draw_list->AddRectFilled(viewport->Pos, viewport->Pos + viewport->Size, dim_bg_col);
        }

    // Draw modal whitening background between CTRL-TAB list
    if (dim_bg_for_window_list && g.NavWindowingTargetAnim->Active)
    {
        // Choose a draw list that will be front-most across all our children
        // In the unlikely case that the window wasn't made active we can't rely on its drawlist and skip rendering all-together.
        ImGuiWindow* window = g.NavWindowingTargetAnim;
        ImDrawList* draw_list = FindFrontMostVisibleChildWindow(window->RootWindowDockTree)->DrawList;
        draw_list->PushClipRectFullScreen();

        // Docking: draw modal whitening background on other nodes of a same dock tree
        // For CTRL+TAB within a docking node we need to render the dimming background in 8 steps
        // (Because the root node renders the background in one shot, in order to avoid flickering when a child dock node is not submitted)
        if (window->RootWindow->DockIsActive)
            if (window->RootWindowDockTree != window->RootWindow)
                RenderRectFilledWithHole(draw_list, window->RootWindowDockTree->Rect(), window->RootWindow->Rect(), GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio), g.Style.WindowRounding);

        // Draw navigation selection/windowing rectangle border
        float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
        ImRect bb = window->Rect();
        bb.Expand(g.FontSize);
        if (bb.Contains(window->Viewport->GetMainRect())) // If a window fits the entire viewport, adjust its highlight inward
        {
            bb.Expand(-g.FontSize - 1.0f);
            rounding = window->WindowRounding;
        }
        draw_list->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
        draw_list->PopClipRect();
    }
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
void ImGui::EndFrame()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);

    // Don't process EndFrame() multiple times.
    if (g.FrameCountEnded == g.FrameCount)
        return;
    IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?");

    CallContextHooks(&g, ImGuiContextHookType_EndFramePre);

    ErrorCheckEndFrameSanityChecks();

    // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
    if (g.PlatformIO.Platform_SetImeInputPos && (g.PlatformImeLastPos.x == FLT_MAX || ImLengthSqr(g.PlatformImePos - g.PlatformImeLastPos) > 0.0001f))
        if (g.PlatformImePosViewport && g.PlatformImePosViewport->PlatformWindowCreated)
        {
            g.PlatformIO.Platform_SetImeInputPos(g.PlatformImePosViewport, g.PlatformImePos);
            g.PlatformImeLastPos = g.PlatformImePos;
            g.PlatformImePosViewport = NULL;
        }

    // Hide implicit/fallback "Debug" window if it hasn't been used
    g.WithinFrameScopeWithImplicitWindow = false;
    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
        g.CurrentWindow->Active = false;
    End();

    // Draw modal whitening background on _other_ viewports than the one the modal is one
    EndFrameDrawDimmedBackgrounds();

    // Update navigation: CTRL+Tab, wrap-around requests
    NavEndFrame();

    SetCurrentViewport(NULL, NULL);

    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
    if (g.DragDropActive)
    {
        bool is_delivered = g.DragDropPayload.Delivery;
        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
        if (is_delivered || is_elapsed)
            ClearDragDrop();
    }

    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
    {
        g.DragDropWithinSource = true;
        SetTooltip("...");
        g.DragDropWithinSource = false;
    }

    // End frame
    g.WithinFrameScope = false;
    g.FrameCountEnded = g.FrameCount;

    // Initiate moving window + handle left-click and right-click focus
    UpdateMouseMovingWindowEndFrame();

    // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
    UpdateViewportsEndFrame();

    // Sort the window list so that all child windows are after their parent
    // We cannot do that on FocusWindow() because children may not exist yet
    g.WindowsTempSortBuffer.resize(0);
    g.WindowsTempSortBuffer.reserve(g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
            continue;
        AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
    }

    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
    IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
    g.Windows.swap(g.WindowsTempSortBuffer);
    g.IO.MetricsActiveWindows = g.WindowsActiveCount;

    // Unlock font atlas
    g.IO.Fonts->Locked = false;

    // Clear Input data for next frame
    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
    g.IO.InputQueueCharacters.resize(0);
    memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));

    CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
}

void ImGui::Render()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);

    if (g.FrameCountEnded != g.FrameCount)
        EndFrame();
    g.FrameCountRendered = g.FrameCount;
    g.IO.MetricsRenderWindows = 0;

    CallContextHooks(&g, ImGuiContextHookType_RenderPre);

    // Add background ImDrawList (for each active viewport)
    for (int n = 0; n != g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        viewport->DrawDataBuilder.Clear();
        if (viewport->DrawLists[0] != NULL)
            AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
    }

    // Add ImDrawList to render
    ImGuiWindow* windows_to_render_top_most[2];
    windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindowDockTree : NULL;
    windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
    for (int n = 0; n != g.Windows.Size; n++)
    {
        ImGuiWindow* window = g.Windows[n];
        IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
            AddRootWindowToDrawData(window);
    }
    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)
        if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window
            AddRootWindowToDrawData(windows_to_render_top_most[n]);

    ImVec2 mouse_cursor_offset, mouse_cursor_size, mouse_cursor_uv[4];
    if (g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_None)
        g.IO.Fonts->GetMouseCursorTexData(g.MouseCursor, &mouse_cursor_offset, &mouse_cursor_size, &mouse_cursor_uv[0], &mouse_cursor_uv[2]);

    // Setup ImDrawData structures for end-user
    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        viewport->DrawDataBuilder.FlattenIntoSingleLayer();

        // Draw software mouse cursor if requested by io.MouseDrawCursor flag
        // (note we scale cursor by current viewport/monitor, however Windows 10 for its own hardware cursor seems to be using a different scale factor)
        if (mouse_cursor_size.x > 0.0f && mouse_cursor_size.y > 0.0f)
        {
            float scale = g.Style.MouseCursorScale * viewport->DpiScale;
            if (viewport->GetMainRect().Overlaps(ImRect(g.IO.MousePos, g.IO.MousePos + ImVec2(mouse_cursor_size.x + 2, mouse_cursor_size.y + 2) * scale)))
                RenderMouseCursor(GetForegroundDrawList(viewport), g.IO.MousePos, scale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
        }

        // Add foreground ImDrawList (for each active viewport)
        if (viewport->DrawLists[1] != NULL)
            AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));

        SetupViewportDrawData(viewport, &viewport->DrawDataBuilder.Layers[0]);
        ImDrawData* draw_data = viewport->DrawData;
        g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
        g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
    }

    CallContextHooks(&g, ImGuiContextHookType_RenderPost);
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2(0.0f, g.FontSize)
ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
{
    ImGuiContext& g = *GImGui;

    const char* text_display_end;
    if (hide_text_after_double_hash)
        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
    else
        text_display_end = text_end;

    ImFont* font = g.Font;
    const float font_size = g.FontSize;
    if (text == text_display_end)
        return ImVec2(0.0f, font_size);
    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

    // Round
    // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
    // FIXME: Investigate using ceilf or e.g.
    // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
    // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
    text_size.x = IM_FLOOR(text_size.x + 0.99999f);

    return text_size;
}

// Find window given position, search front-to-back
// FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically
// with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
// called, aka before the next Begin(). Moving window isn't affected.
static void FindHoveredWindow()
{
    ImGuiContext& g = *GImGui;

    // Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
    ImGuiViewportP* moving_window_viewport = g.MovingWindow ? g.MovingWindow->Viewport : NULL;
    if (g.MovingWindow)
        g.MovingWindow->Viewport = g.MouseViewport;

    ImGuiWindow* hovered_window = NULL;
    ImGuiWindow* hovered_window_ignoring_moving_window = NULL;
    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
        hovered_window = g.MovingWindow;

    ImVec2 padding_regular = g.Style.TouchExtraPadding;
    ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
    for (int i = g.Windows.Size - 1; i >= 0; i--)
    {
        ImGuiWindow* window = g.Windows[i];
        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
        if (!window->Active || window->Hidden)
            continue;
        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
            continue;
        IM_ASSERT(window->Viewport);
        if (window->Viewport != g.MouseViewport)
            continue;

        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
        ImRect bb(window->OuterRectClipped);
        if (window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize))
            bb.Expand(padding_regular);
        else
            bb.Expand(padding_for_resize);
        if (!bb.Contains(g.IO.MousePos))
            continue;

        // Support for one rectangular hole in any given window
        // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
        if (window->HitTestHoleSize.x != 0)
        {
            ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
            ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
            if (ImRect(hole_pos, hole_pos + hole_size).Contains(g.IO.MousePos))
                continue;
        }

        if (hovered_window == NULL)
            hovered_window = window;
        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
        if (hovered_window_ignoring_moving_window == NULL && (!g.MovingWindow || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree))
            hovered_window_ignoring_moving_window = window;
        if (hovered_window && hovered_window_ignoring_moving_window)
            break;
    }

    g.HoveredWindow = hovered_window;
    g.HoveredWindowUnderMovingWindow = hovered_window_ignoring_moving_window;

    if (g.MovingWindow)
        g.MovingWindow->Viewport = moving_window_viewport;
}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
{
    ImGuiContext& g = *GImGui;

    // Clip
    ImRect rect_clipped(r_min, r_max);
    if (clip)
        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

    // Expand for touch input
    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
    if (!rect_for_touch.Contains(g.IO.MousePos))
        return false;
    if (!g.MouseViewport->GetMainRect().Overlaps(rect_clipped))
        return false;
    return true;
}

int ImGui::GetKeyIndex(ImGuiKey imgui_key)
{
    IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);
    ImGuiContext& g = *GImGui;
    return g.IO.KeyMap[imgui_key];
}

// Note that dear imgui doesn't know the semantic of each entry of io.KeysDown[]!
// Use your own indices/enums according to how your backend/engine stored them into io.KeysDown[]!
bool ImGui::IsKeyDown(int user_key_index)
{
    if (user_key_index < 0)
        return false;
    ImGuiContext& g = *GImGui;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    return g.IO.KeysDown[user_key_index];
}

// t0 = previous time (e.g.: g.Time - g.IO.DeltaTime)
// t1 = current time (e.g.: g.Time)
// An event is triggered at:
//  t = 0.0f     t = repeat_delay,    t = repeat_delay + repeat_rate*N
int ImGui::CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate)
{
    if (t1 == 0.0f)
        return 1;
    if (t0 >= t1)
        return 0;
    if (repeat_rate <= 0.0f)
        return (t0 < repeat_delay) && (t1 >= repeat_delay);
    const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);
    const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);
    const int count = count_t1 - count_t0;
    return count;
}

int ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)
{
    ImGuiContext& g = *GImGui;
    if (key_index < 0)
        return 0;
    IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[key_index];
    return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);
}

bool ImGui::IsKeyPressed(int user_key_index, bool repeat)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0)
        return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[user_key_index];
    if (t == 0.0f)
        return true;
    if (repeat && t > g.IO.KeyRepeatDelay)
        return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
    return false;
}

bool ImGui::IsKeyReleased(int user_key_index)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];
}

bool ImGui::IsMouseDown(ImGuiMouseButton button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDown[button];
}

bool ImGui::IsMouseClicked(ImGuiMouseButton button, bool repeat)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    const float t = g.IO.MouseDownDuration[button];
    if (t == 0.0f)
        return true;

    if (repeat && t > g.IO.KeyRepeatDelay)
    {
        // FIXME: 2019/05/03: Our old repeat code was wrong here and led to doubling the repeat rate, which made it an ok rate for repeat on mouse hold.
        int amount = CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate * 0.50f);
        if (amount > 0)
            return true;
    }
    return false;
}

bool ImGui::IsMouseReleased(ImGuiMouseButton button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseReleased[button];
}

bool ImGui::IsMouseDoubleClicked(ImGuiMouseButton button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDoubleClicked[button];
}

// Return if a mouse click/drag went past the given threshold. Valid to call during the MouseReleased frame.
// [Internal] This doesn't test if the button is pressed
bool ImGui::IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

bool ImGui::IsMouseDragging(ImGuiMouseButton button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (!g.IO.MouseDown[button])
        return false;
    return IsMouseDragPastThreshold(button, lock_threshold);
}

ImVec2 ImGui::GetMousePos()
{
    ImGuiContext& g = *GImGui;
    return g.IO.MousePos;
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    if (g.BeginPopupStack.Size > 0)
        return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos;
    return g.IO.MousePos;
}

// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
{
    // The assert is only to silence a false-positive in XCode Static Analysis.
    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
    IM_ASSERT(GImGui != NULL);
    const float MOUSE_INVALID = -256000.0f;
    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
}

bool ImGui::IsAnyMouseDown()
{
    ImGuiContext& g = *GImGui;
    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
        if (g.IO.MouseDown[n])
            return true;
    return false;
}

// Return the delta from the initial clicking position while the mouse button is clicked or was just released.
// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
// NB: This is only valid if IsMousePosValid(). backends in theory should always keep mouse position valid when dragging even outside the client window.
ImVec2 ImGui::GetMouseDragDelta(ImGuiMouseButton button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])
        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
            if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]))
                return g.IO.MousePos - g.IO.MouseClickedPos[button];
    return ImVec2(0.0f, 0.0f);
}

void ImGui::ResetMouseDragDelta(ImGuiMouseButton button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
    g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

ImGuiMouseCursor ImGui::GetMouseCursor()
{
    return GImGui->MouseCursor;
}

void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
{
    GImGui->MouseCursor = cursor_type;
}

void ImGui::CaptureKeyboardFromApp(bool capture)
{
    GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;
}

void ImGui::CaptureMouseFromApp(bool capture)
{
    GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;
}

bool ImGui::IsItemActive()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
    {
        ImGuiWindow* window = g.CurrentWindow;
        return g.ActiveId == window->DC.LastItemId;
    }
    return false;
}

bool ImGui::IsItemActivated()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
    {
        ImGuiWindow* window = g.CurrentWindow;
        if (g.ActiveId == window->DC.LastItemId && g.ActiveIdPreviousFrame != window->DC.LastItemId)
            return true;
    }
    return false;
}

bool ImGui::IsItemDeactivated()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDeactivated)
        return (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Deactivated) != 0;
    return (g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId);
}

bool ImGui::IsItemDeactivatedAfterEdit()
{
    ImGuiContext& g = *GImGui;
    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEditedBefore || (g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore));
}

// == GetItemID() == GetFocusID()
bool ImGui::IsItemFocused()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (g.NavId != window->DC.LastItemId || g.NavId == 0)
        return false;

    // Special handling for the dummy item after Begin() which represent the title bar or tab.
    // When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
    if (window->DC.LastItemId == window->ID && window->WriteAccessed)
        return false;

    return true;
}

// Important: this can be useful but it is NOT equivalent to the behavior of e.g.Button()!
// Most widgets have specific reactions based on mouse-up/down state, mouse position etc.
bool ImGui::IsItemClicked(ImGuiMouseButton mouse_button)
{
    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);
}

bool ImGui::IsItemToggledOpen()
{
    ImGuiContext& g = *GImGui;
    return (g.CurrentWindow->DC.LastItemStatusFlags & ImGuiItemStatusFlags_ToggledOpen) ? true : false;
}

bool ImGui::IsItemToggledSelection()
{
    ImGuiContext& g = *GImGui;
    return (g.CurrentWindow->DC.LastItemStatusFlags & ImGuiItemStatusFlags_ToggledSelection) ? true : false;
}

bool ImGui::IsAnyItemHovered()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool ImGui::IsAnyItemActive()
{
    ImGuiContext& g = *GImGui;
    return g.ActiveId != 0;
}

bool ImGui::IsAnyItemFocused()
{
    ImGuiContext& g = *GImGui;
    return g.NavId != 0 && !g.NavDisableHighlight;
}

bool ImGui::IsItemVisible()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(window->DC.LastItemRect);
}

bool ImGui::IsItemEdited()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Edited) != 0;
}

// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
// FIXME: Although this is exposed, its interaction and ideal idiom with using ImGuiButtonFlags_AllowItemOverlap flag are extremely confusing, need rework.
void ImGui::SetItemAllowOverlap()
{
    ImGuiContext& g = *GImGui;
    ImGuiID id = g.CurrentWindow->DC.LastItemId;
    if (g.HoveredId == id)
        g.HoveredIdAllowOverlap = true;
    if (g.ActiveId == id)
        g.ActiveIdAllowOverlap = true;
}

void ImGui::SetItemUsingMouseWheel()
{
    ImGuiContext& g = *GImGui;
    ImGuiID id = g.CurrentWindow->DC.LastItemId;
    if (g.HoveredId == id)
        g.HoveredIdUsingMouseWheel = true;
    if (g.ActiveId == id)
        g.ActiveIdUsingMouseWheel = true;
}

ImVec2 ImGui::GetItemRectMin()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Min;
}

ImVec2 ImGui::GetItemRectMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Max;
}

ImVec2 ImGui::GetItemRectSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.GetSize();
}

bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;

    flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoDocking;
    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag

    // Size
    const ImVec2 content_avail = GetContentRegionAvail();
    ImVec2 size = ImFloor(size_arg);
    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
    if (size.x <= 0.0f)
        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
    if (size.y <= 0.0f)
        size.y = ImMax(content_avail.y + size.y, 4.0f);
    SetNextWindowSize(size);

    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
    if (name)
        ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), "%s/%s_%08X", parent_window->Name, name, id);
    else
        ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), "%s/%08X", parent_window->Name, id);

    const float backup_border_size = g.Style.ChildBorderSize;
    if (!border)
        g.Style.ChildBorderSize = 0.0f;
    bool ret = Begin(g.TempBuffer, NULL, flags);
    g.Style.ChildBorderSize = backup_border_size;

    ImGuiWindow* child_window = g.CurrentWindow;
    child_window->ChildId = id;
    child_window->AutoFitChildAxises = (ImS8)auto_fit_axises;

    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
    // While this is not really documented/defined, it seems that the expected thing to do.
    if (child_window->BeginCount == 1)
        parent_window->DC.CursorPos = child_window->Pos;

    // Process navigation-in immediately so NavInit can run on first frame
    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavHasScroll))
    {
        FocusWindow(child_window);
        NavInitWindow(child_window, false);
        SetActiveID(id + 1, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
        g.ActiveIdSource = ImGuiInputSource_Nav;
    }
    return ret;
}

bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    IM_ASSERT(id != 0);
    return BeginChildEx(NULL, id, size_arg, border, extra_flags);
}

void ImGui::EndChild()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(g.WithinEndChild == false);
    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() calls

    g.WithinEndChild = true;
    if (window->BeginCount > 1)
    {
        End();
    }
    else
    {
        ImVec2 sz = window->Size;
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
            sz.x = ImMax(4.0f, sz.x);
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
            sz.y = ImMax(4.0f, sz.y);
        End();

        ImGuiWindow* parent_window = g.CurrentWindow;
        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
        ItemSize(sz);
        if ((window->DC.NavLayersActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
        {
            ItemAdd(bb, window->ChildId);
            RenderNavHighlight(bb, window->ChildId);

            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child
            if (window->DC.NavLayersActiveMask == 0 && window == g.NavWindow)
                RenderNavHighlight(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
        }
        else
        {
            // Not navigable into
            ItemAdd(bb, 0);
        }
        if (g.HoveredWindow == window)
            parent_window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
    }
    g.WithinEndChild = false;
    g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
}

// Helper to create a child window / scrolling region that looks like a normal widget frame.
bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
    PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
    PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
    PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);
    bool ret = BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);
    PopStyleVar(3);
    PopStyleColor();
    return ret;
}

void ImGui::EndChildFrame()
{
    EndChild();
}

static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
{
    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
    window->SetWindowDockAllowFlags      = enabled ? (window->SetWindowDockAllowFlags      | flags) : (window->SetWindowDockAllowFlags      & ~flags);
}

ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
}

ImGuiWindow* ImGui::FindWindowByName(const char* name)
{
    ImGuiID id = ImHashStr(name);
    return FindWindowByID(id);
}

static void ApplyWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)
{
    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
    window->ViewportPos = main_viewport->Pos;
    if (settings->ViewportId)
    {
        window->ViewportId = settings->ViewportId;
        window->ViewportPos = ImVec2(settings->ViewportPos.x, settings->ViewportPos.y);
    }
    window->Pos = ImFloor(ImVec2(settings->Pos.x + window->ViewportPos.x, settings->Pos.y + window->ViewportPos.y));
    if (settings->Size.x > 0 && settings->Size.y > 0)
        window->Size = window->SizeFull = ImFloor(ImVec2(settings->Size.x, settings->Size.y));
    window->Collapsed = settings->Collapsed;
    window->DockId = settings->DockId;
    window->DockOrder = settings->DockOrder;
}

static ImGuiWindow* CreateNewWindow(const char* name, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);

    // Create window the first time
    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
    window->Flags = flags;
    g.WindowsById.SetVoidPtr(window->ID, window);

    // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
    window->Pos = main_viewport->Pos + ImVec2(60, 60);
    window->ViewportPos = main_viewport->Pos;

    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))
        {
            // Retrieve settings from .ini file
            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
            ApplyWindowSettings(window, settings);
        }
    window->DC.CursorStartPos = window->DC.CursorMaxPos = window->Pos; // So first call to CalcContentSize() doesn't return crazy values

    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
    {
        window->AutoFitFramesX = window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
    else
    {
        if (window->Size.x <= 0.0f)
            window->AutoFitFramesX = 2;
        if (window->Size.y <= 0.0f)
            window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
    }

    if (!(flags & ImGuiWindowFlags_ChildWindow))
    {
        g.WindowsFocusOrder.push_back(window);
        window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
    }

    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
        g.Windows.push_front(window); // Quite slow but rare and only once
    else
        g.Windows.push_back(window);
    return window;
}

static ImGuiWindow* GetWindowForTitleDisplay(ImGuiWindow* window)
{
    return window->DockNodeAsHost ? window->DockNodeAsHost->VisibleWindow : window;
}

static ImGuiWindow* GetWindowForTitleAndMenuHeight(ImGuiWindow* window)
{
    return (window->DockNodeAsHost && window->DockNodeAsHost->VisibleWindow) ? window->DockNodeAsHost->VisibleWindow : window;
}

static ImVec2 CalcWindowSizeAfterConstraint(ImGuiWindow* window, const ImVec2& size_desired)
{
    ImGuiContext& g = *GImGui;
    ImVec2 new_size = size_desired;
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
    {
        // Using -1,-1 on either X/Y axis to preserve the current size.
        ImRect cr = g.NextWindowData.SizeConstraintRect;
        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
        if (g.NextWindowData.SizeCallback)
        {
            ImGuiSizeCallbackData data;
            data.UserData = g.NextWindowData.SizeCallbackUserData;
            data.Pos = window->Pos;
            data.CurrentSize = window->SizeFull;
            data.DesiredSize = new_size;
            g.NextWindowData.SizeCallback(&data);
            new_size = data.DesiredSize;
        }
        new_size.x = IM_FLOOR(new_size.x);
        new_size.y = IM_FLOOR(new_size.y);
    }

    // Minimum size
    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
    {
        ImGuiWindow* window_for_height = GetWindowForTitleAndMenuHeight(window);
        const float decoration_up_height = window_for_height->TitleBarHeight() + window_for_height->MenuBarHeight();
        new_size = ImMax(new_size, g.Style.WindowMinSize);
        new_size.y = ImMax(new_size.y, decoration_up_height + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows
    }
    return new_size;
}

static void CalcWindowContentSizes(ImGuiWindow* window, ImVec2* content_size_current, ImVec2* content_size_ideal)
{
    bool preserve_old_content_sizes = false;
    if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
        preserve_old_content_sizes = true;
    else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
        preserve_old_content_sizes = true;
    if (preserve_old_content_sizes)
    {
        *content_size_current = window->ContentSize;
        *content_size_ideal = window->ContentSizeIdeal;
        return;
    }

    content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_FLOOR(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
    content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_FLOOR(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
    content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_FLOOR(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);
    content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_FLOOR(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);
}

static ImVec2 CalcWindowAutoFitSize(ImGuiWindow* window, const ImVec2& size_contents)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    const float decoration_up_height = window->TitleBarHeight() + window->MenuBarHeight();
    ImVec2 size_pad = window->WindowPadding * 2.0f;
    ImVec2 size_desired = size_contents + size_pad + ImVec2(0.0f, decoration_up_height);
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Tooltip always resize
        return size_desired;
    }
    else
    {
        // Maximum window size is determined by the viewport size or monitor size
        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;
        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;
        ImVec2 size_min = style.WindowMinSize;
        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));

        // FIXME-VIEWPORT-WORKAREA: May want to use GetWorkSize() instead of Size depending on the type of windows?
        ImVec2 avail_size = window->Viewport->Size;
        if (window->ViewportOwned)
            avail_size = ImVec2(FLT_MAX, FLT_MAX);
        const int monitor_idx = window->ViewportAllowPlatformMonitorExtend;
        if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
            avail_size = g.PlatformIO.Monitors[monitor_idx].WorkSize;
        ImVec2 size_auto_fit = ImClamp(size_desired, size_min, ImMax(size_min, avail_size - style.DisplaySafeAreaPadding * 2.0f));

        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
        ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
        bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - 0.0f                 < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
        bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_up_height < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
        if (will_have_scrollbar_x)
            size_auto_fit.y += style.ScrollbarSize;
        if (will_have_scrollbar_y)
            size_auto_fit.x += style.ScrollbarSize;
        return size_auto_fit;
    }
}

ImVec2 ImGui::CalcWindowNextAutoFitSize(ImGuiWindow* window)
{
    ImVec2 size_contents_current;
    ImVec2 size_contents_ideal;
    CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);
    ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, size_contents_ideal);
    ImVec2 size_final = CalcWindowSizeAfterConstraint(window, size_auto_fit);
    return size_final;
}

static ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)
{
    if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        return ImGuiCol_PopupBg;
    if (flags & ImGuiWindowFlags_ChildWindow)
        return ImGuiCol_ChildBg;
    return ImGuiCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
{
    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
    ImVec2 size_expected = pos_max - pos_min;
    ImVec2 size_constrained = CalcWindowSizeAfterConstraint(window, size_expected);
    *out_pos = pos_min;
    if (corner_norm.x == 0.0f)
        out_pos->x -= (size_constrained.x - size_expected.x);
    if (corner_norm.y == 0.0f)
        out_pos->y -= (size_constrained.y - size_expected.y);
    *out_size = size_constrained;
}

// Data for resizing from corner
struct ImGuiResizeGripDef
{
    ImVec2  CornerPosN;
    ImVec2  InnerDir;
    int     AngleMin12, AngleMax12;
};
static const ImGuiResizeGripDef resize_grip_def[4] =
{
    { ImVec2(1, 1), ImVec2(-1, -1), 0, 3 },  // Lower-right
    { ImVec2(0, 1), ImVec2(+1, -1), 3, 6 },  // Lower-left
    { ImVec2(0, 0), ImVec2(+1, +1), 6, 9 },  // Upper-left (Unused)
    { ImVec2(1, 0), ImVec2(-1, +1), 9, 12 }  // Upper-right (Unused)
};

// Data for resizing from borders
struct ImGuiResizeBorderDef
{
    ImVec2 InnerDir;
    ImVec2 SegmentN1, SegmentN2;
    float  OuterAngle;
};
static const ImGuiResizeBorderDef resize_border_def[4] =
{
    { ImVec2(+1, 0), ImVec2(0, 1), ImVec2(0, 0), IM_PI * 1.00f }, // Left
    { ImVec2(-1, 0), ImVec2(1, 0), ImVec2(1, 1), IM_PI * 0.00f }, // Right
    { ImVec2(0, +1), ImVec2(0, 0), ImVec2(1, 0), IM_PI * 1.50f }, // Up
    { ImVec2(0, -1), ImVec2(1, 1), ImVec2(0, 1), IM_PI * 0.50f }  // Down
};

static ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)
{
    ImRect rect = window->Rect();
    if (thickness == 0.0f)
        rect.Max -= ImVec2(1, 1);
    if (border_n == ImGuiDir_Left)  { return ImRect(rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding); }
    if (border_n == ImGuiDir_Right) { return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding); }
    if (border_n == ImGuiDir_Up)    { return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness);    }
    if (border_n == ImGuiDir_Down)  { return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness);    }
    IM_ASSERT(0);
    return ImRect();
}

// 0..3: corners (Lower-right, Lower-left, Unused, Unused)
ImGuiID ImGui::GetWindowResizeCornerID(ImGuiWindow* window, int n)
{
    IM_ASSERT(n >= 0 && n < 4);
    ImGuiID id = window->DockIsActive ? window->DockNode->HostWindow->ID : window->ID;
    id = ImHashStr("#RESIZE", 0, id);
    id = ImHashData(&n, sizeof(int), id);
    return id;
}

// Borders (Left, Right, Up, Down)
ImGuiID ImGui::GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir)
{
    IM_ASSERT(dir >= 0 && dir < 4);
    int n = (int)dir + 4;
    ImGuiID id = window->DockIsActive ? window->DockNode->HostWindow->ID : window->ID;
    id = ImHashStr("#RESIZE", 0, id);
    id = ImHashData(&n, sizeof(int), id);
    return id;
}

// Handle resize for: Resize Grips, Borders, Gamepad
// Return true when using auto-fit (double click on resize grip)
static bool ImGui::UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindowFlags flags = window->Flags;

    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        return false;
    if (window->WasActive == false) // Early out to avoid running this code for e.g. an hidden implicit/fallback Debug window.
        return false;

    bool ret_auto_fit = false;
    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
    const float grip_draw_size = IM_FLOOR(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
    const float grip_hover_inner_size = IM_FLOOR(grip_draw_size * 0.75f);
    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;

    ImVec2 pos_target(FLT_MAX, FLT_MAX);
    ImVec2 size_target(FLT_MAX, FLT_MAX);

    // Clip mouse interaction rectangles within the viewport rectangle (in practice the narrowing is going to happen most of the time).
    // - Not narrowing would mostly benefit the situation where OS windows _without_ decoration have a threshold for hovering when outside their limits.
    //   This is however not the case with current backends under Win32, but a custom borderless window implementation would benefit from it.
    // - When decoration are enabled we typically benefit from that distance, but then our resize elements would be conflicting with OS resize elements, so we also narrow.
    // - Note that we are unable to tell if the platform setup allows hovering with a distance threshold (on Win32, decorated window have such threshold).
    // We only clip interaction so we overwrite window->ClipRect, cannot call PushClipRect() yet as DrawList is not yet setup.
    const bool clip_with_viewport_rect = !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport) || (g.IO.MouseHoveredViewport != window->ViewportId) || !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration);
    if (clip_with_viewport_rect)
        window->ClipRect = window->Viewport->GetMainRect();

    // Resize grips and borders are on layer 1
    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;

    // Manual resize grips
    PushID("#RESIZE");
    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
    {
        const ImGuiResizeGripDef& def = resize_grip_def[resize_grip_n];
        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, def.CornerPosN);

        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
        bool hovered, held;
        ImRect resize_rect(corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size);
        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
        ImGuiID resize_grip_id = window->GetID(resize_grip_n); // == GetWindowResizeCornerID()
        ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
        if (hovered || held)
            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

        if (held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)
        {
            // Manual auto-fit when double-clicking
            size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
            ret_auto_fit = true;
            ClearActiveID();
        }
        else if (held)
        {
            // Resize from any of the four corners
            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
            ImVec2 clamp_min = ImVec2(def.CornerPosN.x == 1.0f ? visibility_rect.Min.x : -FLT_MAX, def.CornerPosN.y == 1.0f ? visibility_rect.Min.y : -FLT_MAX);
            ImVec2 clamp_max = ImVec2(def.CornerPosN.x == 0.0f ? visibility_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0f ? visibility_rect.Max.y : +FLT_MAX);
            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
            corner_target = ImClamp(corner_target, clamp_min, clamp_max);
            CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);
        }

        // Only lower-left grip is visible before hovering/activating
        if (resize_grip_n == 0 || held || hovered)
            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
    }
    for (int border_n = 0; border_n < resize_border_count; border_n++)
    {
        const ImGuiResizeBorderDef& def = resize_border_def[border_n];
        const ImGuiAxis axis = (border_n == ImGuiDir_Left || border_n == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;

        bool hovered, held;
        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
        ImGuiID border_id = window->GetID(border_n + 4); // == GetWindowResizeBorderID()
        ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren);
        //GetForegroundDrawLists(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)
        {
            g.MouseCursor = (axis == ImGuiAxis_X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
            if (held)
                *border_held = border_n;
        }
        if (held)
        {
            ImVec2 clamp_min(border_n == ImGuiDir_Right ? visibility_rect.Min.x : -FLT_MAX, border_n == ImGuiDir_Down ? visibility_rect.Min.y : -FLT_MAX);
            ImVec2 clamp_max(border_n == ImGuiDir_Left  ? visibility_rect.Max.x : +FLT_MAX, border_n == ImGuiDir_Up   ? visibility_rect.Max.y : +FLT_MAX);
            ImVec2 border_target = window->Pos;
            border_target[axis] = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING;
            border_target = ImClamp(border_target, clamp_min, clamp_max);
            CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);
        }
    }
    PopID();

    // Restore nav layer
    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;

    // Navigation resize (keyboard/gamepad)
    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindowDockTree == window)
    {
        ImVec2 nav_resize_delta;
        if (g.NavInputSource == ImGuiInputSource_Keyboard && g.IO.KeyShift)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_Gamepad)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down);
        if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)
        {
            const float NAV_RESIZE_SPEED = 600.0f;
            nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));
            nav_resize_delta = ImMax(nav_resize_delta, visibility_rect.Min - window->Pos - window->Size);
            g.NavWindowingToggleLayer = false;
            g.NavDisableMouseHover = true;
            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
            // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
            size_target = CalcWindowSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);
        }
    }

    // Apply back modified position/size to window
    if (size_target.x != FLT_MAX)
    {
        window->SizeFull = size_target;
        MarkIniSettingsDirty(window);
    }
    if (pos_target.x != FLT_MAX)
    {
        window->Pos = ImFloor(pos_target);
        MarkIniSettingsDirty(window);
    }

    window->Size = window->SizeFull;
    return ret_auto_fit;
}

static inline void ClampWindowRect(ImGuiWindow* window, const ImRect& visibility_rect)
{
    ImGuiContext& g = *GImGui;
    ImVec2 size_for_clamping = window->Size;
    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar))
        size_for_clamping.y = window->TitleBarHeight();
    window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
}

static void ImGui::RenderWindowOuterBorders(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    float rounding = window->WindowRounding;
    float border_size = window->WindowBorderSize;
    if (border_size > 0.0f && !(window->Flags & ImGuiWindowFlags_NoBackground))
        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);

    int border_held = window->ResizeBorderHeld;
    if (border_held != -1)
    {
        const ImGuiResizeBorderDef& def = resize_border_def[border_held];
        ImRect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
        window->DrawList->PathStroke(GetColorU32(ImGuiCol_SeparatorActive), 0, ImMax(2.0f, border_size)); // Thicker than usual
    }
    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
    {
        float y = window->Pos.y + window->TitleBarHeight() - 1;
        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), GetColorU32(ImGuiCol_Border), g.Style.FrameBorderSize);
    }
}

// Draw background and borders
// Draw and handle scrollbars
void ImGui::RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    ImGuiWindowFlags flags = window->Flags;

    // Ensure that ScrollBar doesn't read last frame's SkipItems
    IM_ASSERT(window->BeginCount == 0);
    window->SkipItems = false;

    // Draw window + handle manual resize
    // As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
    const float window_rounding = window->WindowRounding;
    const float window_border_size = window->WindowBorderSize;
    if (window->Collapsed)
    {
        // Title bar only
        float backup_border_size = style.FrameBorderSize;
        g.Style.FrameBorderSize = window->WindowBorderSize;
        ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
        RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
        g.Style.FrameBorderSize = backup_border_size;
    }
    else
    {
        // Window background
        if (!(flags & ImGuiWindowFlags_NoBackground))
        {
            bool is_docking_transparent_payload = false;
            if (g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload)
                if (g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && *(ImGuiWindow**)g.DragDropPayload.Data == window)
                    is_docking_transparent_payload = true;

            ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));
            if (window->ViewportOwned)
            {
                // No alpha
                bg_col = (bg_col | IM_COL32_A_MASK);
                if (is_docking_transparent_payload)
                    window->Viewport->Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA;
            }
            else
            {
                // Adjust alpha. For docking
                bool override_alpha = false;
                float alpha = 1.0f;
                if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)
                {
                    alpha = g.NextWindowData.BgAlphaVal;
                    override_alpha = true;
                }
                if (is_docking_transparent_payload)
                {
                    alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
                    override_alpha = true;
                }
                if (override_alpha)
                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
            }
            window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
        }

        // Title bar
        // (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
        // in order for their pos/size to be matching their undocking state.)
        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
        {
            ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
            window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
        }

        // Menu bar
        if (flags & ImGuiWindowFlags_MenuBar)
        {
            ImRect menu_bar_rect = window->MenuBarRect();
            menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
            window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
            if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
                window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
        }

        // Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
        ImGuiDockNode* node = window->DockNode;
        if (window->DockIsActive && node->IsHiddenTabBar() && !node->IsNoTabBar())
        {
            float unhide_sz_draw = ImFloor(g.FontSize * 0.70f);
            float unhide_sz_hit = ImFloor(g.FontSize * 0.55f);
            ImVec2 p = node->Pos;
            ImRect r(p, p + ImVec2(unhide_sz_hit, unhide_sz_hit));
            bool hovered, held;
            if (ButtonBehavior(r, window->GetID("#UNHIDE"), &hovered, &held, ImGuiButtonFlags_FlattenChildren))
                node->WantHiddenTabBarToggle = true;
            else if (held && IsMouseDragging(0))
                StartMouseMovingWindowOrNode(window, node, true);

            // FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
            ImU32 col = GetColorU32(((held && hovered) || (node->IsFocused && !hovered)) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
            window->DrawList->AddTriangleFilled(p, p + ImVec2(unhide_sz_draw, 0.0f), p + ImVec2(0.0f, unhide_sz_draw), col);
        }

        // Scrollbars
        if (window->ScrollbarX)
            Scrollbar(ImGuiAxis_X);
        if (window->ScrollbarY)
            Scrollbar(ImGuiAxis_Y);

        // Render resize grips (after their input handling so we don't have a frame of latency)
        if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize))
        {
            for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
            {
                const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
                const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
                window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
                window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
            }
        }

        // Borders (for dock node host they will be rendered over after the tab bar)
        if (handle_borders_and_resize_grips && !window->DockNodeAsHost)
            RenderWindowOuterBorders(window);
    }
}

// Render title text, collapse button, close button
// When inside a dock node, this is handled in DockNodeUpdateTabBar() instead.
void ImGui::RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    ImGuiWindowFlags flags = window->Flags;

    const bool has_close_button = (p_open != NULL);
    const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);

    // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
    const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
    g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;

    // Layout buttons
    // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
    float pad_l = style.FramePadding.x;
    float pad_r = style.FramePadding.x;
    float button_sz = g.FontSize;
    ImVec2 close_button_pos;
    ImVec2 collapse_button_pos;
    if (has_close_button)
    {
        pad_r += button_sz;
        close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y);
    }
    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)
    {
        pad_r += button_sz;
        collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y);
    }
    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)
    {
        collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l - style.FramePadding.x, title_bar_rect.Min.y);
        pad_l += button_sz;
    }

    // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
    if (has_collapse_button)
        if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos, NULL))
            window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function

    // Close button
    if (has_close_button)
        if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
            *p_open = false;

    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    g.CurrentItemFlags = item_flags_backup;

    // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
    // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
    const char* UNSAVED_DOCUMENT_MARKER = "*";
    const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
    const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);

    // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
    // while uncentered title text will still reach edges correctly.
    if (pad_l > style.FramePadding.x)
        pad_l += g.Style.ItemInnerSpacing.x;
    if (pad_r > style.FramePadding.x)
        pad_r += g.Style.ItemInnerSpacing.x;
    if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)
    {
        float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center
        float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
        pad_l = ImMax(pad_l, pad_extend * centerness);
        pad_r = ImMax(pad_r, pad_extend * centerness);
    }

    ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
    ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
    //if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
    //if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
    RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);
    if (flags & ImGuiWindowFlags_UnsavedDocument)
    {
        ImVec2 marker_pos = ImVec2(ImMax(layout_r.Min.x, layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, layout_r.Min.y) + ImVec2(2 - marker_size_x, 0.0f);
        ImVec2 off = ImVec2(0.0f, IM_FLOOR(-g.FontSize * 0.25f));
        RenderTextClipped(marker_pos + off, layout_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, ImVec2(0, style.WindowTitleAlign.y), &clip_r);
    }
}

void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)
{
    window->ParentWindow = parent_window;
    window->RootWindow = window->RootWindowDockTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
    {
        window->RootWindowDockTree = parent_window->RootWindowDockTree;
        if (!window->DockIsActive && !(parent_window->Flags & ImGuiWindowFlags_DockNodeHost))
            window->RootWindow = parent_window->RootWindow;
    }
    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))
        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
    {
        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
    }
}

// Push a new Dear ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
    IM_ASSERT(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()
    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

    // Find or create
    ImGuiWindow* window = FindWindowByName(name);
    const bool window_just_created = (window == NULL);
    if (window_just_created)
        window = CreateNewWindow(name, flags);

    // Automatically disable manual moving/resizing when NoInputs is set
    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

    if (flags & ImGuiWindowFlags_NavFlattened)
        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);

    const int current_frame = g.FrameCount;
    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
    window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);

    // Update the Appearing flag
    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
        window_just_activated_by_user |= (window != popup_ref.Window);
    }
    window->Appearing = window_just_activated_by_user;
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);

    // Update Flags, LastFrameActive, BeginOrderXXX fields
    if (first_begin_of_the_frame)
    {
        window->FlagsPreviousFrame = window->Flags;
        window->Flags = (ImGuiWindowFlags)flags;
        window->LastFrameActive = current_frame;
        window->LastTimeActive = (float)g.Time;
        window->BeginOrderWithinParent = 0;
        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
    }
    else
    {
        flags = window->Flags;
    }

    // Docking
    // (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
    IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL); // Cannot be both
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasDock)
        SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond);
    if (first_begin_of_the_frame)
    {
        bool has_dock_node = (window->DockId != 0 || window->DockNode != NULL);
        bool new_auto_dock_node = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window);
        if (has_dock_node || new_auto_dock_node)
        {
            BeginDocked(window, p_open);
            flags = window->Flags;
            if (window->DockIsActive)
                IM_ASSERT(window->DockNode != NULL);

            // Docking currently override constraints
            g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint;
        }
    }

    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
    ImGuiWindow* parent_window_in_stack = window->DockIsActive ? window->DockNode->HostWindow : g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));

    // We allow window memory to be compacted so recreate the base stack when needed.
    if (window->IDStack.Size == 0)
        window->IDStack.push_back(window->ID);

    // Add to stack
    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
    g.CurrentWindowStack.push_back(window);
    g.CurrentWindow = window;
    window->DC.StackSizesOnBegin.SetToCurrentState();
    g.CurrentWindow = NULL;

    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        popup_ref.Window = window;
        g.BeginPopupStack.push_back(popup_ref);
        window->PopupId = popup_ref.PopupId;
    }

    // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
    if (first_begin_of_the_frame)
        UpdateWindowParentAndRootLinks(window, flags, parent_window);

    // Process SetNextWindow***() calls
    // (FIXME: Consider splitting the HasXXX flags into X/Y components
    bool window_pos_set_by_api = false;
    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)
    {
        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
        {
            // May be processed on the next frame if this is our first frame and we are measuring size
            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
            window->SetWindowPosVal = g.NextWindowData.PosVal;
            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        }
        else
        {
            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
        }
    }
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)
    {
        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
    }
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)
    {
        if (g.NextWindowData.ScrollVal.x >= 0.0f)
        {
            window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
            window->ScrollTargetCenterRatio.x = 0.0f;
        }
        if (g.NextWindowData.ScrollVal.y >= 0.0f)
        {
            window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
            window->ScrollTargetCenterRatio.y = 0.0f;
        }
    }
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
        window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
    else if (first_begin_of_the_frame)
        window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasWindowClass)
        window->WindowClass = g.NextWindowData.WindowClass;
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
        FocusWindow(window);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);

    // When reusing window again multiple times a frame, just append content (don't need to setup again)
    if (first_begin_of_the_frame)
    {
        // Initialize
        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
        window->Active = true;
        window->HasCloseButton = (p_open != NULL);
        window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
        window->IDStack.resize(1);
        window->DrawList->_ResetForNewFrame();
        window->DC.CurrentTableIdx = -1;

        // Restore buffer capacity when woken from a compacted state, to avoid
        if (window->MemoryCompacted)
            GcAwakeTransientWindowBuffers(window);

        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
        bool window_title_visible_elsewhere = false;
        if ((window->Viewport && window->Viewport->Window == window) || (window->DockIsActive))
            window_title_visible_elsewhere = true;
        else if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
            window_title_visible_elsewhere = true;
        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
        {
            size_t buf_len = (size_t)window->NameBufLen;
            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
            window->NameBufLen = (int)buf_len;
        }

        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

        // Update contents size from last frame for auto-fitting (or use explicit size)
        const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
        CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);

        // FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
        // for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
        // it has a single usage before this code block and may be set below before it is finally checked.
        if (window->HiddenFramesCanSkipItems > 0)
            window->HiddenFramesCanSkipItems--;
        if (window->HiddenFramesCannotSkipItems > 0)
            window->HiddenFramesCannotSkipItems--;
        if (window->HiddenFramesForRenderOnly > 0)
            window->HiddenFramesForRenderOnly--;

        // Hide new windows for one frame until they calculate their size
        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
            window->HiddenFramesCannotSkipItems = 1;

        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
        {
            window->HiddenFramesCannotSkipItems = 1;
            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
            {
                if (!window_size_x_set_by_api)
                    window->Size.x = window->SizeFull.x = 0.f;
                if (!window_size_y_set_by_api)
                    window->Size.y = window->SizeFull.y = 0.f;
                window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);
            }
        }

        // SELECT VIEWPORT
        // We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.

        UpdateSelectWindowViewport(window);
        SetCurrentViewport(window, window->Viewport);
        window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
        SetCurrentWindow(window);
        flags = window->Flags;

        // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
        // We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.

        if (flags & ImGuiWindowFlags_ChildWindow)
            window->WindowBorderSize = style.ChildBorderSize;
        else
            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
        if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
        else
            window->WindowPadding = style.WindowPadding;

        // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

        // Collapse window by double-clicking on title bar
        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse) && !window->DockIsActive)
        {
            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
            ImRect title_bar_rect = window->TitleBarRect();
            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
                window->WantCollapseToggle = true;
            if (window->WantCollapseToggle)
            {
                window->Collapsed = !window->Collapsed;
                MarkIniSettingsDirty(window);
            }
        }
        else
        {
            window->Collapsed = false;
        }
        window->WantCollapseToggle = false;

        // SIZE

        // Calculate auto-fit size, handle automatic resize
        const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
        bool use_current_size_for_scrollbar_x = window_just_created;
        bool use_current_size_for_scrollbar_y = window_just_created;
        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
        {
            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
            if (!window_size_x_set_by_api)
            {
                window->SizeFull.x = size_auto_fit.x;
                use_current_size_for_scrollbar_x = true;
            }
            if (!window_size_y_set_by_api)
            {
                window->SizeFull.y = size_auto_fit.y;
                use_current_size_for_scrollbar_y = true;
            }
        }
        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        {
            // Auto-fit may only grow window during the first few frames
            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
            {
                window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
                use_current_size_for_scrollbar_x = true;
            }
            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
            {
                window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
                use_current_size_for_scrollbar_y = true;
            }
            if (!window->Collapsed)
                MarkIniSettingsDirty(window);
        }

        // Apply minimum/maximum window size constraints and final size
        window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

        // Decoration size
        const float decoration_up_height = window->TitleBarHeight() + window->MenuBarHeight();

        // POSITION

        // Popup latch its initial position, will position itself when it appears next frame
        if (window_just_activated_by_user)
        {
            window->AutoPosLastDirection = ImGuiDir_None;
            if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()
                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
        }

        // Position child window
        if (flags & ImGuiWindowFlags_ChildWindow)
        {
            IM_ASSERT(parent_window && parent_window->Active);
            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
            parent_window->DC.ChildWindows.push_back(window);
            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
                window->Pos = parent_window->DC.CursorPos;
        }

        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
        if (window_pos_with_pivot)
            SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
            window->Pos = FindBestWindowPosForPopup(window);

        // Late create viewport if we don't fit within our current host viewport.
        if (window->ViewportAllowPlatformMonitorExtend >= 0 && !window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_Minimized))
            if (!window->Viewport->GetMainRect().Contains(window->Rect()))
            {
                // This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
                //ImGuiViewport* old_viewport = window->Viewport;
                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);

                // FIXME-DPI
                //IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
                SetCurrentViewport(window, window->Viewport);
                window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
                SetCurrentWindow(window);
            }

        bool viewport_rect_changed = false;
        if (window->ViewportOwned)
        {
            // Synchronize window --> viewport in most situations
            // Synchronize viewport -> window in case the platform window has been moved or resized from the OS/WM
            if (window->Viewport->PlatformRequestMove)
            {
                window->Pos = window->Viewport->Pos;
                MarkIniSettingsDirty(window);
            }
            else if (memcmp(&window->Viewport->Pos, &window->Pos, sizeof(window->Pos)) != 0)
            {
                viewport_rect_changed = true;
                window->Viewport->Pos = window->Pos;
            }

            if (window->Viewport->PlatformRequestResize)
            {
                window->Size = window->SizeFull = window->Viewport->Size;
                MarkIniSettingsDirty(window);
            }
            else if (memcmp(&window->Viewport->Size, &window->Size, sizeof(window->Size)) != 0)
            {
                viewport_rect_changed = true;
                window->Viewport->Size = window->Size;
            }
            window->Viewport->UpdateWorkRect();

            // The viewport may have changed monitor since the global update in UpdateViewportsNewFrame()
            // Either a SetNextWindowPos() call in the current frame or a SetWindowPos() call in the previous frame may have this effect.
            if (viewport_rect_changed)
                UpdateViewportPlatformMonitor(window->Viewport);

            // Update common viewport flags
            const ImGuiViewportFlags viewport_flags_to_clear = ImGuiViewportFlags_TopMost | ImGuiViewportFlags_NoTaskBarIcon | ImGuiViewportFlags_NoDecoration | ImGuiViewportFlags_NoRendererClear;
            ImGuiViewportFlags viewport_flags = window->Viewport->Flags & ~viewport_flags_to_clear;
            const bool is_modal = (flags & ImGuiWindowFlags_Modal) != 0;
            const bool is_short_lived_floating_window = (flags & (ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup)) != 0;
            if (flags & ImGuiWindowFlags_Tooltip)
                viewport_flags |= ImGuiViewportFlags_TopMost;
            if ((g.IO.ConfigViewportsNoTaskBarIcon || is_short_lived_floating_window) && !is_modal)
                viewport_flags |= ImGuiViewportFlags_NoTaskBarIcon;
            if (g.IO.ConfigViewportsNoDecoration || is_short_lived_floating_window)
                viewport_flags |= ImGuiViewportFlags_NoDecoration;

            // Not correct to set modal as topmost because:
            // - Because other popups can be stacked above a modal (e.g. combo box in a modal)
            // - ImGuiViewportFlags_TopMost is currently handled different in backends: in Win32 it is "appear top most" whereas in GLFW and SDL it is "stay topmost"
            //if (flags & ImGuiWindowFlags_Modal)
            //    viewport_flags |= ImGuiViewportFlags_TopMost;

            // For popups and menus that may be protruding out of their parent viewport, we enable _NoFocusOnClick so that clicking on them
            // won't steal the OS focus away from their parent window (which may be reflected in OS the title bar decoration).
            // Setting _NoFocusOnClick would technically prevent us from bringing back to front in case they are being covered by an OS window from a different app,
            // but it shouldn't be much of a problem considering those are already popups that are closed when clicking elsewhere.
            if (is_short_lived_floating_window && !is_modal)
                viewport_flags |= ImGuiViewportFlags_NoFocusOnAppearing | ImGuiViewportFlags_NoFocusOnClick;

            // We can overwrite viewport flags using ImGuiWindowClass (advanced users)
            // We don't default to the main viewport because.
            if (window->WindowClass.ParentViewportId)
                window->Viewport->ParentViewportId = window->WindowClass.ParentViewportId;
            else if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && parent_window_in_stack)
                window->Viewport->ParentViewportId = parent_window_in_stack->Viewport->ID;
            else
                window->Viewport->ParentViewportId = g.IO.ConfigViewportsNoDefaultParent ? 0 : IMGUI_VIEWPORT_DEFAULT_ID;
            if (window->WindowClass.ViewportFlagsOverrideSet)
                viewport_flags |= window->WindowClass.ViewportFlagsOverrideSet;
            if (window->WindowClass.ViewportFlagsOverrideClear)
                viewport_flags &= ~window->WindowClass.ViewportFlagsOverrideClear;

            // We can also tell the backend that clearing the platform window won't be necessary,
            // as our window background is filling the viewport and we have disabled BgAlpha.
            // FIXME: Work on support for per-viewport transparency (#2766)
            if (!(flags & ImGuiWindowFlags_NoBackground))
                viewport_flags |= ImGuiViewportFlags_NoRendererClear;

            window->Viewport->Flags = viewport_flags;
        }

        // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
        // When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
        ImRect viewport_rect(window->Viewport->GetMainRect());
        ImRect viewport_work_rect(window->Viewport->GetWorkRect());
        ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
        ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);

        // Clamp position/size so window stays visible within its viewport or monitor
        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
        // FIXME: Similar to code in GetWindowAllowedExtentRect()
        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
        {
            if (!window->ViewportOwned && viewport_rect.GetWidth() > 0 && viewport_rect.GetHeight() > 0.0f)
            {
                ClampWindowRect(window, visibility_rect);
            }
            else if (window->ViewportOwned && g.PlatformIO.Monitors.Size > 0)
            {
                // Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
                const ImGuiPlatformMonitor* monitor = GetViewportPlatformMonitor(window->Viewport);
                visibility_rect.Min = monitor->WorkPos + visibility_padding;
                visibility_rect.Max = monitor->WorkPos + monitor->WorkSize - visibility_padding;
                ClampWindowRect(window, visibility_rect);
            }
        }
        window->Pos = ImFloor(window->Pos);

        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        // Large values tend to lead to variety of artifacts and are not recommended.
        if (window->ViewportOwned || window->DockIsActive)
            window->WindowRounding = 0.0f;
        else
            window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

        // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
        //if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
        //    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);

        // Apply window focus (new and reactivated windows are moved to front)
        bool want_focus = false;
        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
        {
            if (flags & ImGuiWindowFlags_Popup)
                want_focus = true;
            else if ((window->DockIsActive || (flags & ImGuiWindowFlags_ChildWindow) == 0) && !(flags & ImGuiWindowFlags_Tooltip))
                want_focus = true;
        }

        // Decide if we are going to handle borders and resize grips
        const bool handle_borders_and_resize_grips = (window->DockNodeAsHost || !window->DockIsActive);

        // Handle manual resize: Resize Grips, Borders, Gamepad
        int border_held = -1;
        ImU32 resize_grip_col[4] = {};
        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
        const float resize_grip_draw_size = IM_FLOOR(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
        if (handle_borders_and_resize_grips && !window->Collapsed)
            if (UpdateWindowManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))
                use_current_size_for_scrollbar_x = use_current_size_for_scrollbar_y = true;
        window->ResizeBorderHeld = (signed char)border_held;

        // Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
        if (window->ViewportOwned)
        {
            if (!window->Viewport->PlatformRequestMove)
                window->Viewport->Pos = window->Pos;
            if (!window->Viewport->PlatformRequestResize)
                window->Viewport->Size = window->Size;
            window->Viewport->UpdateWorkRect();
            viewport_rect = window->Viewport->GetMainRect();
        }

        // Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
        window->ViewportPos = window->Viewport->Pos;

        // SCROLLBAR VISIBILITY

        // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
        if (!window->Collapsed)
        {
            // When reading the current size we need to read it after size constraints have been applied.
            // When we use InnerRect here we are intentionally reading last frame size, same for ScrollbarSizes values before we set them again.
            ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - decoration_up_height);
            ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + window->ScrollbarSizes;
            ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
            float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
            float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
            //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
            if (window->ScrollbarX && !window->ScrollbarY)
                window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar);
            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
        }

        // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
        // Update various regions. Variables they depends on should be set above in this function.
        // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.

        // Outer rectangle
        // Not affected by window border size. Used by:
        // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
        // - Begin() initial clipping rect for drawing window background and borders.
        // - Begin() clipping whole child
        const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
        const ImRect outer_rect = window->Rect();
        const ImRect title_bar_rect = window->TitleBarRect();
        window->OuterRectClipped = outer_rect;
        if (window->DockIsActive)
            window->OuterRectClipped.Min.y += window->TitleBarHeight();
        window->OuterRectClipped.ClipWith(host_rect);

        // Inner rectangle
        // Not affected by window border size. Used by:
        // - InnerClipRect
        // - ScrollToBringRectIntoView()
        // - NavUpdatePageUpPageDown()
        // - Scrollbar()
        window->InnerRect.Min.x = window->Pos.x;
        window->InnerRect.Min.y = window->Pos.y + decoration_up_height;
        window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x;
        window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y;

        // Inner clipping rectangle.
        // Will extend a little bit outside the normal work region.
        // This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        // Affected by window/frame border size. Used by:
        // - Begin() initial clip rect
        float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(ImFloor(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size);
        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - ImMax(ImFloor(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y - window->WindowBorderSize);
        window->InnerClipRect.ClipWithFull(host_rect);

        // Default item width. Make it proportional to window size if window manually resizes
        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
            window->ItemWidthDefault = ImFloor(window->Size.x * 0.65f);
        else
            window->ItemWidthDefault = ImFloor(g.FontSize * 16.0f);

        // SCROLLING

        // Lock down maximum scrolling
        // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
        // for right/bottom aligned items without creating a scrollbar.
        window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
        window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());

        // Apply scrolling
        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

        // DRAWING

        // Setup draw list and outer clipping rectangle
        IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);
        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
        PushClipRect(host_rect.Min, host_rect.Max, false);

        // Draw modal or window list full viewport dimming background (for other viewports we'll render them in EndFrame)
        ImGuiWindow* window_window_list = g.NavWindowingListWindow;
        const bool dim_bg_for_modal = (flags & ImGuiWindowFlags_Modal) && window == GetTopMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
        const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && ((window == g.NavWindowingTargetAnim->RootWindowDockTree) || (window == window_window_list && window_window_list->Viewport != g.NavWindowingTargetAnim->Viewport));
        if (dim_bg_for_modal || dim_bg_for_window_list)
        {
            const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
            window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
        }

        // Draw navigation selection/windowing rectangle background
        if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
        {
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
                window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
        }

        // Since 1.71, child window can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call.
        // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
        // We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping child.
        // We also disabled this when we have dimming overlay behind this specific one child.
        // FIXME: More code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected.
        const bool is_undocked_or_docked_visible = !window->DockIsActive || window->DockTabIsVisible;
        if (is_undocked_or_docked_visible)
        {
            bool render_decorations_in_parent = false;
            if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
                if (window->DrawList->CmdBuffer.back().ElemCount == 0 && parent_window->DrawList->VtxBuffer.Size > 0)
                    render_decorations_in_parent = true;
            if (render_decorations_in_parent)
                window->DrawList = parent_window->DrawList;

            // Handle title bar, scrollbar, resize grips and resize borders
            const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
            const bool title_bar_is_highlight = want_focus || (window_to_highlight && (window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight || (window->DockNode && window->DockNode == window_to_highlight->DockNode)));
            RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);

            if (render_decorations_in_parent)
                window->DrawList = &window->DrawListInst;
        }

        // Draw navigation selection/windowing rectangle border
        if (g.NavWindowingTargetAnim == window)
        {
            float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
            {
                bb.Expand(-g.FontSize - 1.0f);
                rounding = window->WindowRounding;
            }
            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, 0, 3.0f);
        }

        // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)

        // Work rectangle.
        // Affected by window padding and border size. Used by:
        // - Columns() for right-most edge
        // - TreeNode(), CollapsingHeader() for right-most edge
        // - BeginTabBar() for right-most edge
        const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
        const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
        const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - window->ScrollbarSizes.x));
        const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - decoration_up_height - window->ScrollbarSizes.y));
        window->WorkRect.Min.x = ImFloor(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
        window->WorkRect.Min.y = ImFloor(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
        window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
        window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
        window->ParentWorkRect = window->WorkRect;

        // [LEGACY] Content Region
        // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        // Used by:
        // - Mouse wheel scrolling + many other things
        window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
        window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + decoration_up_height;
        window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - window->ScrollbarSizes.x));
        window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - decoration_up_height - window->ScrollbarSizes.y));

        // Setup drawing context
        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
        window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
        window->DC.GroupOffset.x = 0.0f;
        window->DC.ColumnsOffset.x = 0.0f;
        window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.Indent.x + window->DC.ColumnsOffset.x, decoration_up_height + window->WindowPadding.y - window->Scroll.y);
        window->DC.CursorPos = window->DC.CursorStartPos;
        window->DC.CursorPosPrevLine = window->DC.CursorPos;
        window->DC.CursorMaxPos = window->DC.CursorStartPos;
        window->DC.IdealMaxPos = window->DC.CursorStartPos;
        window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
        window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;

        window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
        window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
        window->DC.NavLayersActiveMaskNext = 0x00;
        window->DC.NavHideHighlightOneFrame = false;
        window->DC.NavHasScroll = (window->ScrollMax.y > 0.0f);

        window->DC.MenuBarAppending = false;
        window->DC.MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);
        window->DC.TreeDepth = 0;
        window->DC.TreeJumpToParentOnPopMask = 0x00;
        window->DC.ChildWindows.resize(0);
        window->DC.StateStorage = &window->StateStorage;
        window->DC.CurrentColumns = NULL;
        window->DC.LayoutType = ImGuiLayoutType_Vertical;
        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
        window->DC.FocusCounterRegular = window->DC.FocusCounterTabStop = -1;

        window->DC.ItemWidth = window->ItemWidthDefault;
        window->DC.TextWrapPos = -1.0f; // disabled
        window->DC.ItemWidthStack.resize(0);
        window->DC.TextWrapPosStack.resize(0);

        if (window->AutoFitFramesX > 0)
            window->AutoFitFramesX--;
        if (window->AutoFitFramesY > 0)
            window->AutoFitFramesY--;

        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
        if (want_focus)
        {
            FocusWindow(window);
            NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
        }

        // Close requested by platform window
        if (p_open != NULL && window->Viewport->PlatformRequestClose && window->Viewport != GetMainViewport())
        {
            if (!window->DockIsActive || window->DockTabIsVisible)
            {
                window->Viewport->PlatformRequestClose = false;
                g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue.
                IMGUI_DEBUG_LOG_VIEWPORT("Window '%s' PlatformRequestClose\n", window->Name);
                *p_open = false;
            }
        }

        // Title bar
        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
            RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);

        // Clear hit test shape every frame
        window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;

        // Pressing CTRL+C while holding on a window copy its content to the clipboard
        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
        // Maybe we can support CTRL+C on every element?
        /*
        //if (g.NavWindow == window && g.ActiveId == 0)
        if (g.ActiveId == window->MoveId)
            if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))
                LogToClipboard();
        */

        if (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable)
        {
            // Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
            // We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
            if (g.MovingWindow == window && g.IO.KeyShift == false)
                if ((window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoDocking) == 0)
                    BeginDockableDragDropSource(window);

            // Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
            if (g.DragDropActive && !(flags & ImGuiWindowFlags_NoDocking))
                if (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != window)
                    if ((window == window->RootWindowDockTree) && !(window->Flags & ImGuiWindowFlags_DockNodeHost))
                        BeginDockableDragDropTarget(window);
        }

        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
        // This is useful to allow creating context menus on title bar only, etc.
        if (window->DockIsActive)
            SetLastItemData(window, window->ID, window->DockTabItemStatusFlags, window->DockTabItemRect);
        else
            SetLastItemData(window, window->MoveId, IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, title_bar_rect);

#ifdef IMGUI_ENABLE_TEST_ENGINE
        if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
            IMGUI_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
    }
    else
    {
        // Append
        SetCurrentViewport(window, window->Viewport);
        SetCurrentWindow(window);
    }

    // Pull/inherit current state
    g.CurrentItemFlags = g.ItemFlagsStack.back(); // Inherit from shared stack
    window->DC.NavFocusScopeIdCurrent = (flags & ImGuiWindowFlags_ChildWindow) ? parent_window->DC.NavFocusScopeIdCurrent : 0; // Inherit from parent only // -V595

    if (!(flags & ImGuiWindowFlags_DockNodeHost))
        PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    window->WriteAccessed = false;
    window->BeginCount++;
    g.NextWindowData.ClearFlags();

    // Update visibility
    if (first_begin_of_the_frame)
    {
        // When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
        // This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
        // This is analogous to regular windows being hidden from one frame.
        // It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
        if (window->DockIsActive && !window->DockTabIsVisible)
        {
            if (window->LastFrameJustFocused == g.FrameCount)
                window->HiddenFramesCannotSkipItems = 1;
            else
                window->HiddenFramesCanSkipItems = 1;
        }

        if (flags & ImGuiWindowFlags_ChildWindow)
        {
            // Child window can be out of sight and have "negative" clip windows.
            // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
            IM_ASSERT((flags& ImGuiWindowFlags_NoTitleBar) != 0 || (window->DockIsActive));
            if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0) // FIXME: Doesn't make sense for ChildWindow??
                if (!g.LogEnabled)
                    if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
                        window->HiddenFramesCanSkipItems = 1;

            // Hide along with parent or if parent is collapsed
            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
                window->HiddenFramesCanSkipItems = 1;
            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
                window->HiddenFramesCannotSkipItems = 1;
        }

        // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
        if (style.Alpha <= 0.0f)
            window->HiddenFramesCanSkipItems = 1;

        // Update the Hidden flag
        window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0) || (window->HiddenFramesForRenderOnly > 0);

        // Disable inputs for requested number of frames
        if (window->DisableInputsFrames > 0)
        {
            window->DisableInputsFrames--;
            window->Flags |= ImGuiWindowFlags_NoInputs;
        }

        // Update the SkipItems flag, used to early out of all items functions (no layout required)
        bool skip_items = false;
        if (window->Collapsed || !window->Active || window->Hidden)
            if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
                skip_items = true;
        window->SkipItems = skip_items;
    }

    return !window->SkipItems;
}

void ImGui::End()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // Error checking: verify that user hasn't called End() too many times!
    if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)
    {
        IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!");
        return;
    }
    IM_ASSERT(g.CurrentWindowStack.Size > 0);

    // Error checking: verify that user doesn't directly call End() on a child window.
    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->DockIsActive)
        IM_ASSERT_USER_ERROR(g.WithinEndChild, "Must call EndChild() and not End()!");

    // Close anything that is open
    if (window->DC.CurrentColumns)
        EndColumns();
    if (!(window->Flags & ImGuiWindowFlags_DockNodeHost))   // Pop inner window clip rectangle
        PopClipRect();

    // Stop logging
    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
        LogFinish();

    // Docking: report contents sizes to parent to allow for auto-resize
    if (window->DockNode && window->DockTabIsVisible)
        if (ImGuiWindow* host_window = window->DockNode->HostWindow)         // FIXME-DOCK
            host_window->DC.CursorMaxPos = window->DC.CursorMaxPos + window->WindowPadding - host_window->WindowPadding;

    // Pop from window stack
    g.CurrentWindowStack.pop_back();
    if (window->Flags & ImGuiWindowFlags_Popup)
        g.BeginPopupStack.pop_back();
    window->DC.StackSizesOnBegin.CompareWithCurrentState();
    SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());
    if (g.CurrentWindow)
        SetCurrentViewport(g.CurrentWindow, g.CurrentWindow->Viewport);
}

void ImGui::BringWindowToFocusFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(window == window->RootWindow);

    const int cur_order = window->FocusOrder;
    IM_ASSERT(g.WindowsFocusOrder[cur_order] == window);
    if (g.WindowsFocusOrder.back() == window)
        return;

    const int new_order = g.WindowsFocusOrder.Size - 1;
    for (int n = cur_order; n < new_order; n++)
    {
        g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
        g.WindowsFocusOrder[n]->FocusOrder--;
        IM_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
    }
    g.WindowsFocusOrder[new_order] = window;
    window->FocusOrder = (short)new_order;
}

void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* current_front_window = g.Windows.back();
    if (current_front_window == window || current_front_window->RootWindowDockTree == window) // Cheap early out (could be better)
        return;
    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the top-most window
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
            g.Windows[g.Windows.Size - 1] = window;
            break;
        }
}

void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.Windows[0] == window)
        return;
    for (int i = 0; i < g.Windows.Size; i++)
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));
            g.Windows[0] = window;
            break;
        }
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
void ImGui::FocusWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    if (g.NavWindow != window)
    {
        g.NavWindow = window;
        if (window && g.NavDisableMouseHover)
            g.NavMousePosDirty = true;
        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
        g.NavFocusScopeId = 0;
        g.NavIdIsAlive = false;
        g.NavLayer = ImGuiNavLayer_Main;
        g.NavInitRequest = g.NavMoveRequest = false;
        NavUpdateAnyRequestFlag();
        //IMGUI_DEBUG_LOG("FocusWindow(\"%s\")\n", window ? window->Name : NULL);
    }

    // Close popups if any
    ClosePopupsOverWindow(window, false);

    // Move the root window to the top of the pile
    IM_ASSERT(window == NULL || window->RootWindowDockTree != NULL);
    ImGuiWindow* focus_front_window = window ? window->RootWindow : NULL;
    ImGuiWindow* display_front_window = window ? window->RootWindowDockTree : NULL;
    ImGuiDockNode* dock_node = window ? window->DockNode : NULL;
    bool active_id_window_is_dock_node_host = (g.ActiveIdWindow && dock_node && dock_node->HostWindow == g.ActiveIdWindow);

    // Steal active widgets. Some of the cases it triggers includes:
    // - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
    // - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
    // - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
    if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
        if (!g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host)
            ClearActiveID();

    // Passing NULL allow to disable keyboard focus
    if (!window)
        return;
    window->LastFrameJustFocused = g.FrameCount;

    // Select in dock node
    if (dock_node && dock_node->TabBar)
        dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->ID;

    // Bring to front
    BringWindowToFocusFront(focus_front_window);
    if (((window->Flags | focus_front_window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
        BringWindowToDisplayFront(display_front_window);
}

void ImGui::FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window)
{
    ImGuiContext& g = *GImGui;

    const int start_idx = ((under_this_window != NULL) ? FindWindowFocusIndex(under_this_window) : g.WindowsFocusOrder.Size) - 1;
    for (int i = start_idx; i >= 0; i--)
    {
        // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
        ImGuiWindow* window = g.WindowsFocusOrder[i];
        IM_ASSERT(window == window->RootWindow);
        if (window != ignore_window && window->WasActive)
            if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))
            {
                // FIXME-DOCK: This is failing (lagging by one frame) for docked windows.
                // If A and B are docked into window and B disappear, at the NewFrame() call site window->NavLastChildNavWindow will still point to B.
                // We might leverage the tab order implicitly stored in window->DockNodeAsHost->TabBar (essentially the 'most_recently_selected_tab' code in tab bar will do that but on next update)
                // to tell which is the "previous" window. Or we may leverage 'LastFrameFocused/LastFrameJustFocused' and have this function handle child window itself?
                ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(window);
                FocusWindow(focus_window);
                return;
            }
    }
    FocusWindow(NULL);
}

// Important: this alone doesn't alter current ImDrawList state. This is called by PushFont/PopFont only.
void ImGui::SetCurrentFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    IM_ASSERT(font->Scale > 0.0f);
    g.Font = font;
    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

    ImFontAtlas* atlas = g.Font->ContainerAtlas;
    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
    g.DrawListSharedData.Font = g.Font;
    g.DrawListSharedData.FontSize = g.FontSize;
}

void ImGui::PushFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    if (!font)
        font = GetDefaultFont();
    SetCurrentFont(font);
    g.FontStack.push_back(font);
    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);
}

void  ImGui::PopFont()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DrawList->PopTextureID();
    g.FontStack.pop_back();
    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());
}

void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)
{
    ImGuiContext& g = *GImGui;
    ImGuiItemFlags item_flags = g.CurrentItemFlags;
    IM_ASSERT(item_flags == g.ItemFlagsStack.back());
    if (enabled)
        item_flags |= option;
    else
        item_flags &= ~option;
    g.CurrentItemFlags = item_flags;
    g.ItemFlagsStack.push_back(item_flags);
}

void ImGui::PopItemFlag()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.ItemFlagsStack.Size > 1); // Too many calls to PopItemFlag() - we always leave a 0 at the bottom of the stack.
    g.ItemFlagsStack.pop_back();
    g.CurrentItemFlags = g.ItemFlagsStack.back();
}

// FIXME: Look into renaming this once we have settled the new Focus/Activation/TabStop system.
void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)
{
    PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);
}

void ImGui::PopAllowKeyboardFocus()
{
    PopItemFlag();
}

void ImGui::PushButtonRepeat(bool repeat)
{
    PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);
}

void ImGui::PopButtonRepeat()
{
    PopItemFlag();
}

void ImGui::PushTextWrapPos(float wrap_pos_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPosStack.push_back(window->DC.TextWrapPos);
    window->DC.TextWrapPos = wrap_pos_x;
}

void ImGui::PopTextWrapPos()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();
    window->DC.TextWrapPosStack.pop_back();
}

bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
{
    if (window->RootWindowDockTree == potential_parent)
        return true;
    while (window != NULL)
    {
        if (window == potential_parent)
            return true;
        window = window->ParentWindow;
    }
    return false;
}

bool ImGui::IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below)
{
    ImGuiContext& g = *GImGui;
    for (int i = g.Windows.Size - 1; i >= 0; i--)
    {
        ImGuiWindow* candidate_window = g.Windows[i];
        if (candidate_window == potential_above)
            return true;
        if (candidate_window == potential_below)
            return false;
    }
    return false;
}

bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)
{
    IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function
    ImGuiContext& g = *GImGui;
    if (g.HoveredWindow == NULL)
        return false;

    if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)
    {
        ImGuiWindow* window = g.CurrentWindow;
        switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))
        {
        case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:
            if (g.HoveredWindow->RootWindow != window->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_RootWindow:
            if (g.HoveredWindow != window->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_ChildWindows:
            if (!IsWindowChildOf(g.HoveredWindow, window))
                return false;
            break;
        default:
            if (g.HoveredWindow != window)
                return false;
            break;
        }
    }

    if (!IsWindowContentHoverable(g.HoveredWindow, flags))
        return false;
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)
            return false;
    return true;
}

bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)
{
    ImGuiContext& g = *GImGui;

    if (flags & ImGuiFocusedFlags_AnyWindow)
        return g.NavWindow != NULL;

    IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()
    switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))
    {
    case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_RootWindow:
        return g.NavWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);
    default:
        return g.NavWindow == g.CurrentWindow;
    }
}

ImGuiID ImGui::GetWindowDockID()
{
    ImGuiContext& g = *GImGui;
    return g.CurrentWindow->DockId;
}

bool ImGui::IsWindowDocked()
{
    ImGuiContext& g = *GImGui;
    return g.CurrentWindow->DockIsActive;
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmatically.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)
{
    return window->WasActive && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);
}

float ImGui::GetWindowWidth()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.x;
}

float ImGui::GetWindowHeight()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.y;
}

ImVec2 ImGui::GetWindowPos()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return window->Pos;
}

void ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);

    // Set
    const ImVec2 old_pos = window->Pos;
    window->Pos = ImFloor(pos);
    ImVec2 offset = window->Pos - old_pos;
    window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
    window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
    window->DC.IdealMaxPos += offset;
    window->DC.CursorStartPos += offset;
}

void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    SetWindowPos(window, pos, cond);
}

void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowPos(window, pos, cond);
}

ImVec2 ImGui::GetWindowSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Size;
}

void ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    if (size.x > 0.0f)
    {
        window->AutoFitFramesX = 0;
        window->SizeFull.x = IM_FLOOR(size.x);
    }
    else
    {
        window->AutoFitFramesX = 2;
        window->AutoFitOnlyGrows = false;
    }
    if (size.y > 0.0f)
    {
        window->AutoFitFramesY = 0;
        window->SizeFull.y = IM_FLOOR(size.y);
    }
    else
    {
        window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
}

void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
{
    SetWindowSize(GImGui->CurrentWindow, size, cond);
}

void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowSize(window, size, cond);
}

void ImGui::SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
        return;
    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    window->Collapsed = collapsed;
}

void ImGui::SetWindowHitTestHole(ImGuiWindow* window, const ImVec2& pos, const ImVec2& size)
{
    IM_ASSERT(window->HitTestHoleSize.x == 0);     // We don't support multiple holes/hit test filters
    window->HitTestHoleSize = ImVec2ih(size);
    window->HitTestHoleOffset = ImVec2ih(pos - window->Pos);
}

void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);
}

bool ImGui::IsWindowCollapsed()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Collapsed;
}

bool ImGui::IsWindowAppearing()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Appearing;
}

void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowCollapsed(window, collapsed, cond);
}

void ImGui::SetWindowFocus()
{
    FocusWindow(GImGui->CurrentWindow);
}

void ImGui::SetWindowFocus(const char* name)
{
    if (name)
    {
        if (ImGuiWindow* window = FindWindowByName(name))
            FocusWindow(window);
    }
    else
    {
        FocusWindow(NULL);
    }
}

void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
    g.NextWindowData.PosVal = pos;
    g.NextWindowData.PosPivotVal = pivot;
    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
    g.NextWindowData.PosUndock = true;
}

void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
    g.NextWindowData.SizeVal = size;
    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;
    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
    g.NextWindowData.SizeCallback = custom_callback;
    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

// Content size = inner scrollable rectangle, padded with WindowPadding.
// SetNextWindowContentSize(ImVec2(100,100) + ImGuiWindowFlags_AlwaysAutoResize will always allow submitting a 100x100 item.
void ImGui::SetNextWindowContentSize(const ImVec2& size)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasContentSize;
    g.NextWindowData.ContentSizeVal = ImFloor(size);
}

void ImGui::SetNextWindowScroll(const ImVec2& scroll)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasScroll;
    g.NextWindowData.ScrollVal = scroll;
}

void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasCollapsed;
    g.NextWindowData.CollapsedVal = collapsed;
    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowFocus()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasFocus;
}

void ImGui::SetNextWindowBgAlpha(float alpha)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasBgAlpha;
    g.NextWindowData.BgAlphaVal = alpha;
}

void ImGui::SetNextWindowViewport(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasViewport;
    g.NextWindowData.ViewportId = id;
}

void ImGui::SetNextWindowDockID(ImGuiID id, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasDock;
    g.NextWindowData.DockCond = cond ? cond : ImGuiCond_Always;
    g.NextWindowData.DockId = id;
}

void ImGui::SetNextWindowClass(const ImGuiWindowClass* window_class)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT((window_class->ViewportFlagsOverrideSet & window_class->ViewportFlagsOverrideClear) == 0); // Cannot set both set and clear for the same bit
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasWindowClass;
    g.NextWindowData.WindowClass = *window_class;
}

ImDrawList* ImGui::GetWindowDrawList()
{
    ImGuiWindow* window = GetCurrentWindow();
    return window->DrawList;
}

float ImGui::GetWindowDpiScale()
{
    ImGuiContext& g = *GImGui;
    return g.CurrentDpiScale;
}

ImGuiViewport* ImGui::GetWindowViewport()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.CurrentViewport != NULL && g.CurrentViewport == g.CurrentWindow->Viewport);
    return g.CurrentViewport;
}

ImFont* ImGui::GetFont()
{
    return GImGui->Font;
}

float ImGui::GetFontSize()
{
    return GImGui->FontSize;
}

ImVec2 ImGui::GetFontTexUvWhitePixel()
{
    return GImGui->DrawListSharedData.TexUvWhitePixel;
}

void ImGui::SetWindowFontScale(float scale)
{
    IM_ASSERT(scale > 0.0f);
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->FontWindowScale = scale;
    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void ImGui::ActivateItem(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.NavNextActivateId = id;
}

void ImGui::PushFocusScope(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    g.FocusScopeStack.push_back(window->DC.NavFocusScopeIdCurrent);
    window->DC.NavFocusScopeIdCurrent = id;
}

void ImGui::PopFocusScope()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(g.FocusScopeStack.Size > 0); // Too many PopFocusScope() ?
    window->DC.NavFocusScopeIdCurrent = g.FocusScopeStack.back();
    g.FocusScopeStack.pop_back();
}

void ImGui::SetKeyboardFocusHere(int offset)
{
    IM_ASSERT(offset >= -1);    // -1 is allowed but not below
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    g.TabFocusRequestNextWindow = window;
    g.TabFocusRequestNextCounterRegular = window->DC.FocusCounterRegular + 1 + offset;
    g.TabFocusRequestNextCounterTabStop = INT_MAX;
}

void ImGui::SetItemDefaultFocus()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!window->Appearing)
        return;
    if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == window->DC.NavLayerCurrent)
    {
        g.NavInitRequest = false;
        g.NavInitResultId = window->DC.LastItemId;
        g.NavInitResultRectRel = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);
        NavUpdateAnyRequestFlag();
        if (!IsItemVisible())
            SetScrollHereY();
    }
}

void ImGui::SetStateStorage(ImGuiStorage* tree)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

ImGuiStorage* ImGui::GetStateStorage()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->DC.StateStorage;
}

void ImGui::PushID(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiID id = window->GetIDNoKeepAlive(str_id);
    window->IDStack.push_back(id);
}

void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiID id = window->GetIDNoKeepAlive(str_id_begin, str_id_end);
    window->IDStack.push_back(id);
}

void ImGui::PushID(const void* ptr_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiID id = window->GetIDNoKeepAlive(ptr_id);
    window->IDStack.push_back(id);
}

void ImGui::PushID(int int_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiID id = window->GetIDNoKeepAlive(int_id);
    window->IDStack.push_back(id);
}

// Push a given id value ignoring the ID stack as a seed.
void ImGui::PushOverrideID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->IDStack.push_back(id);
}

// Helper to avoid a common series of PushOverrideID -> GetID() -> PopID() call
// (note that when using this pattern, TestEngine's "Stack Tool" will tend to not display the intermediate stack level.
//  for that to work we would need to do PushOverrideID() -> ItemAdd() -> PopID() which would alter widget code a little more)
ImGuiID ImGui::GetIDWithSeed(const char* str, const char* str_end, ImGuiID seed)
{
    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
    ImGui::KeepAliveID(id);
#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiContext& g = *GImGui;
    IMGUI_TEST_ENGINE_ID_INFO2(id, ImGuiDataType_String, str, str_end);
#endif
    return id;
}

void ImGui::PopID()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    IM_ASSERT(window->IDStack.Size > 1); // Too many PopID(), or could be popping in a wrong/different window?
    window->IDStack.pop_back();
}

ImGuiID ImGui::GetID(const char* str_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(str_id);
}

ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(str_id_begin, str_id_end);
}

ImGuiID ImGui::GetID(const void* ptr_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(ptr_id);
}

bool ImGui::IsRectVisible(const ImVec2& size)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));
}

bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));
}


//-----------------------------------------------------------------------------
// [SECTION] ERROR CHECKING
//-----------------------------------------------------------------------------

// Helper function to verify ABI compatibility between caller code and compiled version of Dear ImGui.
// Verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If the user has inconsistent compilation settings, imgui configuration #define, packing pragma, etc. your user code
// may see different structures than what imgui.cpp sees, which is problematic.
// We usually require settings to be in imconfig.h to make sure that they are accessible to all compilation units involved with Dear ImGui.
bool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert, size_t sz_idx)
{
    bool error = false;
    if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
    if (sz_io != sizeof(ImGuiIO)) { error = true; IM_ASSERT(sz_io == sizeof(ImGuiIO) && "Mismatched struct layout!"); }
    if (sz_style != sizeof(ImGuiStyle)) { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle) && "Mismatched struct layout!"); }
    if (sz_vec2 != sizeof(ImVec2)) { error = true; IM_ASSERT(sz_vec2 == sizeof(ImVec2) && "Mismatched struct layout!"); }
    if (sz_vec4 != sizeof(ImVec4)) { error = true; IM_ASSERT(sz_vec4 == sizeof(ImVec4) && "Mismatched struct layout!"); }
    if (sz_vert != sizeof(ImDrawVert)) { error = true; IM_ASSERT(sz_vert == sizeof(ImDrawVert) && "Mismatched struct layout!"); }
    if (sz_idx != sizeof(ImDrawIdx)) { error = true; IM_ASSERT(sz_idx == sizeof(ImDrawIdx) && "Mismatched struct layout!"); }
    return !error;
}

static void ImGui::ErrorCheckNewFrameSanityChecks()
{
    ImGuiContext& g = *GImGui;

    // Check user IM_ASSERT macro
    // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
    //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
    //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
    // #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
    // #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
    if (true) IM_ASSERT(1); else IM_ASSERT(0);

    // Check user data
    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    IM_ASSERT(g.Initialized);
    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
    IM_ASSERT(g.IO.Fonts->Fonts.Size > 0                                && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()?");
    IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded()                          && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()?");
    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
    IM_ASSERT(g.Style.CircleTessellationMaxError  > 0.0f                && "Invalid style setting!");
    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
    IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
    IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right);
    for (int n = 0; n < ImGuiKey_COUNT; n++)
        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)");

    // Check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only added in 1.60 WIP)
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)
        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");

    // Check: the io.ConfigWindowsResizeFromEdges option requires backend to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
        g.IO.ConfigWindowsResizeFromEdges = false;

    // Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_DockingEnable) == 0)
        IM_ASSERT(0 && "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable) == 0)
        IM_ASSERT(0 && "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");

    // Perform simple checks: multi-viewport and platform windows support
    if (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        if ((g.IO.BackendFlags & ImGuiBackendFlags_PlatformHasViewports) && (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasViewports))
        {
            IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded) && "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.");
            IM_ASSERT(g.PlatformIO.Platform_CreateWindow  != NULL && "Platform init didn't install handlers?");
            IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != NULL && "Platform init didn't install handlers?");
            IM_ASSERT(g.PlatformIO.Platform_GetWindowPos  != NULL && "Platform init didn't install handlers?");
            IM_ASSERT(g.PlatformIO.Platform_SetWindowPos  != NULL && "Platform init didn't install handlers?");
            IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != NULL && "Platform init didn't install handlers?");
            IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != NULL && "Platform init didn't install handlers?");
            IM_ASSERT(g.PlatformIO.Monitors.Size > 0 && "Platform init didn't setup Monitors list?");
            IM_ASSERT((g.Viewports[0]->PlatformUserData != NULL || g.Viewports[0]->PlatformHandle != NULL) && "Platform init didn't setup main viewport.");
            if (g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
                IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != NULL && "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!");
        }
        else
        {
            // Disable feature, our backends do not support it
            g.IO.ConfigFlags &= ~ImGuiConfigFlags_ViewportsEnable;
        }

        // Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
        for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size; monitor_n++)
        {
            ImGuiPlatformMonitor& mon = g.PlatformIO.Monitors[monitor_n];
            IM_UNUSED(mon);
            IM_ASSERT(mon.MainSize.x > 0.0f && mon.MainSize.y > 0.0f && "Monitor main bounds not setup properly.");
            IM_ASSERT(ImRect(mon.MainPos, mon.MainPos + mon.MainSize).Contains(ImRect(mon.WorkPos, mon.WorkPos + mon.WorkSize)) && "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.");
            IM_ASSERT(mon.DpiScale != 0.0f);
        }
    }
}

static void ImGui::ErrorCheckEndFrameSanityChecks()
{
    ImGuiContext& g = *GImGui;

    // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
    // One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
    // It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
    // send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
    // We silently accommodate for this case by ignoring/ the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
    // while still correctly asserting on mid-frame key press events.
    const ImGuiKeyModFlags key_mod_flags = GetMergedKeyModFlags();
    IM_ASSERT((key_mod_flags == 0 || g.IO.KeyMods == key_mod_flags) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
    IM_UNUSED(key_mod_flags);

    // Recover from errors
    //ErrorCheckEndFrameRecover();

    // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
    // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
    if (g.CurrentWindowStack.Size != 1)
    {
        if (g.CurrentWindowStack.Size > 1)
        {
            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
            while (g.CurrentWindowStack.Size > 1)
                End();
        }
        else
        {
            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
        }
    }

    IM_ASSERT_USER_ERROR(g.GroupStack.Size == 0, "Missing EndGroup call!");
}

// Experimental recovery from incorrect usage of BeginXXX/EndXXX/PushXXX/PopXXX calls.
// Must be called during or before EndFrame().
// This is generally flawed as we are not necessarily End/Popping things in the right order.
// FIXME: Can't recover from inside BeginTabItem/EndTabItem yet.
// FIXME: Can't recover from interleaved BeginTabBar/Begin
void    ImGui::ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback, void* user_data)
{
    // PVS-Studio V1044 is "Loop break conditions do not depend on the number of iterations"
    ImGuiContext& g = *GImGui;
    while (g.CurrentWindowStack.Size > 0)
    {
#ifdef IMGUI_HAS_TABLE
        while (g.CurrentTable && (g.CurrentTable->OuterWindow == g.CurrentWindow || g.CurrentTable->InnerWindow == g.CurrentWindow))
        {
            if (log_callback) log_callback(user_data, "Recovered from missing EndTable() in '%s'", g.CurrentTable->OuterWindow->Name);
            EndTable();
        }
#endif
        ImGuiWindow* window = g.CurrentWindow;
        IM_ASSERT(window != NULL);
        while (g.CurrentTabBar != NULL) //-V1044
        {
            if (log_callback) log_callback(user_data, "Recovered from missing EndTabBar() in '%s'", window->Name);
            EndTabBar();
        }
        while (window->DC.TreeDepth > 0)
        {
            if (log_callback) log_callback(user_data, "Recovered from missing TreePop() in '%s'", window->Name);
            TreePop();
        }
        while (g.GroupStack.Size > window->DC.StackSizesOnBegin.SizeOfGroupStack)
        {
            if (log_callback) log_callback(user_data, "Recovered from missing EndGroup() in '%s'", window->Name);
            EndGroup();
        }
        while (window->IDStack.Size > 1)
        {
            if (log_callback) log_callback(user_data, "Recovered from missing PopID() in '%s'", window->Name);
            PopID();
        }
        while (g.ColorStack.Size > window->DC.StackSizesOnBegin.SizeOfColorStack)
        {
            if (log_callback) log_callback(user_data, "Recovered from missing PopStyleColor() in '%s' for ImGuiCol_%s", window->Name, GetStyleColorName(g.ColorStack.back().Col));
            PopStyleColor();
        }
        while (g.StyleVarStack.Size > window->DC.StackSizesOnBegin.SizeOfStyleVarStack)
        {
            if (log_callback) log_callback(user_data, "Recovered from missing PopStyleVar() in '%s'", window->Name);
            PopStyleVar();
        }
        while (g.FocusScopeStack.Size > window->DC.StackSizesOnBegin.SizeOfFocusScopeStack)
        {
            if (log_callback) log_callback(user_data, "Recovered from missing PopFocusScope() in '%s'", window->Name);
            PopFocusScope();
        }
        if (g.CurrentWindowStack.Size == 1)
        {
            IM_ASSERT(g.CurrentWindow->IsFallbackWindow);
            break;
        }
        IM_ASSERT(window == g.CurrentWindow);
        if (window->Flags & ImGuiWindowFlags_ChildWindow)
        {
            if (log_callback) log_callback(user_data, "Recovered from missing EndChild() for '%s'", window->Name);
            EndChild();
        }
        else
        {
            if (log_callback) log_callback(user_data, "Recovered from missing End() for '%s'", window->Name);
            End();
        }
    }
}

// Save current stack sizes for later compare
void ImGuiStackSizes::SetToCurrentState()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    SizeOfIDStack = (short)window->IDStack.Size;
    SizeOfColorStack = (short)g.ColorStack.Size;
    SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
    SizeOfFontStack = (short)g.FontStack.Size;
    SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
    SizeOfGroupStack = (short)g.GroupStack.Size;
    SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
}

// Compare to detect usage errors
void ImGuiStackSizes::CompareWithCurrentState()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_UNUSED(window);

    // Window stacks
    // NOT checking: DC.ItemWidth, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
    IM_ASSERT(SizeOfIDStack         == window->IDStack.Size     && "PushID/PopID or TreeNode/TreePop Mismatch!");

    // Global stacks
    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
    IM_ASSERT(SizeOfGroupStack      == g.GroupStack.Size        && "BeginGroup/EndGroup Mismatch!");
    IM_ASSERT(SizeOfBeginPopupStack == g.BeginPopupStack.Size   && "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!");
    IM_ASSERT(SizeOfColorStack      >= g.ColorStack.Size        && "PushStyleColor/PopStyleColor Mismatch!");
    IM_ASSERT(SizeOfStyleVarStack   >= g.StyleVarStack.Size     && "PushStyleVar/PopStyleVar Mismatch!");
    IM_ASSERT(SizeOfFontStack       >= g.FontStack.Size         && "PushFont/PopFont Mismatch!");
    IM_ASSERT(SizeOfFocusScopeStack == g.FocusScopeStack.Size   && "PushFocusScope/PopFocusScope Mismatch!");
}


//-----------------------------------------------------------------------------
// [SECTION] LAYOUT
//-----------------------------------------------------------------------------
// - ItemSize()
// - ItemAdd()
// - SameLine()
// - GetCursorScreenPos()
// - SetCursorScreenPos()
// - GetCursorPos(), GetCursorPosX(), GetCursorPosY()
// - SetCursorPos(), SetCursorPosX(), SetCursorPosY()
// - GetCursorStartPos()
// - Indent()
// - Unindent()
// - SetNextItemWidth()
// - PushItemWidth()
// - PushMultiItemsWidths()
// - PopItemWidth()
// - CalcItemWidth()
// - CalcItemSize()
// - GetTextLineHeight()
// - GetTextLineHeightWithSpacing()
// - GetFrameHeight()
// - GetFrameHeightWithSpacing()
// - GetContentRegionMax()
// - GetContentRegionMaxAbs() [Internal]
// - GetContentRegionAvail(),
// - GetWindowContentRegionMin(), GetWindowContentRegionMax()
// - GetWindowContentRegionWidth()
// - BeginGroup()
// - EndGroup()
// Also see in imgui_widgets: tab bars, columns.
//-----------------------------------------------------------------------------

// Advance cursor given item size for layout.
// Register minimum needed size so it can extend the bounding box used for auto-fit calculation.
// See comments in ItemAdd() about how/why the size provided to ItemSize() vs ItemAdd() may often different.
void ImGui::ItemSize(const ImVec2& size, float text_baseline_y)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    // We increase the height in this function to accommodate for baseline offset.
    // In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
    // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
    const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;
    const float line_height = ImMax(window->DC.CurrLineSize.y, size.y + offset_to_match_baseline_y);

    // Always align ourselves on pixel boundaries
    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y;
    window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);    // Next line
    window->DC.CursorPos.y = IM_FLOOR(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y);        // Next line
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

    window->DC.PrevLineSize.y = line_height;
    window->DC.CurrLineSize.y = 0.0f;
    window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
    window->DC.CurrLineTextBaseOffset = 0.0f;

    // Horizontal layout mode
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
        SameLine();
}

void ImGui::ItemSize(const ImRect& bb, float text_baseline_y)
{
    ItemSize(bb.GetSize(), text_baseline_y);
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and provide a larger region to ItemAdd() which is used drawing/interaction.
bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg, ImGuiItemAddFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (id != 0)
    {
        // Navigation processing runs prior to clipping early-out
        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
        //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
        //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
        //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
        // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
        // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
        window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
        if (g.NavId == id || g.NavAnyRequest)
            if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
                if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
                    NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);

        // [DEBUG] Item Picker tool, when enabling the "extended" version we perform the check in ItemAdd()
#ifdef IMGUI_DEBUG_TOOL_ITEM_PICKER_EX
        if (id == g.DebugItemPickerBreakId)
        {
            IM_DEBUG_BREAK();
            g.DebugItemPickerBreakId = 0;
        }
#endif
    }

    // Equivalent to calling SetLastItemData()
    window->DC.LastItemId = id;
    window->DC.LastItemRect = bb;
    window->DC.LastItemStatusFlags = ImGuiItemStatusFlags_None;
    g.NextItemData.Flags = ImGuiNextItemDataFlags_None;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    if (id != 0)
        IMGUI_TEST_ENGINE_ITEM_ADD(nav_bb_arg ? *nav_bb_arg : bb, id);
#endif

    // Clipping test
    const bool is_clipped = IsClippedEx(bb, id, false);
    if (is_clipped)
        return false;
    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]

    // Tab stop handling (previously was using internal ItemFocusable() api)
    // FIXME-NAV: We would now want to move this above the clipping test, but this would require being able to scroll and currently this would mean an extra frame. (#4079, #343)
    if (flags & ImGuiItemAddFlags_Focusable)
        ItemFocusable(window, id);

    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
    if (IsMouseHoveringRect(bb.Min, bb.Max))
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;
    return true;
}

// Gets back to previous line and continue with horizontal layout
//      offset_from_start_x == 0 : follow right after previous item
//      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
//      spacing_w < 0            : use default spacing if pos_x == 0, no spacing if pos_x != 0
//      spacing_w >= 0           : enforce spacing amount
void ImGui::SameLine(float offset_from_start_x, float spacing_w)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    if (offset_from_start_x != 0.0f)
    {
        if (spacing_w < 0.0f) spacing_w = 0.0f;
        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    else
    {
        if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;
        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    window->DC.CurrLineSize = window->DC.PrevLineSize;
    window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
}

ImVec2 ImGui::GetCursorScreenPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos;
}

void ImGui::SetCursorScreenPos(const ImVec2& pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
ImVec2 ImGui::GetCursorPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos - window->Pos + window->Scroll;
}

float ImGui::GetCursorPosX()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float ImGui::GetCursorPosY()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void ImGui::SetCursorPos(const ImVec2& local_pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

void ImGui::SetCursorPosX(float x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
}

void ImGui::SetCursorPosY(float y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
}

ImVec2 ImGui::GetCursorStartPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorStartPos - window->Pos;
}

void ImGui::Indent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void ImGui::Unindent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

// Affect large frame+labels widgets only.
void ImGui::SetNextItemWidth(float item_width)
{
    ImGuiContext& g = *GImGui;
    g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasWidth;
    g.NextItemData.Width = item_width;
}

// FIXME: Remove the == 0.0f behavior?
void ImGui::PushItemWidth(float item_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth); // Backup current width
    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
    g.NextItemData.Flags &= ~ImGuiNextItemDataFlags_HasWidth;
}

void ImGui::PushMultiItemsWidths(int components, float w_full)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const ImGuiStyle& style = g.Style;
    const float w_item_one  = ImMax(1.0f, IM_FLOOR((w_full - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));
    const float w_item_last = ImMax(1.0f, IM_FLOOR(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));
    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth); // Backup current width
    window->DC.ItemWidthStack.push_back(w_item_last);
    for (int i = 0; i < components - 2; i++)
        window->DC.ItemWidthStack.push_back(w_item_one);
    window->DC.ItemWidth = (components == 1) ? w_item_last : w_item_one;
    g.NextItemData.Flags &= ~ImGuiNextItemDataFlags_HasWidth;
}

void ImGui::PopItemWidth()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidth = window->DC.ItemWidthStack.back();
    window->DC.ItemWidthStack.pop_back();
}

// Calculate default item width given value passed to PushItemWidth() or SetNextItemWidth().
// The SetNextItemWidth() data is generally cleared/consumed by ItemAdd() or NextItemData.ClearFlags()
float ImGui::CalcItemWidth()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    float w;
    if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasWidth)
        w = g.NextItemData.Width;
    else
        w = window->DC.ItemWidth;
    if (w < 0.0f)
    {
        float region_max_x = GetContentRegionMaxAbs().x;
        w = ImMax(1.0f, region_max_x - window->DC.CursorPos.x + w);
    }
    w = IM_FLOOR(w);
    return w;
}

// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == CalcItemWidth().
// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.
// Note that only CalcItemWidth() is publicly exposed.
// The 4.0f here may be changed to match CalcItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)
ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_w, float default_h)
{
    ImGuiWindow* window = GImGui->CurrentWindow;

    ImVec2 region_max;
    if (size.x < 0.0f || size.y < 0.0f)
        region_max = GetContentRegionMaxAbs();

    if (size.x == 0.0f)
        size.x = default_w;
    else if (size.x < 0.0f)
        size.x = ImMax(4.0f, region_max.x - window->DC.CursorPos.x + size.x);

    if (size.y == 0.0f)
        size.y = default_h;
    else if (size.y < 0.0f)
        size.y = ImMax(4.0f, region_max.y - window->DC.CursorPos.y + size.y);

    return size;
}

float ImGui::GetTextLineHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize;
}

float ImGui::GetTextLineHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.ItemSpacing.y;
}

float ImGui::GetFrameHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float ImGui::GetFrameHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

// FIXME: All the Contents Region function are messy or misleading. WE WILL AIM TO OBSOLETE ALL OF THEM WITH A NEW "WORK RECT" API. Thanks for your patience!

// FIXME: This is in window space (not screen space!).
ImVec2 ImGui::GetContentRegionMax()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImVec2 mx = window->ContentRegionRect.Max - window->Pos;
    if (window->DC.CurrentColumns || g.CurrentTable)
        mx.x = window->WorkRect.Max.x - window->Pos.x;
    return mx;
}

// [Internal] Absolute coordinate. Saner. This is not exposed until we finishing refactoring work rect features.
ImVec2 ImGui::GetContentRegionMaxAbs()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImVec2 mx = window->ContentRegionRect.Max;
    if (window->DC.CurrentColumns || g.CurrentTable)
        mx.x = window->WorkRect.Max.x;
    return mx;
}

ImVec2 ImGui::GetContentRegionAvail()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return GetContentRegionMaxAbs() - window->DC.CursorPos;
}

// In window space (not screen space!)
ImVec2 ImGui::GetWindowContentRegionMin()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ContentRegionRect.Min - window->Pos;
}

ImVec2 ImGui::GetWindowContentRegionMax()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ContentRegionRect.Max - window->Pos;
}

float ImGui::GetWindowContentRegionWidth()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ContentRegionRect.GetWidth();
}

// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
// Groups are currently a mishmash of functionalities which should perhaps be clarified and separated.
void ImGui::BeginGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    g.GroupStack.resize(g.GroupStack.Size + 1);
    ImGuiGroupData& group_data = g.GroupStack.back();
    group_data.WindowID = window->ID;
    group_data.BackupCursorPos = window->DC.CursorPos;
    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
    group_data.BackupIndent = window->DC.Indent;
    group_data.BackupGroupOffset = window->DC.GroupOffset;
    group_data.BackupCurrLineSize = window->DC.CurrLineSize;
    group_data.BackupCurrLineTextBaseOffset = window->DC.CurrLineTextBaseOffset;
    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    group_data.BackupHoveredIdIsAlive = g.HoveredId != 0;
    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
    group_data.EmitItem = true;

    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
    window->DC.Indent = window->DC.GroupOffset;
    window->DC.CursorMaxPos = window->DC.CursorPos;
    window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
    if (g.LogEnabled)
        g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
}

void ImGui::EndGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(g.GroupStack.Size > 0); // Mismatched BeginGroup()/EndGroup() calls

    ImGuiGroupData& group_data = g.GroupStack.back();
    IM_ASSERT(group_data.WindowID == window->ID); // EndGroup() in wrong window?

    ImRect group_bb(group_data.BackupCursorPos, ImMax(window->DC.CursorMaxPos, group_data.BackupCursorPos));

    window->DC.CursorPos = group_data.BackupCursorPos;
    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
    window->DC.Indent = group_data.BackupIndent;
    window->DC.GroupOffset = group_data.BackupGroupOffset;
    window->DC.CurrLineSize = group_data.BackupCurrLineSize;
    window->DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset;
    if (g.LogEnabled)
        g.LogLinePosY = -FLT_MAX; // To enforce a carriage return

    if (!group_data.EmitItem)
    {
        g.GroupStack.pop_back();
        return;
    }

    window->DC.CurrLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
    ItemSize(group_bb.GetSize());
    ItemAdd(group_bb, 0);

    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
    // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
    // Also if you grep for LastItemId you'll notice it is only used in that context.
    // (The two tests not the same because ActiveIdIsAlive is an ID itself, in order to be able to handle ActiveId being overwritten during the frame.)
    const bool group_contains_curr_active_id = (group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId;
    const bool group_contains_prev_active_id = (group_data.BackupActiveIdPreviousFrameIsAlive == false) && (g.ActiveIdPreviousFrameIsAlive == true);
    if (group_contains_curr_active_id)
        window->DC.LastItemId = g.ActiveId;
    else if (group_contains_prev_active_id)
        window->DC.LastItemId = g.ActiveIdPreviousFrame;
    window->DC.LastItemRect = group_bb;

    // Forward Hovered flag
    const bool group_contains_curr_hovered_id = (group_data.BackupHoveredIdIsAlive == false) && g.HoveredId != 0;
    if (group_contains_curr_hovered_id)
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredWindow;

    // Forward Edited flag
    if (group_contains_curr_active_id && g.ActiveIdHasBeenEditedThisFrame)
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;

    // Forward Deactivated flag
    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDeactivated;
    if (group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame)
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Deactivated;

    g.GroupStack.pop_back();
    //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
}


//-----------------------------------------------------------------------------
// [SECTION] SCROLLING
//-----------------------------------------------------------------------------

// Helper to snap on edges when aiming at an item very close to the edge,
// So the difference between WindowPadding and ItemSpacing will be in the visible area after scrolling.
// When we refactor the scrolling API this may be configurable with a flag?
// Note that the effect for this won't be visible on X axis with default Style settings as WindowPadding.x == ItemSpacing.x by default.
static float CalcScrollEdgeSnap(float target, float snap_min, float snap_max, float snap_threshold, float center_ratio)
{
    if (target <= snap_min + snap_threshold)
        return ImLerp(snap_min, target, center_ratio);
    if (target >= snap_max - snap_threshold)
        return ImLerp(target, snap_max, center_ratio);
    return target;
}

static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window)
{
    ImVec2 scroll = window->Scroll;
    if (window->ScrollTarget.x < FLT_MAX)
    {
        float decoration_total_width = window->ScrollbarSizes.x;
        float center_x_ratio = window->ScrollTargetCenterRatio.x;
        float scroll_target_x = window->ScrollTarget.x;
        if (window->ScrollTargetEdgeSnapDist.x > 0.0f)
        {
            float snap_x_min = 0.0f;
            float snap_x_max = window->ScrollMax.x + window->SizeFull.x - decoration_total_width;
            scroll_target_x = CalcScrollEdgeSnap(scroll_target_x, snap_x_min, snap_x_max, window->ScrollTargetEdgeSnapDist.x, center_x_ratio);
        }
        scroll.x = scroll_target_x - center_x_ratio * (window->SizeFull.x - decoration_total_width);
    }
    if (window->ScrollTarget.y < FLT_MAX)
    {
        float decoration_total_height = window->TitleBarHeight() + window->MenuBarHeight() + window->ScrollbarSizes.y;
        float center_y_ratio = window->ScrollTargetCenterRatio.y;
        float scroll_target_y = window->ScrollTarget.y;
        if (window->ScrollTargetEdgeSnapDist.y > 0.0f)
        {
            float snap_y_min = 0.0f;
            float snap_y_max = window->ScrollMax.y + window->SizeFull.y - decoration_total_height;
            scroll_target_y = CalcScrollEdgeSnap(scroll_target_y, snap_y_min, snap_y_max, window->ScrollTargetEdgeSnapDist.y, center_y_ratio);
        }
        scroll.y = scroll_target_y - center_y_ratio * (window->SizeFull.y - decoration_total_height);
    }
    scroll.x = IM_FLOOR(ImMax(scroll.x, 0.0f));
    scroll.y = IM_FLOOR(ImMax(scroll.y, 0.0f));
    if (!window->Collapsed && !window->SkipItems)
    {
        scroll.x = ImMin(scroll.x, window->ScrollMax.x);
        scroll.y = ImMin(scroll.y, window->ScrollMax.y);
    }
    return scroll;
}

// Scroll to keep newly navigated item fully into view
ImVec2 ImGui::ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& item_rect)
{
    ImGuiContext& g = *GImGui;
    ImRect window_rect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1));
    //GetForegroundDrawList(window)->AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]

    ImVec2 delta_scroll;
    if (!window_rect.Contains(item_rect))
    {
        if (window->ScrollbarX && item_rect.Min.x < window_rect.Min.x)
            SetScrollFromPosX(window, item_rect.Min.x - window->Pos.x - g.Style.ItemSpacing.x, 0.0f);
        else if (window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x)
            SetScrollFromPosX(window, item_rect.Max.x - window->Pos.x + g.Style.ItemSpacing.x, 1.0f);
        if (item_rect.Min.y < window_rect.Min.y)
            SetScrollFromPosY(window, item_rect.Min.y - window->Pos.y - g.Style.ItemSpacing.y, 0.0f);
        else if (item_rect.Max.y >= window_rect.Max.y)
            SetScrollFromPosY(window, item_rect.Max.y - window->Pos.y + g.Style.ItemSpacing.y, 1.0f);

        ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
        delta_scroll = next_scroll - window->Scroll;
    }

    // Also scroll parent window to keep us into view if necessary
    if (window->Flags & ImGuiWindowFlags_ChildWindow)
        delta_scroll += ScrollToBringRectIntoView(window->ParentWindow, ImRect(item_rect.Min - delta_scroll, item_rect.Max - delta_scroll));

    return delta_scroll;
}

float ImGui::GetScrollX()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Scroll.x;
}

float ImGui::GetScrollY()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Scroll.y;
}

float ImGui::GetScrollMaxX()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ScrollMax.x;
}

float ImGui::GetScrollMaxY()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ScrollMax.y;
}

void ImGui::SetScrollX(ImGuiWindow* window, float scroll_x)
{
    window->ScrollTarget.x = scroll_x;
    window->ScrollTargetCenterRatio.x = 0.0f;
    window->ScrollTargetEdgeSnapDist.x = 0.0f;
}

void ImGui::SetScrollY(ImGuiWindow* window, float scroll_y)
{
    window->ScrollTarget.y = scroll_y;
    window->ScrollTargetCenterRatio.y = 0.0f;
    window->ScrollTargetEdgeSnapDist.y = 0.0f;
}

void ImGui::SetScrollX(float scroll_x)
{
    ImGuiContext& g = *GImGui;
    SetScrollX(g.CurrentWindow, scroll_x);
}

void ImGui::SetScrollY(float scroll_y)
{
    ImGuiContext& g = *GImGui;
    SetScrollY(g.CurrentWindow, scroll_y);
}

// Note that a local position will vary depending on initial scroll value,
// This is a little bit confusing so bear with us:
//  - local_pos = (absolution_pos - window->Pos)
//  - So local_x/local_y are 0.0f for a position at the upper-left corner of a window,
//    and generally local_x/local_y are >(padding+decoration) && <(size-padding-decoration) when in the visible area.
//  - They mostly exists because of legacy API.
// Following the rules above, when trying to work with scrolling code, consider that:
//  - SetScrollFromPosY(0.0f) == SetScrollY(0.0f + scroll.y) == has no effect!
//  - SetScrollFromPosY(-scroll.y) == SetScrollY(-scroll.y + scroll.y) == SetScrollY(0.0f) == reset scroll. Of course writing SetScrollY(0.0f) directly then makes more sense
// We store a target position so centering and clamping can occur on the next frame when we are guaranteed to have a known window size
void ImGui::SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio)
{
    IM_ASSERT(center_x_ratio >= 0.0f && center_x_ratio <= 1.0f);
    window->ScrollTarget.x = IM_FLOOR(local_x + window->Scroll.x); // Convert local position to scroll offset
    window->ScrollTargetCenterRatio.x = center_x_ratio;
    window->ScrollTargetEdgeSnapDist.x = 0.0f;
}

void ImGui::SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio)
{
    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
    const float decoration_up_height = window->TitleBarHeight() + window->MenuBarHeight(); // FIXME: Would be nice to have a more standardized access to our scrollable/client rect;
    local_y -= decoration_up_height;
    window->ScrollTarget.y = IM_FLOOR(local_y + window->Scroll.y); // Convert local position to scroll offset
    window->ScrollTargetCenterRatio.y = center_y_ratio;
    window->ScrollTargetEdgeSnapDist.y = 0.0f;
}

void ImGui::SetScrollFromPosX(float local_x, float center_x_ratio)
{
    ImGuiContext& g = *GImGui;
    SetScrollFromPosX(g.CurrentWindow, local_x, center_x_ratio);
}

void ImGui::SetScrollFromPosY(float local_y, float center_y_ratio)
{
    ImGuiContext& g = *GImGui;
    SetScrollFromPosY(g.CurrentWindow, local_y, center_y_ratio);
}

// center_x_ratio: 0.0f left of last item, 0.5f horizontal center of last item, 1.0f right of last item.
void ImGui::SetScrollHereX(float center_x_ratio)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    float spacing_x = ImMax(window->WindowPadding.x, g.Style.ItemSpacing.x);
    float target_pos_x = ImLerp(window->DC.LastItemRect.Min.x - spacing_x, window->DC.LastItemRect.Max.x + spacing_x, center_x_ratio);
    SetScrollFromPosX(window, target_pos_x - window->Pos.x, center_x_ratio); // Convert from absolute to local pos

    // Tweak: snap on edges when aiming at an item very close to the edge
    window->ScrollTargetEdgeSnapDist.x = ImMax(0.0f, window->WindowPadding.x - spacing_x);
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
void ImGui::SetScrollHereY(float center_y_ratio)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    float spacing_y = ImMax(window->WindowPadding.y, g.Style.ItemSpacing.y);
    float target_pos_y = ImLerp(window->DC.CursorPosPrevLine.y - spacing_y, window->DC.CursorPosPrevLine.y + window->DC.PrevLineSize.y + spacing_y, center_y_ratio);
    SetScrollFromPosY(window, target_pos_y - window->Pos.y, center_y_ratio); // Convert from absolute to local pos

    // Tweak: snap on edges when aiming at an item very close to the edge
    window->ScrollTargetEdgeSnapDist.y = ImMax(0.0f, window->WindowPadding.y - spacing_y);
}

//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

void ImGui::BeginTooltip()
{
    BeginTooltipEx(ImGuiWindowFlags_None, ImGuiTooltipFlags_None);
}

void ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, ImGuiTooltipFlags tooltip_flags)
{
    ImGuiContext& g = *GImGui;

    if (g.DragDropWithinSource || g.DragDropWithinTarget)
    {
        // The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)
        // In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.
        // Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.
        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
        ImVec2 tooltip_pos = g.IO.MousePos + ImVec2(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);
        SetNextWindowPos(tooltip_pos);
        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);
        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
        tooltip_flags |= ImGuiTooltipFlags_OverridePreviousTooltip;
    }

    char window_name[16];
    ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", g.TooltipOverrideCount);
    if (tooltip_flags & ImGuiTooltipFlags_OverridePreviousTooltip)
        if (ImGuiWindow* window = FindWindowByName(window_name))
            if (window->Active)
            {
                // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
                window->Hidden = true;
                window->HiddenFramesCanSkipItems = 1; // FIXME: This may not be necessary?
                ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", ++g.TooltipOverrideCount);
            }
    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDocking;
    Begin(window_name, NULL, flags | extra_flags);
}

void ImGui::EndTooltip()
{
    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
    End();
}

void ImGui::SetTooltipV(const char* fmt, va_list args)
{
    BeginTooltipEx(0, ImGuiTooltipFlags_OverridePreviousTooltip);
    TextV(fmt, args);
    EndTooltip();
}

void ImGui::SetTooltip(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    SetTooltipV(fmt, args);
    va_end(args);
}

//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

// Supported flags: ImGuiPopupFlags_AnyPopupId, ImGuiPopupFlags_AnyPopupLevel
bool ImGui::IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    if (popup_flags & ImGuiPopupFlags_AnyPopupId)
    {
        // Return true if any popup is open at the current BeginPopup() level of the popup stack
        // This may be used to e.g. test for another popups already opened to handle popups priorities at the same level.
        IM_ASSERT(id == 0);
        if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
            return g.OpenPopupStack.Size > 0;
        else
            return g.OpenPopupStack.Size > g.BeginPopupStack.Size;
    }
    else
    {
        if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
        {
            // Return true if the popup is open anywhere in the popup stack
            for (int n = 0; n < g.OpenPopupStack.Size; n++)
                if (g.OpenPopupStack[n].PopupId == id)
                    return true;
            return false;
        }
        else
        {
            // Return true if the popup is open at the current BeginPopup() level of the popup stack (this is the most-common query)
            return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
        }
    }
}

bool ImGui::IsPopupOpen(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiID id = (popup_flags & ImGuiPopupFlags_AnyPopupId) ? 0 : g.CurrentWindow->GetID(str_id);
    if ((popup_flags & ImGuiPopupFlags_AnyPopupLevel) && id != 0)
        IM_ASSERT(0 && "Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel."); // But non-string version is legal and used internally
    return IsPopupOpen(id, popup_flags);
}

ImGuiWindow* ImGui::GetTopMostPopupModal()
{
    ImGuiContext& g = *GImGui;
    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
            if (popup->Flags & ImGuiWindowFlags_Modal)
                return popup;
    return NULL;
}

void ImGui::OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    OpenPopupEx(g.CurrentWindow->GetID(str_id), popup_flags);
}

void ImGui::OpenPopup(ImGuiID id, ImGuiPopupFlags popup_flags)
{
    OpenPopupEx(id, popup_flags);
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
void ImGui::OpenPopupEx(ImGuiID id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;
    const int current_stack_size = g.BeginPopupStack.Size;

    if (popup_flags & ImGuiPopupFlags_NoOpenOverExistingPopup)
        if (IsPopupOpen(0u, ImGuiPopupFlags_AnyPopupId))
            return;

    ImGuiPopupData popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
    popup_ref.PopupId = id;
    popup_ref.Window = NULL;
    popup_ref.SourceWindow = g.NavWindow;
    popup_ref.OpenFrameCount = g.FrameCount;
    popup_ref.OpenParentId = parent_window->IDStack.back();
    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

    IMGUI_DEBUG_LOG_POPUP("OpenPopupEx(0x%08X)\n", id);
    if (g.OpenPopupStack.Size < current_stack_size + 1)
    {
        g.OpenPopupStack.push_back(popup_ref);
    }
    else
    {
        // Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui
        // would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing
        // situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.
        if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)
        {
            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
        }
        else
        {
            // Close child popups if any, then flag popup for open/reopen
            ClosePopupToLevel(current_stack_size, false);
            g.OpenPopupStack.push_back(popup_ref);
        }

        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
        // This is equivalent to what ClosePopupToLevel() does.
        //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        //    FocusWindow(parent_window);
    }
}

// When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
// This function closes any popups that are over 'ref_window'.
void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.Size == 0)
        return;

    // Don't close our own child popup windows.
    int popup_count_to_keep = 0;
    if (ref_window)
    {
        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
        {
            ImGuiPopupData& popup = g.OpenPopupStack[popup_count_to_keep];
            if (!popup.Window)
                continue;
            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
                continue;

            // Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
            // - With this stack of window, clicking/focusing Popup1 will close Popup2 and Popup3:
            //     Window -> Popup1 -> Popup2 -> Popup3
            // - Each popups may contain child windows, which is why we compare ->RootWindowDockTree!
            //     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
            bool ref_window_is_descendent_of_popup = false;
            for (int n = popup_count_to_keep; n < g.OpenPopupStack.Size; n++)
                if (ImGuiWindow* popup_window = g.OpenPopupStack[n].Window)
                    if (popup_window->RootWindowDockTree == ref_window->RootWindowDockTree)
                    {
                        ref_window_is_descendent_of_popup = true;
                        break;
                    }
            if (!ref_window_is_descendent_of_popup)
                break;
        }
    }
    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
    {
        IMGUI_DEBUG_LOG_POPUP("ClosePopupsOverWindow(\"%s\") -> ClosePopupToLevel(%d)\n", ref_window->Name, popup_count_to_keep);
        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
    }
}

void ImGui::ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)
{
    ImGuiContext& g = *GImGui;
    IMGUI_DEBUG_LOG_POPUP("ClosePopupToLevel(%d), restore_focus_to_window_under_popup=%d\n", remaining, restore_focus_to_window_under_popup);
    IM_ASSERT(remaining >= 0 && remaining < g.OpenPopupStack.Size);

    // Trim open popup stack
    ImGuiWindow* focus_window = g.OpenPopupStack[remaining].SourceWindow;
    ImGuiWindow* popup_window = g.OpenPopupStack[remaining].Window;
    g.OpenPopupStack.resize(remaining);

    if (restore_focus_to_window_under_popup)
    {
        if (focus_window && !focus_window->WasActive && popup_window)
        {
            // Fallback
            FocusTopMostWindowUnderOne(popup_window, NULL);
        }
        else
        {
            if (g.NavLayer == ImGuiNavLayer_Main && focus_window)
                focus_window = NavRestoreLastChildNavWindow(focus_window);
            FocusWindow(focus_window);
        }
    }
}

// Close the popup we have begin-ed into.
void ImGui::CloseCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    int popup_idx = g.BeginPopupStack.Size - 1;
    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
        return;

    // Closing a menu closes its top-most parent popup (unless a modal)
    while (popup_idx > 0)
    {
        ImGuiWindow* popup_window = g.OpenPopupStack[popup_idx].Window;
        ImGuiWindow* parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;
        bool close_parent = false;
        if (popup_window && (popup_window->Flags & ImGuiWindowFlags_ChildMenu))
            if (parent_popup_window == NULL || !(parent_popup_window->Flags & ImGuiWindowFlags_Modal))
                close_parent = true;
        if (!close_parent)
            break;
        popup_idx--;
    }
    IMGUI_DEBUG_LOG_POPUP("CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx);
    ClosePopupToLevel(popup_idx, true);

    // A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
    // To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
    // Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
    if (ImGuiWindow* window = g.NavWindow)
        window->DC.NavHideHighlightOneFrame = true;
}

// Attention! BeginPopup() adds default flags which BeginPopupEx()!
bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (!IsPopupOpen(id, ImGuiPopupFlags_None))
    {
        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
        return false;
    }

    char name[20];
    if (flags & ImGuiWindowFlags_ChildMenu)
        ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth
    else
        ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame

    flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoDocking;
    bool is_open = Begin(name, NULL, flags);
    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
        EndPopup();

    return is_open;
}

bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance
    {
        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
        return false;
    }
    flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
    return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags);
}

// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by Dear ImGui (and manipulated with e.g. OpenPopup) so the actual value of *p_open is meaningless here.
bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const ImGuiID id = window->GetID(name);
    if (!IsPopupOpen(id, ImGuiPopupFlags_None))
    {
        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
        return false;
    }

    // Center modal windows by default for increased visibility
    // (this won't really last as settings will kick in, and is mostly for backward compatibility. user may do the same themselves)
    // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) == 0)
    {
        const ImGuiViewport* viewport = window->WasActive ? window->Viewport : GetMainViewport(); // FIXME-VIEWPORT: What may be our reference viewport?
        SetNextWindowPos(viewport->GetCenter(), ImGuiCond_FirstUseEver, ImVec2(0.5f, 0.5f));
    }

    flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking;
    const bool is_open = Begin(name, p_open, flags);
    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    {
        EndPopup();
        if (is_open)
            ClosePopupToLevel(g.BeginPopupStack.Size, true);
        return false;
    }
    return is_open;
}

void ImGui::EndPopup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(window->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
    IM_ASSERT(g.BeginPopupStack.Size > 0);

    // Make all menus and popups wrap around for now, may need to expose that policy.
    if (g.NavWindow == window)
        NavMoveRequestTryWrapping(window, ImGuiNavMoveFlags_LoopY);

    // Child-popups don't need to be laid out
    IM_ASSERT(g.WithinEndChild == false);
    if (window->Flags & ImGuiWindowFlags_ChildWindow)
        g.WithinEndChild = true;
    End();
    g.WithinEndChild = false;
}

// Helper to open a popup if mouse button is released over the item
// - This is essentially the same as BeginPopupContextItem() but without the trailing BeginPopup()
void ImGui::OpenPopupOnItemClick(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    {
        ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
        IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
        OpenPopupEx(id, popup_flags);
    }
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// - To create a popup associated to the last item, you generally want to pass a NULL value to str_id.
// - To create a popup with a specific identifier, pass it in str_id.
//    - This is useful when using using BeginPopupContextItem() on an item which doesn't have an identifier, e.g. a Text() call.
//    - This is useful when multiple code locations may want to manipulate/open the same popup, given an explicit id.
// - You may want to handle the whole on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
//   This is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       OpenPopupOnItemClick(str_id);
//       return BeginPopup(id);
//   Which is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
//           OpenPopup(id);
//       return BeginPopup(id);
//   The main difference being that this is tweaked to avoid computing the ID twice.
bool ImGui::BeginPopupContextItem(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    if (window->SkipItems)
        return false;
    ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        OpenPopupEx(id, popup_flags);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextWindow(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    if (!str_id)
        str_id = "window_context";
    ImGuiID id = window->GetID(str_id);
    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        if (!(popup_flags & ImGuiPopupFlags_NoOpenOverItems) || !IsAnyItemHovered())
            OpenPopupEx(id, popup_flags);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextVoid(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    if (!str_id)
        str_id = "void_context";
    ImGuiID id = window->GetID(str_id);
    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
        if (GetTopMostPopupModal() == NULL)
            OpenPopupEx(id, popup_flags);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
// (r_outer is usually equivalent to the viewport rectangle minus padding, but when multi-viewports are enabled and monitor
//  information are available, it may represent the entire platform monitor from the frame of reference of the current viewport.
//  this allows us to have tooltips/popups displayed out of the parent viewport.)
ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)
{
    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
    //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
    //GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

    // Combo Box policy (we want a connecting edge)
    if (policy == ImGuiPopupPositionPolicy_ComboBox)
    {
        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
        {
            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
            if (n != -1 && dir == *last_dir) // Already tried this direction?
                continue;
            ImVec2 pos;
            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)
            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
            if (!r_outer.Contains(ImRect(pos, pos + size)))
                continue;
            *last_dir = dir;
            return pos;
        }
    }

    // Tooltip and Default popup policy
    // (Always first try the direction we used on the last frame, if any)
    if (policy == ImGuiPopupPositionPolicy_Tooltip || policy == ImGuiPopupPositionPolicy_Default)
    {
        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
        {
            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
            if (n != -1 && dir == *last_dir) // Already tried this direction?
                continue;

            const float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
            const float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);

            // If there not enough room on one axis, there's no point in positioning on a side on this axis (e.g. when not enough width, use a top/bottom position to maximize available width)
            if (avail_w < size.x && (dir == ImGuiDir_Left || dir == ImGuiDir_Right))
                continue;
            if (avail_h < size.y && (dir == ImGuiDir_Up || dir == ImGuiDir_Down))
                continue;

            ImVec2 pos;
            pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
            pos.y = (dir == ImGuiDir_Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down) ? r_avoid.Max.y : base_pos_clamped.y;

            // Clamp top-left corner of popup
            pos.x = ImMax(pos.x, r_outer.Min.x);
            pos.y = ImMax(pos.y, r_outer.Min.y);

            *last_dir = dir;
            return pos;
        }
    }

    // Fallback when not enough room:
    *last_dir = ImGuiDir_None;

    // For tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
    if (policy == ImGuiPopupPositionPolicy_Tooltip)
        return ref_pos + ImVec2(2, 2);

    // Otherwise try to keep within display
    ImVec2 pos = ref_pos;
    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
    return pos;
}

// Note that this is used for popups, which can overlap the non work-area of individual viewports.
ImRect ImGui::GetWindowAllowedExtentRect(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ImRect r_screen;
    if (window->ViewportAllowPlatformMonitorExtend >= 0)
    {
        // Extent with be in the frame of reference of the given viewport (so Min is likely to be negative here)
        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[window->ViewportAllowPlatformMonitorExtend];
        r_screen.Min = monitor.WorkPos;
        r_screen.Max = monitor.WorkPos + monitor.WorkSize;
    }
    else
    {
        // Use the full viewport area (not work area) for popups
        r_screen = window->Viewport->GetMainRect();
    }
    ImVec2 padding = g.Style.DisplaySafeAreaPadding;
    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
    return r_screen;
}

ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    ImRect r_outer = GetWindowAllowedExtentRect(window);
    if (window->Flags & ImGuiWindowFlags_ChildMenu)
    {
        // Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
        ImGuiWindow* parent_window = window->ParentWindow;
        float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
        ImRect r_avoid;
        if (parent_window->DC.MenuBarAppending)
            r_avoid = ImRect(-FLT_MAX, parent_window->ClipRect.Min.y, FLT_MAX, parent_window->ClipRect.Max.y); // Avoid parent menu-bar. If we wanted multi-line menu-bar, we may instead want to have the calling window setup e.g. a NextWindowData.PosConstraintAvoidRect field
        else
            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Default);
    }
    if (window->Flags & ImGuiWindowFlags_Popup)
    {
        ImRect r_avoid = ImRect(window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Default);
    }
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Position tooltip (always follows mouse)
        float sc = g.Style.MouseCursorScale;
        ImVec2 ref_pos = NavCalcPreferredRefPos();
        ImRect r_avoid;
        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
        else
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
        return FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Tooltip);
    }
    IM_ASSERT(0);
    return window->Pos;
}

//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

// FIXME-NAV: The existence of SetNavID vs SetFocusID properly needs to be clarified/reworked.
void ImGui::SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindow != NULL);
    IM_ASSERT(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
    g.NavId = id;
    g.NavLayer = nav_layer;
    g.NavFocusScopeId = focus_scope_id;
    g.NavWindow->NavLastIds[nav_layer] = id;
    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
    //g.NavDisableHighlight = false;
    //g.NavDisableMouseHover = g.NavMousePosDirty = true;
}

void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(id != 0);

    // Assume that SetFocusID() is called in the context where its window->DC.NavLayerCurrent and window->DC.NavFocusScopeIdCurrent are valid.
    // Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
    if (g.NavWindow != window)
        g.NavInitRequest = false;
    g.NavWindow = window;
    g.NavId = id;
    g.NavLayer = nav_layer;
    g.NavFocusScopeId = window->DC.NavFocusScopeIdCurrent;
    window->NavLastIds[nav_layer] = id;
    if (window->DC.LastItemId == id)
        window->NavRectRel[nav_layer] = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);

    if (g.ActiveIdSource == ImGuiInputSource_Nav)
        g.NavDisableMouseHover = true;
    else
        g.NavDisableHighlight = true;
}

ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)
{
    if (ImFabs(dx) > ImFabs(dy))
        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
}

static float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)
{
    if (a1 < b0)
        return a1 - b0;
    if (b1 < a0)
        return a0 - b1;
    return 0.0f;
}

static void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)
{
    if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
    {
        r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);
        r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);
    }
    else
    {
        r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);
        r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);
    }
}

// Scoring function for gamepad/keyboard directional navigation. Based on https://gist.github.com/rygorous/6981057
static bool ImGui::NavScoreItem(ImGuiNavItemData* result, ImRect cand)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavLayer != window->DC.NavLayerCurrent)
        return false;

    const ImRect& curr = g.NavScoringRect; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
    g.NavScoringCount++;

    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
    if (window->ParentWindow == g.NavWindow)
    {
        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);
        if (!window->ClipRect.Overlaps(cand))
            return false;
        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
    }

    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
    // For example, this ensure that items in one column are not reached when moving vertically from items in another column.
    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);

    // Compute distance between boxes
    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
    if (dby != 0.0f && dbx != 0.0f)
        dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
    float dist_box = ImFabs(dbx) + ImFabs(dby);

    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
    ImGuiDir quadrant;
    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
    if (dbx != 0.0f || dby != 0.0f)
    {
        // For non-overlapping boxes, use distance between boxes
        dax = dbx;
        day = dby;
        dist_axial = dist_box;
        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
    }
    else if (dcx != 0.0f || dcy != 0.0f)
    {
        // For overlapping boxes with different centers, use distance between centers
        dax = dcx;
        day = dcy;
        dist_axial = dist_center;
        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
    }
    else
    {
        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
        quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
    }

#if IMGUI_DEBUG_NAV_SCORING
    char buf[128];
    if (IsMouseHoveringRect(cand.Min, cand.Max))
    {
        ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
        ImDrawList* draw_list = GetForegroundDrawList(window);
        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255,200,0,100));
        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));
        draw_list->AddRectFilled(cand.Max - ImVec2(4, 4), cand.Max + CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40,0,0,150));
        draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);
    }
    else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
    {
        if (IsKeyPressedMap(ImGuiKey_C)) { g.NavMoveDirLast = (ImGuiDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[ImGuiKey_C]] = 0.01f; }
        if (quadrant == g.NavMoveDir)
        {
            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
            ImDrawList* draw_list = GetForegroundDrawList(window);
            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
            draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);
        }
    }
#endif

    // Is it in the quadrant we're interesting in moving to?
    bool new_best = false;
    if (quadrant == g.NavMoveDir)
    {
        // Does it beat the current best candidate?
        if (dist_box < result->DistBox)
        {
            result->DistBox = dist_box;
            result->DistCenter = dist_center;
            return true;
        }
        if (dist_box == result->DistBox)
        {
            // Try using distance between center points to break ties
            if (dist_center < result->DistCenter)
            {
                result->DistCenter = dist_center;
                new_best = true;
            }
            else if (dist_center == result->DistCenter)
            {
                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
                if (((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
                    new_best = true;
            }
        }
    }

    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
        if (g.NavLayer == ImGuiNavLayer_Menu && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
            if ((g.NavMoveDir == ImGuiDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiDir_Down && day > 0.0f))
            {
                result->DistAxial = dist_axial;
                new_best = true;
            }

    return new_best;
}

static void ImGui::NavApplyItemToResult(ImGuiNavItemData* result, ImGuiWindow* window, ImGuiID id, const ImRect& nav_bb_rel)
{
    result->Window = window;
    result->ID = id;
    result->FocusScopeId = window->DC.NavFocusScopeIdCurrent;
    result->RectRel = nav_bb_rel;
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
static void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    //if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.
    //    return;

    const ImGuiItemFlags item_flags = g.CurrentItemFlags;
    const ImRect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);

    // Process Init Request
    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)
    {
        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)
        {
            g.NavInitResultId = id;
            g.NavInitResultRectRel = nav_bb_rel;
        }
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus))
        {
            g.NavInitRequest = false; // Found a match, clear request
            NavUpdateAnyRequestFlag();
        }
    }

    // Process Move Request (scoring for navigation)
    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)
    if ((g.NavId != id || (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & (ImGuiItemFlags_Disabled | ImGuiItemFlags_NoNav)))
    {
        ImGuiNavItemData* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
#if IMGUI_DEBUG_NAV_SCORING
        // [DEBUG] Score all items in NavWindow at all times
        if (!g.NavMoveRequest)
            g.NavMoveDir = g.NavMoveDirLast;
        bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;
#else
        bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);
#endif
        if (new_best)
            NavApplyItemToResult(result, window, id, nav_bb_rel);

        // Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
        const float VISIBLE_RATIO = 0.70f;
        if ((g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
            if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
                if (NavScoreItem(&g.NavMoveResultLocalVisibleSet, nav_bb))
                    NavApplyItemToResult(&g.NavMoveResultLocalVisibleSet, window, id, nav_bb_rel);
    }

    // Update window-relative bounding box of navigated item
    if (g.NavId == id)
    {
        g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.
        g.NavLayer = window->DC.NavLayerCurrent;
        g.NavFocusScopeId = window->DC.NavFocusScopeIdCurrent;
        g.NavIdIsAlive = true;
        window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)
    }
}

bool ImGui::NavMoveRequestButNoResultYet()
{
    ImGuiContext& g = *GImGui;
    return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

void ImGui::NavMoveRequestCancel()
{
    ImGuiContext& g = *GImGui;
    g.NavMoveRequest = false;
    NavUpdateAnyRequestFlag();
}

void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_None);
    NavMoveRequestCancel();
    g.NavMoveDir = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
    g.NavMoveRequestFlags = move_flags;
    g.NavWindow->NavRectRel[g.NavLayer] = bb_rel;
}

void ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;

    // Navigation wrap-around logic is delayed to the end of the frame because this operation is only valid after entire
    // popup is assembled and in case of appended popups it is not clear which EndPopup() call is final.
    g.NavWrapRequestWindow = window;
    g.NavWrapRequestFlags = move_flags;
}

// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
// This way we could find the last focused window among our children. It would be much less confusing this way?
static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window)
{
    ImGuiWindow* parent = nav_window;
    while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
        parent = parent->ParentWindow;
    if (parent && parent != nav_window)
        parent->NavLastChildNavWindow = nav_window;
}

// Restore the last focused child.
// Call when we are expected to land on the Main Layer (0) after FocusWindow()
static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)
{
    if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
        return window->NavLastChildNavWindow;
    if (window->DockNodeAsHost && window->DockNodeAsHost->TabBar)
        if (ImGuiTabItem* tab = TabBarFindMostRecentlySelectedTabForActiveWindow(window->DockNodeAsHost->TabBar))
            return tab->Window;
    return window;
}

void ImGui::NavRestoreLayer(ImGuiNavLayer layer)
{
    ImGuiContext& g = *GImGui;
    if (layer == ImGuiNavLayer_Main)
        g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow);
    ImGuiWindow* window = g.NavWindow;
    if (window->NavLastIds[layer] != 0)
    {
        SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = g.NavMousePosDirty = true;
    }
    else
    {
        g.NavLayer = layer;
        NavInitWindow(window, true);
    }
}

static inline void ImGui::NavUpdateAnyRequestFlag()
{
    ImGuiContext& g = *GImGui;
    g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
    if (g.NavAnyRequest)
        IM_ASSERT(g.NavWindow != NULL);
}

// This needs to be called before we submit any widget (aka in or before Begin)
void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
{
    // FIXME: ChildWindow test here is wrong for docking
    ImGuiContext& g = *GImGui;
    IM_ASSERT(window == g.NavWindow);

    if (window->Flags & ImGuiWindowFlags_NoNavInputs)
    {
        g.NavId = g.NavFocusScopeId = 0;
        return;
    }

    bool init_for_nav = false;
    if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
        init_for_nav = true;
    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
    if (init_for_nav)
    {
        SetNavID(0, g.NavLayer, 0, ImRect());
        g.NavInitRequest = true;
        g.NavInitRequestFromMove = false;
        g.NavInitResultId = 0;
        g.NavInitResultRectRel = ImRect();
        NavUpdateAnyRequestFlag();
    }
    else
    {
        g.NavId = window->NavLastIds[0];
        g.NavFocusScopeId = 0;
    }
}

static ImVec2 ImGui::NavCalcPreferredRefPos()
{
    ImGuiContext& g = *GImGui;
    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)
    {
        // Mouse (we need a fallback in case the mouse becomes invalid after being used)
        if (IsMousePosValid(&g.IO.MousePos))
            return g.IO.MousePos;
        return g.LastValidMousePos;
    }
    else
    {
        // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.
        const ImRect& rect_rel = g.NavWindow->NavRectRel[g.NavLayer];
        ImVec2 pos = g.NavWindow->Pos + ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));
        ImGuiViewport* viewport = g.NavWindow->Viewport;
        return ImFloor(ImClamp(pos, viewport->Pos, viewport->Pos + viewport->Size)); // ImFloor() is important because non-integer mouse position application in backend might be lossy and result in undesirable non-zero delta.
    }
}

float ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)
{
    ImGuiContext& g = *GImGui;
    if (mode == ImGuiInputReadMode_Down)
        return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)

    const float t = g.IO.NavInputsDownDuration[n];
    if (t < 0.0f && mode == ImGuiInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.
        return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);
    if (t < 0.0f)
        return 0.0f;
    if (mode == ImGuiInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.
        return (t == 0.0f) ? 1.0f : 0.0f;
    if (mode == ImGuiInputReadMode_Repeat)
        return (float)CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay * 0.72f, g.IO.KeyRepeatRate * 0.80f);
    if (mode == ImGuiInputReadMode_RepeatSlow)
        return (float)CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay * 1.25f, g.IO.KeyRepeatRate * 2.00f);
    if (mode == ImGuiInputReadMode_RepeatFast)
        return (float)CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay * 0.72f, g.IO.KeyRepeatRate * 0.30f);
    return 0.0f;
}

ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)
{
    ImVec2 delta(0.0f, 0.0f);
    if (dir_sources & ImGuiNavDirSourceFlags_Keyboard)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_KeyRight_, mode)   - GetNavInputAmount(ImGuiNavInput_KeyLeft_,   mode), GetNavInputAmount(ImGuiNavInput_KeyDown_,   mode) - GetNavInputAmount(ImGuiNavInput_KeyUp_,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadDPad)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_DpadRight, mode)   - GetNavInputAmount(ImGuiNavInput_DpadLeft,   mode), GetNavInputAmount(ImGuiNavInput_DpadDown,   mode) - GetNavInputAmount(ImGuiNavInput_DpadUp,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadLStick)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_LStickRight, mode) - GetNavInputAmount(ImGuiNavInput_LStickLeft, mode), GetNavInputAmount(ImGuiNavInput_LStickDown, mode) - GetNavInputAmount(ImGuiNavInput_LStickUp, mode));
    if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakSlow))
        delta *= slow_factor;
    if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakFast))
        delta *= fast_factor;
    return delta;
}

static void ImGui::NavUpdate()
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;

    io.WantSetMousePos = false;
    g.NavWrapRequestWindow = NULL;
    g.NavWrapRequestFlags = ImGuiNavMoveFlags_None;
#if 0
    if (g.NavScoringCount > 0) IMGUI_DEBUG_LOG("NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
#endif

    // Set input source as Gamepad when buttons are pressed (as some features differs when used with Gamepad vs Keyboard)
    // (do it before we map Keyboard input!)
    bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    if (nav_gamepad_active && g.NavInputSource != ImGuiInputSource_Gamepad)
    {
        if (io.NavInputs[ImGuiNavInput_Activate] > 0.0f || io.NavInputs[ImGuiNavInput_Input] > 0.0f || io.NavInputs[ImGuiNavInput_Cancel] > 0.0f || io.NavInputs[ImGuiNavInput_Menu] > 0.0f
            || io.NavInputs[ImGuiNavInput_DpadLeft] > 0.0f || io.NavInputs[ImGuiNavInput_DpadRight] > 0.0f || io.NavInputs[ImGuiNavInput_DpadUp] > 0.0f || io.NavInputs[ImGuiNavInput_DpadDown] > 0.0f)
            g.NavInputSource = ImGuiInputSource_Gamepad;
    }

    // Update Keyboard->Nav inputs mapping
    if (nav_keyboard_active)
    {
        #define NAV_MAP_KEY(_KEY, _NAV_INPUT)  do { if (IsKeyDown(io.KeyMap[_KEY])) { io.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_Keyboard; } } while (0)
        NAV_MAP_KEY(ImGuiKey_Space,     ImGuiNavInput_Activate );
        NAV_MAP_KEY(ImGuiKey_Enter,     ImGuiNavInput_Input    );
        NAV_MAP_KEY(ImGuiKey_Escape,    ImGuiNavInput_Cancel   );
        NAV_MAP_KEY(ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_ );
        NAV_MAP_KEY(ImGuiKey_RightArrow,ImGuiNavInput_KeyRight_);
        NAV_MAP_KEY(ImGuiKey_UpArrow,   ImGuiNavInput_KeyUp_   );
        NAV_MAP_KEY(ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_ );
        if (io.KeyCtrl)
            io.NavInputs[ImGuiNavInput_TweakSlow] = 1.0f;
        if (io.KeyShift)
            io.NavInputs[ImGuiNavInput_TweakFast] = 1.0f;

        // AltGR is normally Alt+Ctrl but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl)
        // But also even on keyboards without AltGR we don't want Alt+Ctrl to open menu anyway.
        if (io.KeyAlt && !io.KeyCtrl)
            io.NavInputs[ImGuiNavInput_KeyMenu_]  = 1.0f;

        // We automatically cancel toggling nav layer when any text has been typed while holding Alt. (See #370)
        if (io.KeyAlt && !io.KeyCtrl && g.NavWindowingToggleLayer && io.InputQueueCharacters.Size > 0)
            g.NavWindowingToggleLayer = false;

        #undef NAV_MAP_KEY
    }
    memcpy(io.NavInputsDownDurationPrev, io.NavInputsDownDuration, sizeof(io.NavInputsDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++)
        io.NavInputsDownDuration[i] = (io.NavInputs[i] > 0.0f) ? (io.NavInputsDownDuration[i] < 0.0f ? 0.0f : io.NavInputsDownDuration[i] + io.DeltaTime) : -1.0f;

    // Process navigation init request (select first/default focus)
    if (g.NavInitResultId != 0)
        NavUpdateInitResult();
    g.NavInitRequest = false;
    g.NavInitRequestFromMove = false;
    g.NavInitResultId = 0;
    g.NavJustMovedToId = 0;

    // Process navigation move request
    if (g.NavMoveRequest)
        NavUpdateMoveResult();

    // When a forwarded move request failed, we restore the highlight that we disabled during the forward frame
    if (g.NavMoveRequestForward == ImGuiNavForward_ForwardActive)
    {
        IM_ASSERT(g.NavMoveRequest);
        if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
            g.NavDisableHighlight = false;
        g.NavMoveRequestForward = ImGuiNavForward_None;
    }

    // Apply application mouse position movement, after we had a chance to process move request result.
    if (g.NavMousePosDirty && g.NavIdIsAlive)
    {
        // Set mouse position given our knowledge of the navigated item position from last frame
        if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
            if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
            {
                io.MousePos = io.MousePosPrev = NavCalcPreferredRefPos();
                io.WantSetMousePos = true;
            }
        g.NavMousePosDirty = false;
    }
    g.NavIdIsAlive = false;
    g.NavJustTabbedId = 0;
    IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);

    // Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0
    if (g.NavWindow)
        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main)
        g.NavWindow->NavLastChildNavWindow = NULL;

    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
    NavUpdateWindowing();

    // Set output flags for user application
    io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
    io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);

    // Process NavCancel input (to close a popup, get back to parent, clear focus)
    if (IsNavInputTest(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed))
    {
        IMGUI_DEBUG_LOG_NAV("[nav] ImGuiNavInput_Cancel\n");
        if (g.ActiveId != 0)
        {
            if (!IsActiveIdUsingNavInput(ImGuiNavInput_Cancel))
                ClearActiveID();
        }
        else if (g.NavLayer != ImGuiNavLayer_Main)
        {
            // Leave the "menu" layer
            NavRestoreLayer(ImGuiNavLayer_Main);
        }
        else if (g.NavWindow && g.NavWindow != g.NavWindow->RootWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
        {
            // Exit child window
            ImGuiWindow* child_window = g.NavWindow;
            ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
            IM_ASSERT(child_window->ChildId != 0);
            ImRect child_rect = child_window->Rect();
            FocusWindow(parent_window);
            SetNavID(child_window->ChildId, ImGuiNavLayer_Main, 0, ImRect(child_rect.Min - parent_window->Pos, child_rect.Max - parent_window->Pos));
        }
        else if (g.OpenPopupStack.Size > 0)
        {
            // Close open popup/menu
            if (!(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
                ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
        }
        else
        {
            // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
            if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
                g.NavWindow->NavLastIds[0] = 0;
            g.NavId = g.NavFocusScopeId = 0;
        }
    }

    // Process manual activation request
    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;
    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
    {
        bool activate_down = IsNavInputDown(ImGuiNavInput_Activate);
        bool activate_pressed = activate_down && IsNavInputTest(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed);
        if (g.ActiveId == 0 && activate_pressed)
            g.NavActivateId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
            g.NavActivateDownId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
            g.NavActivatePressedId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputTest(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed))
            g.NavInputId = g.NavId;
    }
    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        g.NavDisableHighlight = true;
    if (g.NavActivateId != 0)
        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
    g.NavMoveRequest = false;

    // Process programmatic activation request
    if (g.NavNextActivateId != 0)
        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;
    g.NavNextActivateId = 0;

    // Initiate directional inputs request
    if (g.NavMoveRequestForward == ImGuiNavForward_None)
    {
        g.NavMoveDir = ImGuiDir_None;
        g.NavMoveRequestFlags = ImGuiNavMoveFlags_None;
        if (g.NavWindow && !g.NavWindowingTarget && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        {
            const ImGuiInputReadMode read_mode = ImGuiInputReadMode_Repeat;
            if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && (IsNavInputTest(ImGuiNavInput_DpadLeft,  read_mode) || IsNavInputTest(ImGuiNavInput_KeyLeft_,  read_mode))) { g.NavMoveDir = ImGuiDir_Left; }
            if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && (IsNavInputTest(ImGuiNavInput_DpadRight, read_mode) || IsNavInputTest(ImGuiNavInput_KeyRight_, read_mode))) { g.NavMoveDir = ImGuiDir_Right; }
            if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && (IsNavInputTest(ImGuiNavInput_DpadUp,    read_mode) || IsNavInputTest(ImGuiNavInput_KeyUp_,    read_mode))) { g.NavMoveDir = ImGuiDir_Up; }
            if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && (IsNavInputTest(ImGuiNavInput_DpadDown,  read_mode) || IsNavInputTest(ImGuiNavInput_KeyDown_,  read_mode))) { g.NavMoveDir = ImGuiDir_Down; }
        }
        g.NavMoveClipDir = g.NavMoveDir;
    }
    else
    {
        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)
        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
        IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued);
        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
        g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;
    }

    // Update PageUp/PageDown/Home/End scroll
    // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
    float nav_scoring_rect_offset_y = 0.0f;
    if (nav_keyboard_active)
        nav_scoring_rect_offset_y = NavUpdatePageUpPageDown();

    // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
    if (g.NavMoveDir != ImGuiDir_None)
    {
        g.NavMoveRequest = true;
        g.NavMoveRequestKeyMods = io.KeyMods;
        g.NavMoveDirLast = g.NavMoveDir;
    }
    if (g.NavMoveRequest && g.NavId == 0)
    {
        IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", g.NavWindow->Name, g.NavLayer);
        g.NavInitRequest = g.NavInitRequestFromMove = true;
        // Reassigning with same value, we're being explicit here.
        g.NavInitResultId = 0;     // -V1048
        g.NavDisableHighlight = false;
    }
    NavUpdateAnyRequestFlag();

    // Scrolling
    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
    {
        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
        ImGuiWindow* window = g.NavWindow;
        const float scroll_speed = IM_ROUND(window->CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
        if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)
        {
            if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)
                SetScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
            if (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down)
                SetScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
        }

        // *Normal* Manual scroll with NavScrollXXX keys
        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
        ImVec2 scroll_dir = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f / 10.0f, 10.0f);
        if (scroll_dir.x != 0.0f && window->ScrollbarX)
            SetScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));
        if (scroll_dir.y != 0.0f)
            SetScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));
    }

    // Reset search results
    g.NavMoveResultLocal.Clear();
    g.NavMoveResultLocalVisibleSet.Clear();
    g.NavMoveResultOther.Clear();

    // When using gamepad, we project the reference nav bounding box into window visible area.
    // This is to allow resuming navigation inside the visible area after doing a large amount of scrolling, since with gamepad every movements are relative
    // (can't focus a visible object like we can with the mouse).
    if (g.NavMoveRequest && g.NavInputSource == ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer_Main)
    {
        ImGuiWindow* window = g.NavWindow;
        ImRect window_rect_rel(window->InnerRect.Min - window->Pos - ImVec2(1, 1), window->InnerRect.Max - window->Pos + ImVec2(1, 1));
        if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
        {
            IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: clamp NavRectRel\n");
            float pad = window->CalcFontSize() * 0.5f;
            window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item
            window->NavRectRel[g.NavLayer].ClipWithFull(window_rect_rel);
            g.NavId = g.NavFocusScopeId = 0;
        }
    }

    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
    ImRect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
    g.NavScoringRect = g.NavWindow ? ImRect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : ImRect(0, 0, 0, 0);
    g.NavScoringRect.TranslateY(nav_scoring_rect_offset_y);
    g.NavScoringRect.Min.x = ImMin(g.NavScoringRect.Min.x + 1.0f, g.NavScoringRect.Max.x);
    g.NavScoringRect.Max.x = g.NavScoringRect.Min.x;
    IM_ASSERT(!g.NavScoringRect.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().
    //GetForegroundDrawList()->AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
    g.NavScoringCount = 0;
#if IMGUI_DEBUG_NAV_RECTS
    if (g.NavWindow)
    {
        ImDrawList* draw_list = GetForegroundDrawList(g.NavWindow);
        if (1) { for (int layer = 0; layer < 2; layer++) draw_list->AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255,200,0,255)); } // [DEBUG]
        if (1) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
    }
#endif
}

static void ImGui::NavUpdateInitResult()
{
    // In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
    ImGuiContext& g = *GImGui;
    if (!g.NavWindow)
        return;

    // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
    // FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated during subsequent frame. Not a problem currently.
    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", g.NavInitResultId, g.NavLayer, g.NavWindow->Name);
    SetNavID(g.NavInitResultId, g.NavLayer, 0, g.NavInitResultRectRel);
    if (g.NavInitRequestFromMove)
    {
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = g.NavMousePosDirty = true;
    }
}

// Apply result from previous frame navigation directional move request
static void ImGui::NavUpdateMoveResult()
{
    ImGuiContext& g = *GImGui;
    if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
    {
        // In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
        if (g.NavId != 0)
        {
            g.NavDisableHighlight = false;
            g.NavDisableMouseHover = true;
        }
        return;
    }

    // Select which result to use
    ImGuiNavItemData* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;

    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
    if (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
        if (g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId)
            result = &g.NavMoveResultLocalVisibleSet;

    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
            result = &g.NavMoveResultOther;
    IM_ASSERT(g.NavWindow && result->Window);

    // Scroll to keep newly navigated item fully into view.
    if (g.NavLayer == ImGuiNavLayer_Main)
    {
        ImVec2 delta_scroll;
        if (g.NavMoveRequestFlags & ImGuiNavMoveFlags_ScrollToEdge)
        {
            float scroll_target = (g.NavMoveDir == ImGuiDir_Up) ? result->Window->ScrollMax.y : 0.0f;
            delta_scroll.y = result->Window->Scroll.y - scroll_target;
            SetScrollY(result->Window, scroll_target);
        }
        else
        {
            ImRect rect_abs = ImRect(result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos);
            delta_scroll = ScrollToBringRectIntoView(result->Window, rect_abs);
        }

        // Offset our result position so mouse position can be applied immediately after in NavUpdate()
        result->RectRel.TranslateX(-delta_scroll.x);
        result->RectRel.TranslateY(-delta_scroll.y);
    }

    ClearActiveID();
    g.NavWindow = result->Window;
    if (g.NavId != result->ID)
    {
        // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
        g.NavJustMovedToId = result->ID;
        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
        g.NavJustMovedToKeyMods = g.NavMoveRequestKeyMods;
    }
    IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
    g.NavDisableHighlight = false;
    g.NavDisableMouseHover = g.NavMousePosDirty = true;
}

// Handle PageUp/PageDown/Home/End keys
static float ImGui::NavUpdatePageUpPageDown()
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;

    if (g.NavMoveDir != ImGuiDir_None || g.NavWindow == NULL)
        return 0.0f;
    if ((g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != NULL || g.NavLayer != ImGuiNavLayer_Main)
        return 0.0f;

    ImGuiWindow* window = g.NavWindow;
    const bool page_up_held = IsKeyDown(io.KeyMap[ImGuiKey_PageUp]) && !IsActiveIdUsingKey(ImGuiKey_PageUp);
    const bool page_down_held = IsKeyDown(io.KeyMap[ImGuiKey_PageDown]) && !IsActiveIdUsingKey(ImGuiKey_PageDown);
    const bool home_pressed = IsKeyPressed(io.KeyMap[ImGuiKey_Home]) && !IsActiveIdUsingKey(ImGuiKey_Home);
    const bool end_pressed = IsKeyPressed(io.KeyMap[ImGuiKey_End]) && !IsActiveIdUsingKey(ImGuiKey_End);
    if (page_up_held != page_down_held || home_pressed != end_pressed) // If either (not both) are pressed
    {
        if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavHasScroll)
        {
            // Fallback manual-scroll when window has no navigable item
            if (IsKeyPressed(io.KeyMap[ImGuiKey_PageUp], true))
                SetScrollY(window, window->Scroll.y - window->InnerRect.GetHeight());
            else if (IsKeyPressed(io.KeyMap[ImGuiKey_PageDown], true))
                SetScrollY(window, window->Scroll.y + window->InnerRect.GetHeight());
            else if (home_pressed)
                SetScrollY(window, 0.0f);
            else if (end_pressed)
                SetScrollY(window, window->ScrollMax.y);
        }
        else
        {
            ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
            const float page_offset_y = ImMax(0.0f, window->InnerRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
            float nav_scoring_rect_offset_y = 0.0f;
            if (IsKeyPressed(io.KeyMap[ImGuiKey_PageUp], true))
            {
                nav_scoring_rect_offset_y = -page_offset_y;
                g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
                g.NavMoveClipDir = ImGuiDir_Up;
                g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
            }
            else if (IsKeyPressed(io.KeyMap[ImGuiKey_PageDown], true))
            {
                nav_scoring_rect_offset_y = +page_offset_y;
                g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
                g.NavMoveClipDir = ImGuiDir_Down;
                g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
            }
            else if (home_pressed)
            {
                // FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
                // Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdge flag, we don't scroll immediately to avoid scrolling happening before nav result.
                // Preserve current horizontal position if we have any.
                nav_rect_rel.Min.y = nav_rect_rel.Max.y = -window->Scroll.y;
                if (nav_rect_rel.IsInverted())
                    nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
                g.NavMoveDir = ImGuiDir_Down;
                g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdge;
            }
            else if (end_pressed)
            {
                nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ScrollMax.y + window->SizeFull.y - window->Scroll.y;
                if (nav_rect_rel.IsInverted())
                    nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
                g.NavMoveDir = ImGuiDir_Up;
                g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdge;
            }
            return nav_scoring_rect_offset_y;
        }
    }
    return 0.0f;
}

static void ImGui::NavEndFrame()
{
    ImGuiContext& g = *GImGui;

    // Show CTRL+TAB list window
    if (g.NavWindowingTarget != NULL)
        NavUpdateWindowingOverlay();

    // Perform wrap-around in menus
    ImGuiWindow* window = g.NavWrapRequestWindow;
    ImGuiNavMoveFlags move_flags = g.NavWrapRequestFlags;
    if (window != NULL && g.NavWindow == window && NavMoveRequestButNoResultYet() && g.NavMoveRequestForward == ImGuiNavForward_None && g.NavLayer == ImGuiNavLayer_Main)
    {
        IM_ASSERT(move_flags != 0); // No points calling this with no wrapping
        ImRect bb_rel = window->NavRectRel[0];

        ImGuiDir clip_dir = g.NavMoveDir;
        if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
        {
            bb_rel.Min.x = bb_rel.Max.x =
                ImMax(window->SizeFull.x, window->ContentSize.x + window->WindowPadding.x * 2.0f) - window->Scroll.x;
            if (move_flags & ImGuiNavMoveFlags_WrapX)
            {
                bb_rel.TranslateY(-bb_rel.GetHeight());
                clip_dir = ImGuiDir_Up;
            }
            NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
        }
        if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
        {
            bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;
            if (move_flags & ImGuiNavMoveFlags_WrapX)
            {
                bb_rel.TranslateY(+bb_rel.GetHeight());
                clip_dir = ImGuiDir_Down;
            }
            NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
        }
        if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
        {
            bb_rel.Min.y = bb_rel.Max.y =
                ImMax(window->SizeFull.y, window->ContentSize.y + window->WindowPadding.y * 2.0f) - window->Scroll.y;
            if (move_flags & ImGuiNavMoveFlags_WrapY)
            {
                bb_rel.TranslateX(-bb_rel.GetWidth());
                clip_dir = ImGuiDir_Left;
            }
            NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
        }
        if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
        {
            bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;
            if (move_flags & ImGuiNavMoveFlags_WrapY)
            {
                bb_rel.TranslateX(+bb_rel.GetWidth());
                clip_dir = ImGuiDir_Right;
            }
            NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
        }
    }
}

static int ImGui::FindWindowFocusIndex(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    IM_UNUSED(g);
    int order = window->FocusOrder;
    IM_ASSERT(g.WindowsFocusOrder[order] == window);
    return order;
}

static ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)
{
    ImGuiContext& g = *GImGui;
    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)
        if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
            return g.WindowsFocusOrder[i];
    return NULL;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget);
    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
        return;

    const int i_current = ImGui::FindWindowFocusIndex(g.NavWindowingTarget);
    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
    if (!window_target)
        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);
    if (window_target) // Don't reset windowing target if there's a single window in the list
        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
    g.NavWindowingToggleLayer = false;
}

// Windowing management mode
// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
static void ImGui::NavUpdateWindowing()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* apply_focus_window = NULL;
    bool apply_toggle_layer = false;

    ImGuiWindow* modal_window = GetTopMostPopupModal();
    bool allow_windowing = (modal_window == NULL);
    if (!allow_windowing)
        g.NavWindowingTarget = NULL;

    // Fade out
    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
    {
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f);
        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
            g.NavWindowingTargetAnim = NULL;
    }

    // Start CTRL-TAB or Square+L/R window selection
    bool start_windowing_with_gamepad = allow_windowing && !g.NavWindowingTarget && IsNavInputTest(ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed);
    bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab) && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard);
    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
        {
            g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
            g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;
            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;
        }

    // Gamepad update
    g.NavWindowingTimer += g.IO.DeltaTime;
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad)
    {
        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));

        // Select window to focus
        const int focus_change_dir = (int)IsNavInputTest(ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow) - (int)IsNavInputTest(ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow);
        if (focus_change_dir != 0)
        {
            NavUpdateWindowingHighlightWindow(focus_change_dir);
            g.NavWindowingHighlightAlpha = 1.0f;
        }

        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
        if (!IsNavInputDown(ImGuiNavInput_Menu))
        {
            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
            if (g.NavWindowingToggleLayer && g.NavWindow)
                apply_toggle_layer = true;
            else if (!g.NavWindowingToggleLayer)
                apply_focus_window = g.NavWindowingTarget;
            g.NavWindowingTarget = NULL;
        }
    }

    // Keyboard: Focus
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Keyboard)
    {
        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
        if (IsKeyPressedMap(ImGuiKey_Tab, true))
            NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);
        if (!g.IO.KeyCtrl)
            apply_focus_window = g.NavWindowingTarget;
    }

    // Keyboard: Press and Release ALT to toggle menu layer
    // FIXME: We lack an explicit IO variable for "is the imgui window focused", so compare mouse validity to detect the common case of backend clearing releases all keys on ALT-TAB
    if (IsNavInputTest(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Pressed))
        g.NavWindowingToggleLayer = true;
    if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && g.NavWindowingToggleLayer && IsNavInputTest(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released))
        if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))
            apply_toggle_layer = true;

    // Move window
    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
    {
        ImVec2 move_delta;
        if (g.NavInputSource == ImGuiInputSource_Keyboard && !g.IO.KeyShift)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_Gamepad)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down);
        if (move_delta.x != 0.0f || move_delta.y != 0.0f)
        {
            const float NAV_MOVE_SPEED = 800.0f;
            const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)); // FIXME: Doesn't handle variable framerate very well
            ImGuiWindow* moving_window = g.NavWindowingTarget->RootWindowDockTree;
            SetWindowPos(moving_window, moving_window->Pos + move_delta * move_speed, ImGuiCond_Always);
            MarkIniSettingsDirty(moving_window);
            g.NavDisableMouseHover = true;
        }
    }

    // Apply final focus
    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
    {
        ImGuiViewport* previous_viewport = g.NavWindow ? g.NavWindow->Viewport : NULL;
        ClearActiveID();
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
        ClosePopupsOverWindow(apply_focus_window, false);
        FocusWindow(apply_focus_window);
        if (apply_focus_window->NavLastIds[0] == 0)
            NavInitWindow(apply_focus_window, false);

        // If the window has ONLY a menu layer (no main layer), select it directly
        // FIXME-NAV: This should be done in NavInit.. or in FocusWindow..
        if (apply_focus_window->DC.NavLayersActiveMask == (1 << ImGuiNavLayer_Menu))
            g.NavLayer = ImGuiNavLayer_Menu;

        // Request OS level focus
        if (apply_focus_window->Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus)
            g.PlatformIO.Platform_SetWindowFocus(apply_focus_window->Viewport);
    }
    if (apply_focus_window)
        g.NavWindowingTarget = NULL;

    // Apply menu/layer toggle
    if (apply_toggle_layer && g.NavWindow)
    {
        ClearActiveID();

        // Move to parent menu if necessary
        ImGuiWindow* new_nav_window = g.NavWindow;
        while (new_nav_window->ParentWindow
            && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
            new_nav_window = new_nav_window->ParentWindow;
        if (new_nav_window != g.NavWindow)
        {
            ImGuiWindow* old_nav_window = g.NavWindow;
            FocusWindow(new_nav_window);
            new_nav_window->NavLastChildNavWindow = old_nav_window;
        }
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;

        // Reinitialize navigation when entering menu bar with the Alt key.
        const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;
        const bool preserve_layer_1_nav_id = (new_nav_window->DockNodeAsHost != NULL);
        if (new_nav_layer == ImGuiNavLayer_Menu && !preserve_layer_1_nav_id)
            g.NavWindow->NavLastIds[new_nav_layer] = 0;
        NavRestoreLayer(new_nav_layer);
    }
}

// Window has already passed the IsWindowNavFocusable()
static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)
{
    if (window->Flags & ImGuiWindowFlags_Popup)
        return "(Popup)";
    if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)
        return "(Main menu bar)";
    if (window->DockNodeAsHost)
        return "(Dock node)";
    return "(Untitled)";
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
void ImGui::NavUpdateWindowingOverlay()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget != NULL);

    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
        return;

    if (g.NavWindowingListWindow == NULL)
        g.NavWindowingListWindow = FindWindowByName("###NavWindowingList");
    const ImGuiViewport* viewport = /*g.NavWindow ? g.NavWindow->Viewport :*/ GetMainViewport();
    SetNextWindowSizeConstraints(ImVec2(viewport->Size.x * 0.20f, viewport->Size.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));
    SetNextWindowPos(viewport->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
    Begin("###NavWindowingList", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)
    {
        ImGuiWindow* window = g.WindowsFocusOrder[n];
        IM_ASSERT(window != NULL); // Fix static analyzers
        if (!IsWindowNavFocusable(window))
            continue;
        const char* label = window->Name;
        if (label == FindRenderedTextEnd(label))
            label = GetFallbackWindowNameForWindowingList(window);
        Selectable(label, g.NavWindowingTarget == window);
    }
    End();
    PopStyleVar();
}


//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

void ImGui::ClearDragDrop()
{
    ImGuiContext& g = *GImGui;
    g.DragDropActive = false;
    g.DragDropPayload.Clear();
    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropAcceptFrameCount = -1;

    g.DragDropPayloadBufHeap.clear();
    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
}

// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
// If the item has an identifier:
// - This assume/require the item to be activated (typically via ButtonBehavior).
// - Therefore if you want to use this with a mouse button other than left mouse button, it is up to the item itself to activate with another button.
// - We then pull and use the mouse button that was used to activate the item and use it to carry on the drag.
// If the item has no identifier:
// - Currently always assume left mouse button.
bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
    // in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
    ImGuiMouseButton mouse_button = ImGuiMouseButton_Left;

    bool source_drag_active = false;
    ImGuiID source_id = 0;
    ImGuiID source_parent_id = 0;
    if (!(flags & ImGuiDragDropFlags_SourceExtern))
    {
        source_id = window->DC.LastItemId;
        if (source_id != 0)
        {
            // Common path: items with ID
            if (g.ActiveId != source_id)
                return false;
            if (g.ActiveIdMouseButton != -1)
                mouse_button = g.ActiveIdMouseButton;
            if (g.IO.MouseDown[mouse_button] == false)
                return false;
            g.ActiveIdAllowOverlap = false;
        }
        else
        {
            // Uncommon path: items without ID
            if (g.IO.MouseDown[mouse_button] == false)
                return false;

            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.
            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
            {
                IM_ASSERT(0);
                return false;
            }

            // Early out
            if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))
                return false;

            // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()
            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
            source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);
            bool is_hovered = ItemHoverable(window->DC.LastItemRect, source_id);
            if (is_hovered && g.IO.MouseClicked[mouse_button])
            {
                SetActiveID(source_id, window);
                FocusWindow(window);
            }
            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
                g.ActiveIdAllowOverlap = is_hovered;
        }
        if (g.ActiveId != source_id)
            return false;
        source_parent_id = window->IDStack.back();
        source_drag_active = IsMouseDragging(mouse_button);

        // Disable navigation and key inputs while dragging
        g.ActiveIdUsingNavDirMask = ~(ImU32)0;
        g.ActiveIdUsingNavInputMask = ~(ImU32)0;
        g.ActiveIdUsingKeyInputMask = ~(ImU64)0;
    }
    else
    {
        window = NULL;
        source_id = ImHashStr("#SourceExtern");
        source_drag_active = true;
    }

    if (source_drag_active)
    {
        if (!g.DragDropActive)
        {
            IM_ASSERT(source_id != 0);
            ClearDragDrop();
            ImGuiPayload& payload = g.DragDropPayload;
            payload.SourceId = source_id;
            payload.SourceParentId = source_parent_id;
            g.DragDropActive = true;
            g.DragDropSourceFlags = flags;
            g.DragDropMouseButton = mouse_button;
            if (payload.SourceId == g.ActiveId)
                g.ActiveIdNoClearOnFocusLoss = true;
        }
        g.DragDropSourceFrameCount = g.FrameCount;
        g.DragDropWithinSource = true;

        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        {
            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
            BeginTooltip();
            if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
            {
                ImGuiWindow* tooltip_window = g.CurrentWindow;
                tooltip_window->SkipItems = true;
                tooltip_window->HiddenFramesCanSkipItems = 1;
            }
        }

        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
            window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

        return true;
    }
    return false;
}

void ImGui::EndDragDropSource()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSource && "Not after a BeginDragDropSource()?");

    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        EndTooltip();

    // Discard the drag if have not called SetDragDropPayload()
    if (g.DragDropPayload.DataFrameCount == -1)
        ClearDragDrop();
    g.DragDropWithinSource = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    ImGuiPayload& payload = g.DragDropPayload;
    if (cond == 0)
        cond = ImGuiCond_Always;

    IM_ASSERT(type != NULL);
    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()

    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
    {
        // Copy payload
        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
        g.DragDropPayloadBufHeap.resize(0);
        if (data_size > sizeof(g.DragDropPayloadBufLocal))
        {
            // Store in heap
            g.DragDropPayloadBufHeap.resize((int)data_size);
            payload.Data = g.DragDropPayloadBufHeap.Data;
            memcpy(payload.Data, data, data_size);
        }
        else if (data_size > 0)
        {
            // Store locally
            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
            payload.Data = g.DragDropPayloadBufLocal;
            memcpy(payload.Data, data, data_size);
        }
        else
        {
            payload.Data = NULL;
        }
        payload.DataSize = (int)data_size;
    }
    payload.DataFrameCount = g.FrameCount;

    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow;
    if (hovered_window == NULL || window->RootWindowDockTree != hovered_window->RootWindowDockTree)
        return false;
    IM_ASSERT(id != 0);
    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
        return false;
    if (window->SkipItems)
        return false;

    IM_ASSERT(g.DragDropWithinTarget == false);
    g.DragDropTargetRect = bb;
    g.DragDropTargetId = id;
    g.DragDropWithinTarget = true;
    return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
bool ImGui::BeginDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow;
    if (hovered_window == NULL || window->RootWindowDockTree != hovered_window->RootWindowDockTree)
        return false;

    const ImRect& display_rect = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;
    ImGuiID id = window->DC.LastItemId;
    if (id == 0)
        id = window->GetIDFromRectangle(display_rect);
    if (g.DragDropPayload.SourceId == id)
        return false;

    IM_ASSERT(g.DragDropWithinTarget == false);
    g.DragDropTargetRect = display_rect;
    g.DragDropTargetId = id;
    g.DragDropWithinTarget = true;
    return true;
}

bool ImGui::IsDragDropPayloadBeingAccepted()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiPayload& payload = g.DragDropPayload;
    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
    if (type != NULL && !payload.IsDataType(type))
        return NULL;

    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
    ImRect r = g.DragDropTargetRect;
    float r_surface = r.GetWidth() * r.GetHeight();
    if (r_surface <= g.DragDropAcceptIdCurrRectSurface)
    {
        g.DragDropAcceptFlags = flags;
        g.DragDropAcceptIdCurr = g.DragDropTargetId;
        g.DragDropAcceptIdCurrRectSurface = r_surface;
    }

    // Render default drop visuals
    payload.Preview = was_accepted_previously;
    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)
    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
    {
        // FIXME-DRAGDROP: Settle on a proper default visuals for drop target.
        r.Expand(3.5f);
        bool push_clip_rect = !window->ClipRect.Contains(r);
        if (push_clip_rect) window->DrawList->PushClipRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1));
        window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, 0, 2.0f);
        if (push_clip_rect) window->DrawList->PopClipRect();
    }

    g.DragDropAcceptFrameCount = g.FrameCount;
    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
        return NULL;

    return &payload;
}

const ImGuiPayload* ImGui::GetDragDropPayload()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive ? &g.DragDropPayload : NULL;
}

// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.
void ImGui::EndDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinTarget);
    g.DragDropWithinTarget = false;
}

//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
static inline void LogTextV(ImGuiContext& g, const char* fmt, va_list args)
{
    if (g.LogFile)
    {
        g.LogBuffer.Buf.resize(0);
        g.LogBuffer.appendfv(fmt, args);
        ImFileWrite(g.LogBuffer.c_str(), sizeof(char), (ImU64)g.LogBuffer.size(), g.LogFile);
    }
    else
    {
        g.LogBuffer.appendfv(fmt, args);
    }
}

void ImGui::LogText(const char* fmt, ...)
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    va_list args;
    va_start(args, fmt);
    LogTextV(g, fmt, args);
    va_end(args);
}

void ImGui::LogTextV(const char* fmt, va_list args)
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    LogTextV(g, fmt, args);
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
// FIXME: This code is a little complicated perhaps, considering simplifying the whole system.
void ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const char* prefix = g.LogNextPrefix;
    const char* suffix = g.LogNextSuffix;
    g.LogNextPrefix = g.LogNextSuffix = NULL;

    if (!text_end)
        text_end = FindRenderedTextEnd(text, text_end);

    const bool log_new_line = ref_pos && (ref_pos->y > g.LogLinePosY + g.Style.FramePadding.y + 1);
    if (ref_pos)
        g.LogLinePosY = ref_pos->y;
    if (log_new_line)
    {
        LogText(IM_NEWLINE);
        g.LogLineFirstItem = true;
    }

    if (prefix)
        LogRenderedText(ref_pos, prefix, prefix + strlen(prefix)); // Calculate end ourself to ensure "##" are included here.

    // Re-adjust padding if we have popped out of our starting depth
    if (g.LogDepthRef > window->DC.TreeDepth)
        g.LogDepthRef = window->DC.TreeDepth;
    const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);

    const char* text_remaining = text;
    for (;;)
    {
        // Split the string. Each new line (after a '\n') is followed by indentation corresponding to the current depth of our log entry.
        // We don't add a trailing \n yet to allow a subsequent item on the same line to be captured.
        const char* line_start = text_remaining;
        const char* line_end = ImStreolRange(line_start, text_end);
        const bool is_last_line = (line_end == text_end);
        if (line_start != line_end || !is_last_line)
        {
            const int line_length = (int)(line_end - line_start);
            const int indentation = g.LogLineFirstItem ? tree_depth * 4 : 1;
            LogText("%*s%.*s", indentation, "", line_length, line_start);
            g.LogLineFirstItem = false;
            if (*line_end == '\n')
            {
                LogText(IM_NEWLINE);
                g.LogLineFirstItem = true;
            }
        }
        if (is_last_line)
            break;
        text_remaining = line_end + 1;
    }

    if (suffix)
        LogRenderedText(ref_pos, suffix, suffix + strlen(suffix));
}

// Start logging/capturing text output
void ImGui::LogBegin(ImGuiLogType type, int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(g.LogEnabled == false);
    IM_ASSERT(g.LogFile == NULL);
    IM_ASSERT(g.LogBuffer.empty());
    g.LogEnabled = true;
    g.LogType = type;
    g.LogNextPrefix = g.LogNextSuffix = NULL;
    g.LogDepthRef = window->DC.TreeDepth;
    g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault);
    g.LogLinePosY = FLT_MAX;
    g.LogLineFirstItem = true;
}

// Important: doesn't copy underlying data, use carefully (prefix/suffix must be in scope at the time of the next LogRenderedText)
void ImGui::LogSetNextTextDecoration(const char* prefix, const char* suffix)
{
    ImGuiContext& g = *GImGui;
    g.LogNextPrefix = prefix;
    g.LogNextSuffix = suffix;
}

void ImGui::LogToTTY(int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    IM_UNUSED(auto_open_depth);
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
    LogBegin(ImGuiLogType_TTY, auto_open_depth);
    g.LogFile = stdout;
#endif
}

// Start logging/capturing text output to given file
void ImGui::LogToFile(int auto_open_depth, const char* filename)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;

    // FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still
    // be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.
    // By opening the file in binary mode "ab" we have consistent output everywhere.
    if (!filename)
        filename = g.IO.LogFilename;
    if (!filename || !filename[0])
        return;
    ImFileHandle f = ImFileOpen(filename, "ab");
    if (!f)
    {
        IM_ASSERT(0);
        return;
    }

    LogBegin(ImGuiLogType_File, auto_open_depth);
    g.LogFile = f;
}

// Start logging/capturing text output to clipboard
void ImGui::LogToClipboard(int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    LogBegin(ImGuiLogType_Clipboard, auto_open_depth);
}

void ImGui::LogToBuffer(int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    LogBegin(ImGuiLogType_Buffer, auto_open_depth);
}

void ImGui::LogFinish()
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    LogText(IM_NEWLINE);
    switch (g.LogType)
    {
    case ImGuiLogType_TTY:
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
        fflush(g.LogFile);
#endif
        break;
    case ImGuiLogType_File:
        ImFileClose(g.LogFile);
        break;
    case ImGuiLogType_Buffer:
        break;
    case ImGuiLogType_Clipboard:
        if (!g.LogBuffer.empty())
            SetClipboardText(g.LogBuffer.begin());
        break;
    case ImGuiLogType_None:
        IM_ASSERT(0);
        break;
    }

    g.LogEnabled = false;
    g.LogType = ImGuiLogType_None;
    g.LogFile = NULL;
    g.LogBuffer.clear();
}

// Helper to display logging buttons
// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
void ImGui::LogButtons()
{
    ImGuiContext& g = *GImGui;

    PushID("LogButtons");
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
    const bool log_to_tty = Button("Log To TTY"); SameLine();
#else
    const bool log_to_tty = false;
#endif
    const bool log_to_file = Button("Log To File"); SameLine();
    const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();
    PushAllowKeyboardFocus(false);
    SetNextItemWidth(80.0f);
    SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, NULL);
    PopAllowKeyboardFocus();
    PopID();

    // Start logging at the end of the function so that the buttons don't appear in the log
    if (log_to_tty)
        LogToTTY();
    if (log_to_file)
        LogToFile();
    if (log_to_clipboard)
        LogToClipboard();
}


//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------
// - UpdateSettings() [Internal]
// - MarkIniSettingsDirty() [Internal]
// - CreateNewWindowSettings() [Internal]
// - FindWindowSettings() [Internal]
// - FindOrCreateWindowSettings() [Internal]
// - FindSettingsHandler() [Internal]
// - ClearIniSettings() [Internal]
// - LoadIniSettingsFromDisk()
// - LoadIniSettingsFromMemory()
// - SaveIniSettingsToDisk()
// - SaveIniSettingsToMemory()
// - WindowSettingsHandler_***() [Internal]
//-----------------------------------------------------------------------------

// Called by NewFrame()
void ImGui::UpdateSettings()
{
    // Load settings on first frame (if not explicitly loaded manually before)
    ImGuiContext& g = *GImGui;
    if (!g.SettingsLoaded)
    {
        IM_ASSERT(g.SettingsWindows.empty());
        if (g.IO.IniFilename)
            LoadIniSettingsFromDisk(g.IO.IniFilename);
        g.SettingsLoaded = true;
    }

    // Save settings (with a delay after the last modification, so we don't spam disk too much)
    if (g.SettingsDirtyTimer > 0.0f)
    {
        g.SettingsDirtyTimer -= g.IO.DeltaTime;
        if (g.SettingsDirtyTimer <= 0.0f)
        {
            if (g.IO.IniFilename != NULL)
                SaveIniSettingsToDisk(g.IO.IniFilename);
            else
                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
            g.SettingsDirtyTimer = 0.0f;
        }
    }
}

void ImGui::MarkIniSettingsDirty()
{
    ImGuiContext& g = *GImGui;
    if (g.SettingsDirtyTimer <= 0.0f)
        g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
        if (g.SettingsDirtyTimer <= 0.0f)
            g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)
{
    ImGuiContext& g = *GImGui;

#if !IMGUI_DEBUG_INI_SETTINGS
    // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
    // Preserve the full string when IMGUI_DEBUG_INI_SETTINGS is set to make .ini inspection easier.
    if (const char* p = strstr(name, "###"))
        name = p;
#endif
    const size_t name_len = strlen(name);

    // Allocate chunk
    const size_t chunk_size = sizeof(ImGuiWindowSettings) + name_len + 1;
    ImGuiWindowSettings* settings = g.SettingsWindows.alloc_chunk(chunk_size);
    IM_PLACEMENT_NEW(settings) ImGuiWindowSettings();
    settings->ID = ImHashStr(name, name_len);
    memcpy(settings->GetName(), name, name_len + 1);   // Store with zero terminator

    return settings;
}

ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        if (settings->ID == id)
            return settings;
    return NULL;
}

ImGuiWindowSettings* ImGui::FindOrCreateWindowSettings(const char* name)
{
    if (ImGuiWindowSettings* settings = FindWindowSettings(ImHashStr(name)))
        return settings;
    return CreateNewWindowSettings(name);
}

ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
{
    ImGuiContext& g = *GImGui;
    const ImGuiID type_hash = ImHashStr(type_name);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
            return &g.SettingsHandlers[handler_n];
    return NULL;
}

void ImGui::ClearIniSettings()
{
    ImGuiContext& g = *GImGui;
    g.SettingsIniData.clear();
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].ClearAllFn)
            g.SettingsHandlers[handler_n].ClearAllFn(&g, &g.SettingsHandlers[handler_n]);
}

void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)
{
    size_t file_data_size = 0;
    char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
    if (!file_data)
        return;
    LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
    IM_FREE(file_data);
}

// Zero-tolerance, no error reporting, cheap .ini parsing
void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);
    //IM_ASSERT(!g.WithinFrameScope && "Cannot be called between NewFrame() and EndFrame()");
    //IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
    if (ini_size == 0)
        ini_size = strlen(ini_data);
    g.SettingsIniData.Buf.resize((int)ini_size + 1);
    char* const buf = g.SettingsIniData.Buf.Data;
    char* const buf_end = buf + ini_size;
    memcpy(buf, ini_data, ini_size);
    buf_end[0] = 0;

    // Call pre-read handlers
    // Some types will clear their data (e.g. dock information) some types will allow merge/override (window)
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].ReadInitFn)
            g.SettingsHandlers[handler_n].ReadInitFn(&g, &g.SettingsHandlers[handler_n]);

    void* entry_data = NULL;
    ImGuiSettingsHandler* entry_handler = NULL;

    char* line_end = NULL;
    for (char* line = buf; line < buf_end; line = line_end + 1)
    {
        // Skip new lines markers, then find end of the line
        while (*line == '\n' || *line == '\r')
            line++;
        line_end = line;
        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
            line_end++;
        line_end[0] = 0;
        if (line[0] == ';')
            continue;
        if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        {
            // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
            line_end[-1] = 0;
            const char* name_end = line_end - 1;
            const char* type_start = line + 1;
            char* type_end = (char*)(void*)ImStrchrRange(type_start, name_end, ']');
            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
            if (!type_end || !name_start)
                continue;
            *type_end = 0; // Overwrite first ']'
            name_start++;  // Skip second '['
            entry_handler = FindSettingsHandler(type_start);
            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
        }
        else if (entry_handler != NULL && entry_data != NULL)
        {
            // Let type handler parse the line
            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
        }
    }
    g.SettingsLoaded = true;

    // [DEBUG] Restore untouched copy so it can be browsed in Metrics (not strictly necessary)
    memcpy(buf, ini_data, ini_size);

    // Call post-read handlers
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].ApplyAllFn)
            g.SettingsHandlers[handler_n].ApplyAllFn(&g, &g.SettingsHandlers[handler_n]);
}

void ImGui::SaveIniSettingsToDisk(const char* ini_filename)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    if (!ini_filename)
        return;

    size_t ini_data_size = 0;
    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);
    ImFileHandle f = ImFileOpen(ini_filename, "wt");
    if (!f)
        return;
    ImFileWrite(ini_data, sizeof(char), ini_data_size, f);
    ImFileClose(f);
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    g.SettingsIniData.Buf.resize(0);
    g.SettingsIniData.Buf.push_back(0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
    {
        ImGuiSettingsHandler* handler = &g.SettingsHandlers[handler_n];
        handler->WriteAllFn(&g, handler, &g.SettingsIniData);
    }
    if (out_size)
        *out_size = (size_t)g.SettingsIniData.size();
    return g.SettingsIniData.c_str();
}

static void WindowSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Windows.Size; i++)
        g.Windows[i]->SettingsOffset = -1;
    g.SettingsWindows.clear();
}

static void* WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    ImGuiWindowSettings* settings = ImGui::FindOrCreateWindowSettings(name);
    ImGuiID id = settings->ID;
    *settings = ImGuiWindowSettings(); // Clear existing if recycling previous entry
    settings->ID = id;
    settings->WantApply = true;
    return (void*)settings;
}

static void WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
{
    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
    int x, y;
    int i;
    ImU32 u1;
    if (sscanf(line, "Pos=%i,%i", &x, &y) == 2)             { settings->Pos = ImVec2ih((short)x, (short)y); }
    else if (sscanf(line, "Size=%i,%i", &x, &y) == 2)       { settings->Size = ImVec2ih((short)x, (short)y); }
    else if (sscanf(line, "ViewportId=0x%08X", &u1) == 1)   { settings->ViewportId = u1; }
    else if (sscanf(line, "ViewportPos=%i,%i", &x, &y) == 2){ settings->ViewportPos = ImVec2ih((short)x, (short)y); }
    else if (sscanf(line, "Collapsed=%d", &i) == 1)         { settings->Collapsed = (i != 0); }
    else if (sscanf(line, "DockId=0x%X,%d", &u1, &i) == 2)  { settings->DockId = u1; settings->DockOrder = (short)i; }
    else if (sscanf(line, "DockId=0x%X", &u1) == 1)         { settings->DockId = u1; settings->DockOrder = -1; }
    else if (sscanf(line, "ClassId=0x%X", &u1) == 1)        { settings->ClassId = u1; }
}

// Apply to existing windows (if any)
static void WindowSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        if (settings->WantApply)
        {
            if (ImGuiWindow* window = ImGui::FindWindowByID(settings->ID))
                ApplyWindowSettings(window, settings);
            settings->WantApply = false;
        }
}

static void WindowSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
    // Gather data from windows that were active during this session
    // (if a window wasn't opened in this session we preserve its settings)
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
            continue;

        ImGuiWindowSettings* settings = (window->SettingsOffset != -1) ? g.SettingsWindows.ptr_from_offset(window->SettingsOffset) : ImGui::FindWindowSettings(window->ID);
        if (!settings)
        {
            settings = ImGui::CreateNewWindowSettings(window->Name);
            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
        }
        IM_ASSERT(settings->ID == window->ID);
        settings->Pos = ImVec2ih(window->Pos - window->ViewportPos);
        settings->Size = ImVec2ih(window->SizeFull);
        settings->ViewportId = window->ViewportId;
        settings->ViewportPos = ImVec2ih(window->ViewportPos);
        IM_ASSERT(window->DockNode == NULL || window->DockNode->ID == window->DockId);
        settings->DockId = window->DockId;
        settings->ClassId = window->WindowClass.ClassId;
        settings->DockOrder = window->DockOrder;
        settings->Collapsed = window->Collapsed;
    }

    // Write to text buffer
    buf->reserve(buf->size() + g.SettingsWindows.size() * 6); // ballpark reserve
    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
    {
        const char* settings_name = settings->GetName();
        buf->appendf("[%s][%s]\n", handler->TypeName, settings_name);
        if (settings->ViewportId != 0 && settings->ViewportId != ImGui::IMGUI_VIEWPORT_DEFAULT_ID)
        {
            buf->appendf("ViewportPos=%d,%d\n", settings->ViewportPos.x, settings->ViewportPos.y);
            buf->appendf("ViewportId=0x%08X\n", settings->ViewportId);
        }
        if (settings->Pos.x != 0 || settings->Pos.y != 0 || settings->ViewportId == ImGui::IMGUI_VIEWPORT_DEFAULT_ID)
            buf->appendf("Pos=%d,%d\n", settings->Pos.x, settings->Pos.y);
        if (settings->Size.x != 0 || settings->Size.y != 0)
            buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
        buf->appendf("Collapsed=%d\n", settings->Collapsed);
        if (settings->DockId != 0)
        {
            if (settings->DockOrder == -1)
                buf->appendf("DockId=0x%08X\n", settings->DockId);
            else
                buf->appendf("DockId=0x%08X,%d\n", settings->DockId, settings->DockOrder);
            if (settings->ClassId != 0)
                buf->appendf("ClassId=0x%08X\n", settings->ClassId);
        }
        buf->append("\n");
    }
}


//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------
// - GetMainViewport()
// - FindViewportByID()
// - FindViewportByPlatformHandle()
// - SetCurrentViewport() [Internal]
// - SetWindowViewport() [Internal]
// - GetWindowAlwaysWantOwnViewport() [Internal]
// - UpdateTryMergeWindowIntoHostViewport() [Internal]
// - UpdateTryMergeWindowIntoHostViewports() [Internal]
// - TranslateWindowsInViewport() [Internal]
// - ScaleWindowsInViewport() [Internal]
// - FindHoveredViewportFromPlatformWindowStack() [Internal]
// - UpdateViewportsNewFrame() [Internal]
// - UpdateViewportsEndFrame() [Internal]
// - AddUpdateViewport() [Internal]
// - UpdateSelectWindowViewport() [Internal]
// - UpdatePlatformWindows()
// - RenderPlatformWindowsDefault()
// - FindPlatformMonitorForPos() [Internal]
// - FindPlatformMonitorForRect() [Internal]
// - UpdateViewportPlatformMonitor() [Internal]
// - DestroyPlatformWindow() [Internal]
// - DestroyPlatformWindows()
//-----------------------------------------------------------------------------

ImGuiViewport* ImGui::GetMainViewport()
{
    ImGuiContext& g = *GImGui;
    return g.Viewports[0];
}

ImGuiViewport* ImGui::FindViewportByID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    for (int n = 0; n < g.Viewports.Size; n++)
        if (g.Viewports[n]->ID == id)
            return g.Viewports[n];
    return NULL;
}

ImGuiViewport* ImGui::FindViewportByPlatformHandle(void* platform_handle)
{
    ImGuiContext& g = *GImGui;
    for (int i = 0; i != g.Viewports.Size; i++)
        if (g.Viewports[i]->PlatformHandle == platform_handle)
            return g.Viewports[i];
    return NULL;
}

void ImGui::SetCurrentViewport(ImGuiWindow* current_window, ImGuiViewportP* viewport)
{
    ImGuiContext& g = *GImGui;
    (void)current_window;

    if (viewport)
        viewport->LastFrameActive = g.FrameCount;
    if (g.CurrentViewport == viewport)
        return;
    g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;
    g.CurrentViewport = viewport;
    //IMGUI_DEBUG_LOG_VIEWPORT("SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);

    // Notify platform layer of viewport changes
    // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
    if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport)
        g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);
}

static void SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
{
    window->Viewport = viewport;
    window->ViewportId = viewport->ID;
    window->ViewportOwned = (viewport->Window == window);
}

static bool ImGui::GetWindowAlwaysWantOwnViewport(ImGuiWindow* window)
{
    // Tooltips and menus are not automatically forced into their own viewport when the NoMerge flag is set, however the multiplication of viewports makes them more likely to protrude and create their own.
    ImGuiContext& g = *GImGui;
    if (g.IO.ConfigViewportsNoAutoMerge || (window->WindowClass.ViewportFlagsOverrideSet & ImGuiViewportFlags_NoAutoMerge))
        if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
            if (!window->DockIsActive)
                if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip)) == 0)
                    if ((window->Flags & ImGuiWindowFlags_Popup) == 0 || (window->Flags & ImGuiWindowFlags_Modal) != 0)
                        return true;
    return false;
}

static bool ImGui::UpdateTryMergeWindowIntoHostViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
{
    ImGuiContext& g = *GImGui;
    if (window->Viewport == viewport)
        return false;
    if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) == 0)
        return false;
    if ((viewport->Flags & ImGuiViewportFlags_Minimized) != 0)
        return false;
    if (!viewport->GetMainRect().Contains(window->Rect()))
        return false;
    if (GetWindowAlwaysWantOwnViewport(window))
        return false;

    for (int n = 0; n < g.Windows.Size; n++)
    {
        ImGuiWindow* window_behind = g.Windows[n];
        if (window_behind == window)
            break;
        if (window_behind->WasActive && window_behind->ViewportOwned && !(window_behind->Flags & ImGuiWindowFlags_ChildWindow))
            if (window_behind->Viewport->GetMainRect().Overlaps(window->Rect()))
                return false;
    }

    // Move to the existing viewport, Move child/hosted windows as well (FIXME-OPT: iterate child)
    ImGuiViewportP* old_viewport = window->Viewport;
    if (window->ViewportOwned)
        for (int n = 0; n < g.Windows.Size; n++)
            if (g.Windows[n]->Viewport == old_viewport)
                SetWindowViewport(g.Windows[n], viewport);
    SetWindowViewport(window, viewport);
    BringWindowToDisplayFront(window);

    return true;
}

// FIXME: handle 0 to N host viewports
static bool ImGui::UpdateTryMergeWindowIntoHostViewports(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    return UpdateTryMergeWindowIntoHostViewport(window, g.Viewports[0]);
}

// Translate Dear ImGui windows when a Host Viewport has been moved
// (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
void ImGui::TranslateWindowsInViewport(ImGuiViewportP* viewport, const ImVec2& old_pos, const ImVec2& new_pos)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(viewport->Window == NULL && (viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows));

    // 1) We test if ImGuiConfigFlags_ViewportsEnable was just toggled, which allows us to conveniently
    // translate imgui windows from OS-window-local to absolute coordinates or vice-versa.
    // 2) If it's not going to fit into the new size, keep it at same absolute position.
    // One problem with this is that most Win32 applications doesn't update their render while dragging,
    // and so the window will appear to teleport when releasing the mouse.
    const bool translate_all_windows = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable);
    ImRect test_still_fit_rect(old_pos, old_pos + viewport->Size);
    ImVec2 delta_pos = new_pos - old_pos;
    for (int window_n = 0; window_n < g.Windows.Size; window_n++) // FIXME-OPT
        if (translate_all_windows || (g.Windows[window_n]->Viewport == viewport && test_still_fit_rect.Contains(g.Windows[window_n]->Rect())))
            TranslateWindow(g.Windows[window_n], delta_pos);
}

// Scale all windows (position, size). Use when e.g. changing DPI. (This is a lossy operation!)
void ImGui::ScaleWindowsInViewport(ImGuiViewportP* viewport, float scale)
{
    ImGuiContext& g = *GImGui;
    if (viewport->Window)
    {
        ScaleWindow(viewport->Window, scale);
    }
    else
    {
        for (int i = 0; i != g.Windows.Size; i++)
            if (g.Windows[i]->Viewport == viewport)
                ScaleWindow(g.Windows[i], scale);
    }
}

// If the backend doesn't set MouseLastHoveredViewport or doesn't honor ImGuiViewportFlags_NoInputs, we do a search ourselves.
// A) It won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
// B) It requires Platform_GetWindowFocus to be implemented by backend.
static ImGuiViewportP* FindHoveredViewportFromPlatformWindowStack(const ImVec2 mouse_platform_pos)
{
    ImGuiContext& g = *GImGui;
    ImGuiViewportP* best_candidate = NULL;
    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        if (!(viewport->Flags & (ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_Minimized)) && viewport->GetMainRect().Contains(mouse_platform_pos))
            if (best_candidate == NULL || best_candidate->LastFrontMostStampCount < viewport->LastFrontMostStampCount)
                best_candidate = viewport;
    }
    return best_candidate;
}

// Update viewports and monitor infos
// Note that this is running even if 'ImGuiConfigFlags_ViewportsEnable' is not set, in order to clear unused viewports (if any) and update monitor info.
static void ImGui::UpdateViewportsNewFrame()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size);

    // Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
    const bool viewports_enabled = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != 0;
    if (viewports_enabled)
    {
        for (int n = 0; n < g.Viewports.Size; n++)
        {
            ImGuiViewportP* viewport = g.Viewports[n];
            const bool platform_funcs_available = viewport->PlatformWindowCreated;
            if (g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available)
            {
                bool minimized = g.PlatformIO.Platform_GetWindowMinimized(viewport);
                if (minimized)
                    viewport->Flags |= ImGuiViewportFlags_Minimized;
                else
                    viewport->Flags &= ~ImGuiViewportFlags_Minimized;
            }
        }
    }

    // Create/update main viewport with current platform position.
    // FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
    ImGuiViewportP* main_viewport = g.Viewports[0];
    IM_ASSERT(main_viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID);
    IM_ASSERT(main_viewport->Window == NULL);
    ImVec2 main_viewport_pos = viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2(0.0f, 0.0f);
    ImVec2 main_viewport_size = g.IO.DisplaySize;
    if (viewports_enabled && (main_viewport->Flags & ImGuiViewportFlags_Minimized))
    {
        main_viewport_pos = main_viewport->Pos;    // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
        main_viewport_size = main_viewport->Size;
    }
    AddUpdateViewport(NULL, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_CanHostOtherWindows);

    g.CurrentDpiScale = 0.0f;
    g.CurrentViewport = NULL;
    g.MouseViewport = NULL;
    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        viewport->Idx = n;

        // Erase unused viewports
        if (n > 0 && viewport->LastFrameActive < g.FrameCount - 2)
        {
            // Clear references to this viewport in windows (window->ViewportId becomes the master data)
            for (int window_n = 0; window_n < g.Windows.Size; window_n++)
                if (g.Windows[window_n]->Viewport == viewport)
                {
                    g.Windows[window_n]->Viewport = NULL;
                    g.Windows[window_n]->ViewportOwned = false;
                }
            if (viewport == g.MouseLastHoveredViewport)
                g.MouseLastHoveredViewport = NULL;
            g.Viewports.erase(g.Viewports.Data + n);

            // Destroy
            IMGUI_DEBUG_LOG_VIEWPORT("Delete Viewport %08X (%s)\n", viewport->ID, viewport->Window ? viewport->Window->Name : "n/a");
            DestroyPlatformWindow(viewport); // In most circumstances the platform window will already be destroyed here.
            IM_ASSERT(g.PlatformIO.Viewports.contains(viewport) == false);
            IM_DELETE(viewport);
            n--;
            continue;
        }

        const bool platform_funcs_available = viewport->PlatformWindowCreated;
        if (viewports_enabled)
        {
            // Update Position and Size (from Platform Window to ImGui) if requested.
            // We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
            if (!(viewport->Flags & ImGuiViewportFlags_Minimized) && platform_funcs_available)
            {
                // Viewport->WorkPos and WorkSize will be updated below
                if (viewport->PlatformRequestMove)
                    viewport->Pos = viewport->LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport);
                if (viewport->PlatformRequestResize)
                    viewport->Size = viewport->LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport);
            }
        }

        // Update/copy monitor info
        UpdateViewportPlatformMonitor(viewport);

        // Lock down space taken by menu bars and status bars, reset the offset for functions like BeginMainMenuBar() to alter them again.
        viewport->WorkOffsetMin = viewport->BuildWorkOffsetMin;
        viewport->WorkOffsetMax = viewport->BuildWorkOffsetMax;
        viewport->BuildWorkOffsetMin = viewport->BuildWorkOffsetMax = ImVec2(0.0f, 0.0f);
        viewport->UpdateWorkRect();

        // Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
        viewport->Alpha = 1.0f;

        // Translate imgui windows when a Host Viewport has been moved
        // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
        const ImVec2 viewport_delta_pos = viewport->Pos - viewport->LastPos;
        if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) && (viewport_delta_pos.x != 0.0f || viewport_delta_pos.y != 0.0f))
            TranslateWindowsInViewport(viewport, viewport->LastPos, viewport->Pos);

        // Update DPI scale
        float new_dpi_scale;
        if (g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available)
            new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport);
        else if (viewport->PlatformMonitor != -1)
            new_dpi_scale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
        else
            new_dpi_scale = (viewport->DpiScale != 0.0f) ? viewport->DpiScale : 1.0f;
        if (viewport->DpiScale != 0.0f && new_dpi_scale != viewport->DpiScale)
        {
            float scale_factor = new_dpi_scale / viewport->DpiScale;
            if (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleViewports)
                ScaleWindowsInViewport(viewport, scale_factor);
            //if (viewport == GetMainViewport())
            //    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);

            // Scale our window moving pivot so that the window will rescale roughly around the mouse position.
            // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
            // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
            //if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
            //    g.ActiveIdClickOffset = ImFloor(g.ActiveIdClickOffset * scale_factor);
        }
        viewport->DpiScale = new_dpi_scale;
    }

    // Update fallback monitor
    if (g.PlatformIO.Monitors.Size == 0)
    {
        ImGuiPlatformMonitor* monitor = &g.FallbackMonitor;
        monitor->MainPos = main_viewport->Pos;
        monitor->MainSize = main_viewport->Size;
        monitor->WorkPos = main_viewport->WorkPos;
        monitor->WorkSize = main_viewport->WorkSize;
        monitor->DpiScale = main_viewport->DpiScale;
    }

    if (!viewports_enabled)
    {
        g.MouseViewport = main_viewport;
        return;
    }

    // Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
    // Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
    ImGuiViewportP* viewport_hovered = NULL;
    if (g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)
    {
        viewport_hovered = g.IO.MouseHoveredViewport ? (ImGuiViewportP*)FindViewportByID(g.IO.MouseHoveredViewport) : NULL;
        if (viewport_hovered && (viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
        {
            // Backend failed at honoring its contract if it returned a viewport with the _NoInputs flag.
            IM_ASSERT(0);
            viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
        }
    }
    else
    {
        // If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
        // A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
        // B) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
        viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
    }
    if (viewport_hovered != NULL)
        g.MouseLastHoveredViewport = viewport_hovered;
    else if (g.MouseLastHoveredViewport == NULL)
        g.MouseLastHoveredViewport = g.Viewports[0];

    // Update mouse reference viewport
    // (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
    if (g.MovingWindow)
        g.MouseViewport = g.MovingWindow->Viewport;
    else
        g.MouseViewport = g.MouseLastHoveredViewport;

    // When dragging something, always refer to the last hovered viewport.
    // - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
    // - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
    // - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
    // FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
    const bool is_mouse_dragging_with_an_expected_destination = g.DragDropActive;
    if (is_mouse_dragging_with_an_expected_destination && viewport_hovered == NULL)
        viewport_hovered = g.MouseLastHoveredViewport;
    if (is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown())
        if (viewport_hovered != NULL && viewport_hovered != g.MouseViewport && !(viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
            g.MouseViewport = viewport_hovered;

    IM_ASSERT(g.MouseViewport != NULL);
}

// Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
static void ImGui::UpdateViewportsEndFrame()
{
    ImGuiContext& g = *GImGui;
    g.PlatformIO.Viewports.resize(0);
    for (int i = 0; i < g.Viewports.Size; i++)
    {
        ImGuiViewportP* viewport = g.Viewports[i];
        viewport->LastPos = viewport->Pos;
        if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0.0f || viewport->Size.y <= 0.0f)
            if (i > 0) // Always include main viewport in the list
                continue;
        if (viewport->Window && !IsWindowActiveAndVisible(viewport->Window))
            continue;
        if (i > 0)
            IM_ASSERT(viewport->Window != NULL);
        g.PlatformIO.Viewports.push_back(viewport);
    }
    g.Viewports[0]->ClearRequestFlags(); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
}

// FIXME: We should ideally refactor the system to call this every frame (we currently don't)
ImGuiViewportP* ImGui::AddUpdateViewport(ImGuiWindow* window, ImGuiID id, const ImVec2& pos, const ImVec2& size, ImGuiViewportFlags flags)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(id != 0);

    flags |= ImGuiViewportFlags_IsPlatformWindow;
    if (window != NULL)
    {
        if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window)
            flags |= ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_NoFocusOnAppearing;
        if ((window->Flags & ImGuiWindowFlags_NoMouseInputs) && (window->Flags & ImGuiWindowFlags_NoNavInputs))
            flags |= ImGuiViewportFlags_NoInputs;
        if (window->Flags & ImGuiWindowFlags_NoFocusOnAppearing)
            flags |= ImGuiViewportFlags_NoFocusOnAppearing;
    }

    ImGuiViewportP* viewport = (ImGuiViewportP*)FindViewportByID(id);
    if (viewport)
    {
        if (!viewport->PlatformRequestMove)
            viewport->Pos = pos;
        if (!viewport->PlatformRequestResize)
            viewport->Size = size;
        viewport->Flags = flags | (viewport->Flags & ImGuiViewportFlags_Minimized); // Preserve existing flags
    }
    else
    {
        // New viewport
        viewport = IM_NEW(ImGuiViewportP)();
        viewport->ID = id;
        viewport->Idx = g.Viewports.Size;
        viewport->Pos = viewport->LastPos = pos;
        viewport->Size = size;
        viewport->Flags = flags;
        UpdateViewportPlatformMonitor(viewport);
        g.Viewports.push_back(viewport);
        IMGUI_DEBUG_LOG_VIEWPORT("Add Viewport %08X (%s)\n", id, window->Name);

        // We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
        // We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
        g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport->Pos.x);
        g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport->Pos.y);
        g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport->Pos.x + viewport->Size.x);
        g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport->Pos.y + viewport->Size.y);

        // Store initial DpiScale before the OS platform window creation, based on expected monitor data.
        // This is so we can select an appropriate font size on the first frame of our window lifetime
        if (viewport->PlatformMonitor != -1)
            viewport->DpiScale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
    }

    viewport->Window = window;
    viewport->LastFrameActive = g.FrameCount;
    viewport->UpdateWorkRect();
    IM_ASSERT(window == NULL || viewport->ID == window->ID);

    if (window != NULL)
        window->ViewportOwned = true;

    return viewport;
}

// FIXME-VIEWPORT: This is all super messy and ought to be clarified or rewritten.
static void ImGui::UpdateSelectWindowViewport(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindowFlags flags = window->Flags;
    window->ViewportAllowPlatformMonitorExtend = -1;

    // Restore main viewport if multi-viewport is not supported by the backend
    ImGuiViewportP* main_viewport = (ImGuiViewportP*)(void*)GetMainViewport();
    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
    {
        SetWindowViewport(window, main_viewport);
        return;
    }
    window->ViewportOwned = false;

    // Appearing popups reset their viewport so they can inherit again
    if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && window->Appearing)
    {
        window->Viewport = NULL;
        window->ViewportId = 0;
    }

    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport) == 0)
    {
        // By default inherit from parent window
        if (window->Viewport == NULL && window->ParentWindow && !window->ParentWindow->IsFallbackWindow)
            window->Viewport = window->ParentWindow->Viewport;

        // Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
        if (window->Viewport == NULL && window->ViewportId != 0)
        {
            window->Viewport = (ImGuiViewportP*)FindViewportByID(window->ViewportId);
            if (window->Viewport == NULL && window->ViewportPos.x != FLT_MAX && window->ViewportPos.y != FLT_MAX)
                window->Viewport = AddUpdateViewport(window, window->ID, window->ViewportPos, window->Size, ImGuiViewportFlags_None);
        }
    }

    bool lock_viewport = false;
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport)
    {
        // Code explicitly request a viewport
        window->Viewport = (ImGuiViewportP*)FindViewportByID(g.NextWindowData.ViewportId);
        window->ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
        lock_viewport = true;
    }
    else if ((flags & ImGuiWindowFlags_ChildWindow) || (flags & ImGuiWindowFlags_ChildMenu))
    {
        // Always inherit viewport from parent window
        window->Viewport = window->ParentWindow->Viewport;
    }
    else if (flags & ImGuiWindowFlags_Tooltip)
    {
        window->Viewport = g.MouseViewport;
    }
    else if (GetWindowAlwaysWantOwnViewport(window))
    {
        window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
    }
    else if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window && IsMousePosValid())
    {
        if (window->Viewport != NULL && window->Viewport->Window == window)
            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
    }
    else
    {
        // Merge into host viewport?
        // We cannot test window->ViewportOwned as it set lower in the function.
        bool try_to_merge_into_host_viewport = (window->Viewport && window == window->Viewport->Window && g.ActiveId == 0);
        if (try_to_merge_into_host_viewport)
            UpdateTryMergeWindowIntoHostViewports(window);
    }

    // Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
    if (window->Viewport == NULL)
        if (!UpdateTryMergeWindowIntoHostViewport(window, main_viewport))
            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);

    // Mark window as allowed to protrude outside of its viewport and into the current monitor
    if (!lock_viewport)
    {
        if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        {
            // We need to take account of the possibility that mouse may become invalid.
            // Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
            ImVec2 mouse_ref = (flags & ImGuiWindowFlags_Tooltip) ? g.IO.MousePos : g.BeginPopupStack.back().OpenMousePos;
            bool use_mouse_ref = (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow);
            bool mouse_valid = IsMousePosValid(&mouse_ref);
            if ((window->Appearing || (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid))
                window->ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos());
            else
                window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
        }
        else if (window->Viewport && window != window->Viewport->Window && window->Viewport->Window && !(flags & ImGuiWindowFlags_ChildWindow))
        {
            // When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
            const bool will_be_visible = (window->DockIsActive && !window->DockTabIsVisible) ? false : true;
            if ((window->Flags & ImGuiWindowFlags_DockNodeHost) && window->Viewport->LastFrameActive < g.FrameCount && will_be_visible)
            {
                // Steal/transfer ownership
                IMGUI_DEBUG_LOG_VIEWPORT("Window '%s' steal Viewport %08X from Window '%s'\n", window->Name, window->Viewport->ID, window->Viewport->Window->Name);
                window->Viewport->Window = window;
                window->Viewport->ID = window->ID;
                window->Viewport->LastNameHash = 0;
            }
            else if (!UpdateTryMergeWindowIntoHostViewports(window)) // Merge?
            {
                // New viewport
                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
            }
        }
        else if (window->ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_ChildWindow) == 0)
        {
            // Regular (non-child, non-popup) windows by default are also allowed to protrude
            // Child windows are kept contained within their parent.
            window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
        }
    }

    // Update flags
    window->ViewportOwned = (window == window->Viewport->Window);
    window->ViewportId = window->Viewport->ID;

    // If the OS window has a title bar, hide our imgui title bar
    //if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
    //    window->Flags |= ImGuiWindowFlags_NoTitleBar;
}

// Called by user at the end of the main loop, after EndFrame()
// This will handle the creation/update of all OS windows via function defined in the ImGuiPlatformIO api.
void ImGui::UpdatePlatformWindows()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.FrameCountEnded == g.FrameCount && "Forgot to call Render() or EndFrame() before UpdatePlatformWindows()?");
    IM_ASSERT(g.FrameCountPlatformEnded < g.FrameCount);
    g.FrameCountPlatformEnded = g.FrameCount;
    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
        return;

    // Create/resize/destroy platform windows to match each active viewport.
    // Skip the main viewport (index 0), which is always fully handled by the application!
    for (int i = 1; i < g.Viewports.Size; i++)
    {
        ImGuiViewportP* viewport = g.Viewports[i];

        // Destroy platform window if the viewport hasn't been submitted or if it is hosting a hidden window
        // (the implicit/fallback Debug##Default window will be registering its viewport then be disabled, causing a dummy DestroyPlatformWindow to be made each frame)
        bool destroy_platform_window = false;
        destroy_platform_window |= (viewport->LastFrameActive < g.FrameCount - 1);
        destroy_platform_window |= (viewport->Window && !IsWindowActiveAndVisible(viewport->Window));
        if (destroy_platform_window)
        {
            DestroyPlatformWindow(viewport);
            continue;
        }

        // New windows that appears directly in a new viewport won't always have a size on their first frame
        if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0 || viewport->Size.y <= 0)
            continue;

        // Create window
        bool is_new_platform_window = (viewport->PlatformWindowCreated == false);
        if (is_new_platform_window)
        {
            IMGUI_DEBUG_LOG_VIEWPORT("Create Platform Window %08X (%s)\n", viewport->ID, viewport->Window ? viewport->Window->Name : "n/a");
            g.PlatformIO.Platform_CreateWindow(viewport);
            if (g.PlatformIO.Renderer_CreateWindow != NULL)
                g.PlatformIO.Renderer_CreateWindow(viewport);
            viewport->LastNameHash = 0;
            viewport->LastPlatformPos = viewport->LastPlatformSize = ImVec2(FLT_MAX, FLT_MAX); // By clearing those we'll enforce a call to Platform_SetWindowPos/Size below, before Platform_ShowWindow (FIXME: Is that necessary?)
            viewport->LastRendererSize = viewport->Size;                                       // We don't need to call Renderer_SetWindowSize() as it is expected Renderer_CreateWindow() already did it.
            viewport->PlatformWindowCreated = true;
        }

        // Apply Position and Size (from ImGui to Platform/Renderer backends)
        if ((viewport->LastPlatformPos.x != viewport->Pos.x || viewport->LastPlatformPos.y != viewport->Pos.y) && !viewport->PlatformRequestMove)
            g.PlatformIO.Platform_SetWindowPos(viewport, viewport->Pos);
        if ((viewport->LastPlatformSize.x != viewport->Size.x || viewport->LastPlatformSize.y != viewport->Size.y) && !viewport->PlatformRequestResize)
            g.PlatformIO.Platform_SetWindowSize(viewport, viewport->Size);
        if ((viewport->LastRendererSize.x != viewport->Size.x || viewport->LastRendererSize.y != viewport->Size.y) && g.PlatformIO.Renderer_SetWindowSize)
            g.PlatformIO.Renderer_SetWindowSize(viewport, viewport->Size);
        viewport->LastPlatformPos = viewport->Pos;
        viewport->LastPlatformSize = viewport->LastRendererSize = viewport->Size;

        // Update title bar (if it changed)
        if (ImGuiWindow* window_for_title = GetWindowForTitleDisplay(viewport->Window))
        {
            const char* title_begin = window_for_title->Name;
            char* title_end = (char*)(intptr_t)FindRenderedTextEnd(title_begin);
            const ImGuiID title_hash = ImHashStr(title_begin, title_end - title_begin);
            if (viewport->LastNameHash != title_hash)
            {
                char title_end_backup_c = *title_end;
                *title_end = 0; // Cut existing buffer short instead of doing an alloc/free, no small gain.
                g.PlatformIO.Platform_SetWindowTitle(viewport, title_begin);
                *title_end = title_end_backup_c;
                viewport->LastNameHash = title_hash;
            }
        }

        // Update alpha (if it changed)
        if (viewport->LastAlpha != viewport->Alpha && g.PlatformIO.Platform_SetWindowAlpha)
            g.PlatformIO.Platform_SetWindowAlpha(viewport, viewport->Alpha);
        viewport->LastAlpha = viewport->Alpha;

        // Optional, general purpose call to allow the backend to perform general book-keeping even if things haven't changed.
        if (g.PlatformIO.Platform_UpdateWindow)
            g.PlatformIO.Platform_UpdateWindow(viewport);

        if (is_new_platform_window)
        {
            // On startup ensure new platform window don't steal focus (give it a few frames, as nested contents may lead to viewport being created a few frames late)
            if (g.FrameCount < 3)
                viewport->Flags |= ImGuiViewportFlags_NoFocusOnAppearing;

            // Show window
            g.PlatformIO.Platform_ShowWindow(viewport);

            // Even without focus, we assume the window becomes front-most.
            // This is useful for our platform z-order heuristic when io.MouseHoveredViewport is not available.
            if (viewport->LastFrontMostStampCount != g.ViewportFrontMostStampCount)
                viewport->LastFrontMostStampCount = ++g.ViewportFrontMostStampCount;
            }

        // Clear request flags
        viewport->ClearRequestFlags();
    }

    // Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
    // When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
    // FIXME-VIEWPORT: We should use this information to also set dear imgui-side focus, allowing us to handle os-level alt+tab.
    if (g.PlatformIO.Platform_GetWindowFocus != NULL)
    {
        ImGuiViewportP* focused_viewport = NULL;
        for (int n = 0; n < g.Viewports.Size && focused_viewport == NULL; n++)
        {
            ImGuiViewportP* viewport = g.Viewports[n];
            if (viewport->PlatformWindowCreated)
                if (g.PlatformIO.Platform_GetWindowFocus(viewport))
                    focused_viewport = viewport;
        }

        // Store a tag so we can infer z-order easily from all our windows
        // We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
        // will keep the front most stamp instead of losing it back to their parent viewport.
        if (focused_viewport && g.PlatformLastFocusedViewportId != focused_viewport->ID)
        {
            if (focused_viewport->LastFrontMostStampCount != g.ViewportFrontMostStampCount)
                focused_viewport->LastFrontMostStampCount = ++g.ViewportFrontMostStampCount;
            g.PlatformLastFocusedViewportId = focused_viewport->ID;
        }
    }
}

// This is a default/basic function for performing the rendering/swap of multiple Platform Windows.
// Custom renderers may prefer to not call this function at all, and instead iterate the publicly exposed platform data and handle rendering/sync themselves.
// The Render/Swap functions stored in ImGuiPlatformIO are merely here to allow for this helper to exist, but you can do it yourself:
//
//    ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
//    for (int i = 1; i < platform_io.Viewports.Size; i++)
//        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
//            MyRenderFunction(platform_io.Viewports[i], my_args);
//    for (int i = 1; i < platform_io.Viewports.Size; i++)
//        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
//            MySwapBufferFunction(platform_io.Viewports[i], my_args);
//
void ImGui::RenderPlatformWindowsDefault(void* platform_render_arg, void* renderer_render_arg)
{
    // Skip the main viewport (index 0), which is always fully handled by the application!
    ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
    for (int i = 1; i < platform_io.Viewports.Size; i++)
    {
        ImGuiViewport* viewport = platform_io.Viewports[i];
        if (viewport->Flags & ImGuiViewportFlags_Minimized)
            continue;
        if (platform_io.Platform_RenderWindow) platform_io.Platform_RenderWindow(viewport, platform_render_arg);
        if (platform_io.Renderer_RenderWindow) platform_io.Renderer_RenderWindow(viewport, renderer_render_arg);
    }
    for (int i = 1; i < platform_io.Viewports.Size; i++)
    {
        ImGuiViewport* viewport = platform_io.Viewports[i];
        if (viewport->Flags & ImGuiViewportFlags_Minimized)
            continue;
        if (platform_io.Platform_SwapBuffers) platform_io.Platform_SwapBuffers(viewport, platform_render_arg);
        if (platform_io.Renderer_SwapBuffers) platform_io.Renderer_SwapBuffers(viewport, renderer_render_arg);
    }
}

static int ImGui::FindPlatformMonitorForPos(const ImVec2& pos)
{
    ImGuiContext& g = *GImGui;
    for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size; monitor_n++)
    {
        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
        if (ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize).Contains(pos))
            return monitor_n;
    }
    return -1;
}

// Search for the monitor with the largest intersection area with the given rectangle
// We generally try to avoid searching loops but the monitor count should be very small here
// FIXME-OPT: We could test the last monitor used for that viewport first, and early
static int ImGui::FindPlatformMonitorForRect(const ImRect& rect)
{
    ImGuiContext& g = *GImGui;

    const int monitor_count = g.PlatformIO.Monitors.Size;
    if (monitor_count <= 1)
        return monitor_count - 1;

    // Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
    // This is necessary for tooltips which always resize down to zero at first.
    const float surface_threshold = ImMax(rect.GetWidth() * rect.GetHeight() * 0.5f, 1.0f);
    int best_monitor_n = -1;
    float best_monitor_surface = 0.001f;

    for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; monitor_n++)
    {
        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
        const ImRect monitor_rect = ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize);
        if (monitor_rect.Contains(rect))
            return monitor_n;
        ImRect overlapping_rect = rect;
        overlapping_rect.ClipWithFull(monitor_rect);
        float overlapping_surface = overlapping_rect.GetWidth() * overlapping_rect.GetHeight();
        if (overlapping_surface < best_monitor_surface)
            continue;
        best_monitor_surface = overlapping_surface;
        best_monitor_n = monitor_n;
    }
    return best_monitor_n;
}

// Update monitor from viewport rectangle (we'll use this info to clamp windows and save windows lost in a removed monitor)
static void ImGui::UpdateViewportPlatformMonitor(ImGuiViewportP* viewport)
{
    viewport->PlatformMonitor = (short)FindPlatformMonitorForRect(viewport->GetMainRect());
}

// Return value is always != NULL, but don't hold on it across frames.
const ImGuiPlatformMonitor* ImGui::GetViewportPlatformMonitor(ImGuiViewport* viewport_p)
{
    ImGuiContext& g = *GImGui;
    ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)viewport_p;
    int monitor_idx = viewport->PlatformMonitor;
    if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
        return &g.PlatformIO.Monitors[monitor_idx];
    return &g.FallbackMonitor;
}

void ImGui::DestroyPlatformWindow(ImGuiViewportP* viewport)
{
    ImGuiContext& g = *GImGui;
    if (viewport->PlatformWindowCreated)
    {
        if (g.PlatformIO.Renderer_DestroyWindow)
            g.PlatformIO.Renderer_DestroyWindow(viewport);
        if (g.PlatformIO.Platform_DestroyWindow)
            g.PlatformIO.Platform_DestroyWindow(viewport);
        IM_ASSERT(viewport->RendererUserData == NULL && viewport->PlatformUserData == NULL);

        // Don't clear PlatformWindowCreated for the main viewport, as we initially set that up to true in Initialize()
        // The righter way may be to leave it to the backend to set this flag all-together, and made the flag public.
        if (viewport->ID != IMGUI_VIEWPORT_DEFAULT_ID)
            viewport->PlatformWindowCreated = false;
    }
    else
    {
        IM_ASSERT(viewport->RendererUserData == NULL && viewport->PlatformUserData == NULL && viewport->PlatformHandle == NULL);
    }
    viewport->RendererUserData = viewport->PlatformUserData = viewport->PlatformHandle = NULL;
    viewport->ClearRequestFlags();
}

void ImGui::DestroyPlatformWindows()
{
    // We call the destroy window on every viewport (including the main viewport, index 0) to give a chance to the backend
    // to clear any data they may have stored in e.g. PlatformUserData, RendererUserData.
    // It is convenient for the platform backend code to store something in the main viewport, in order for e.g. the mouse handling
    // code to operator a consistent manner.
    // It is expected that the backend can handle calls to Renderer_DestroyWindow/Platform_DestroyWindow without
    // crashing if it doesn't have data stored.
    ImGuiContext& g = *GImGui;
    for (int i = 0; i < g.Viewports.Size; i++)
        DestroyPlatformWindow(g.Viewports[i]);
}


//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------
// Docking: Internal Types
// Docking: Forward Declarations
// Docking: ImGuiDockContext
// Docking: ImGuiDockContext Docking/Undocking functions
// Docking: ImGuiDockNode
// Docking: ImGuiDockNode Tree manipulation functions
// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
// Docking: Builder Functions
// Docking: Begin/End Support Functions (called from Begin/End)
// Docking: Settings
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical Docking call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - NewFrame()                               new dear imgui frame
//    | DockContextNewFrameUpdateUndocking()  - process queued undocking requests
//    | - DockContextProcessUndockWindow()    - process one window undocking request
//    | - DockContextProcessUndockNode()      - process one whole node undocking request
//    | DockContextNewFrameUpdateUndocking()  - process queue docking requests, create floating dock nodes
//    | - update g.HoveredDockNode            - [debug] update node hovered by mouse
//    | - DockContextProcessDock()            - process one docking request
//    | - DockNodeUpdate()
//    |   - DockNodeUpdateForRootNode()
//    |     - DockNodeUpdateVisibleFlagAndInactiveChilds()
//    |     - DockNodeFindInfo()
//    |   - destroy unused node or tab bar
//    |   - create dock node host window
//    |      - Begin() etc.
//    |   - DockNodeStartMouseMovingWindow()
//    |   - DockNodeTreeUpdatePosSize()
//    |   - DockNodeTreeUpdateSplitter()
//    |   - draw node background
//    |   - DockNodeUpdateTabBar()            - create/update tab bar for a docking node
//    |     - DockNodeAddTabBar()
//    |     - DockNodeUpdateWindowMenu()
//    |     - DockNodeCalcTabBarLayout()
//    |     - BeginTabBarEx()
//    |     - TabItemEx() calls
//    |     - EndTabBar()
//    |   - BeginDockableDragDropTarget()
//    |      - DockNodeUpdate()               - recurse into child nodes...
//-----------------------------------------------------------------------------
// - DockSpace()                              user submit a dockspace into a window
//    | Begin(Child)                          - create a child window
//    | DockNodeUpdate()                      - call main dock node update function
//    | End(Child)
//    | ItemSize()
//-----------------------------------------------------------------------------
// - Begin()
//    | BeginDocked()
//    | BeginDockableDragDropSource()
//    | BeginDockableDragDropTarget()
//    | - DockNodePreviewDockRender()
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Docking: Internal Types
//-----------------------------------------------------------------------------
// - ImGuiDockRequestType
// - ImGuiDockRequest
// - ImGuiDockPreviewData
// - ImGuiDockNodeSettings
// - ImGuiDockContext
//-----------------------------------------------------------------------------

enum ImGuiDockRequestType
{
    ImGuiDockRequestType_None = 0,
    ImGuiDockRequestType_Dock,
    ImGuiDockRequestType_Undock,
    ImGuiDockRequestType_Split                  // Split is the same as Dock but without a DockPayload
};

struct ImGuiDockRequest
{
    ImGuiDockRequestType    Type;
    ImGuiWindow*            DockTargetWindow;   // Destination/Target Window to dock into (may be a loose window or a DockNode, might be NULL in which case DockTargetNode cannot be NULL)
    ImGuiDockNode*          DockTargetNode;     // Destination/Target Node to dock into
    ImGuiWindow*            DockPayload;        // Source/Payload window to dock (may be a loose window or a DockNode), [Optional]
    ImGuiDir                DockSplitDir;
    float                   DockSplitRatio;
    bool                    DockSplitOuter;
    ImGuiWindow*            UndockTargetWindow;
    ImGuiDockNode*          UndockTargetNode;

    ImGuiDockRequest()
    {
        Type = ImGuiDockRequestType_None;
        DockTargetWindow = DockPayload = UndockTargetWindow = NULL;
        DockTargetNode = UndockTargetNode = NULL;
        DockSplitDir = ImGuiDir_None;
        DockSplitRatio = 0.5f;
        DockSplitOuter = false;
    }
};

struct ImGuiDockPreviewData
{
    ImGuiDockNode   FutureNode;
    bool            IsDropAllowed;
    bool            IsCenterAvailable;
    bool            IsSidesAvailable;           // Hold your breath, grammar freaks..
    bool            IsSplitDirExplicit;         // Set when hovered the drop rect (vs. implicit SplitDir==None when hovered the window)
    ImGuiDockNode*  SplitNode;
    ImGuiDir        SplitDir;
    float           SplitRatio;
    ImRect          DropRectsDraw[ImGuiDir_COUNT + 1];  // May be slightly different from hit-testing drop rects used in DockNodeCalcDropRects()

    ImGuiDockPreviewData() : FutureNode(0) { IsDropAllowed = IsCenterAvailable = IsSidesAvailable = IsSplitDirExplicit = false; SplitNode = NULL; SplitDir = ImGuiDir_None; SplitRatio = 0.f; for (int n = 0; n < IM_ARRAYSIZE(DropRectsDraw); n++) DropRectsDraw[n] = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX); }
};

// Persistent Settings data, stored contiguously in SettingsNodes (sizeof() ~32 bytes)
struct ImGuiDockNodeSettings
{
    ImGuiID             ID;
    ImGuiID             ParentNodeId;
    ImGuiID             ParentWindowId;
    ImGuiID             SelectedTabId;
    signed char         SplitAxis;
    char                Depth;
    ImGuiDockNodeFlags  Flags;                  // NB: We save individual flags one by one in ascii format (ImGuiDockNodeFlags_SavedFlagsMask_)
    ImVec2ih            Pos;
    ImVec2ih            Size;
    ImVec2ih            SizeRef;
    ImGuiDockNodeSettings() { memset(this, 0, sizeof(*this)); SplitAxis = ImGuiAxis_None; }
};

//-----------------------------------------------------------------------------
// Docking: Forward Declarations
//-----------------------------------------------------------------------------

namespace ImGui
{
    // ImGuiDockContext
    static ImGuiDockNode*   DockContextAddNode(ImGuiContext* ctx, ImGuiID id);
    static void             DockContextRemoveNode(ImGuiContext* ctx, ImGuiDockNode* node, bool merge_sibling_into_parent_node);
    static void             DockContextQueueNotifyRemovedNode(ImGuiContext* ctx, ImGuiDockNode* node);
    static void             DockContextProcessDock(ImGuiContext* ctx, ImGuiDockRequest* req);
    static void             DockContextProcessUndockWindow(ImGuiContext* ctx, ImGuiWindow* window, bool clear_persistent_docking_ref = true);
    static void             DockContextProcessUndockNode(ImGuiContext* ctx, ImGuiDockNode* node);
    static void             DockContextPruneUnusedSettingsNodes(ImGuiContext* ctx);
    static ImGuiDockNode*   DockContextFindNodeByID(ImGuiContext* ctx, ImGuiID id);
    static ImGuiDockNode*   DockContextBindNodeToWindow(ImGuiContext* ctx, ImGuiWindow* window);
    static void             DockContextBuildNodesFromSettings(ImGuiContext* ctx, ImGuiDockNodeSettings* node_settings_array, int node_settings_count);
    static void             DockContextBuildAddWindowsToNodes(ImGuiContext* ctx, ImGuiID root_id);                            // Use root_id==0 to add all

    // ImGuiDockNode
    static void             DockNodeAddWindow(ImGuiDockNode* node, ImGuiWindow* window, bool add_to_tab_bar);
    static void             DockNodeMoveWindows(ImGuiDockNode* dst_node, ImGuiDockNode* src_node);
    static void             DockNodeMoveChildNodes(ImGuiDockNode* dst_node, ImGuiDockNode* src_node);
    static ImGuiWindow*     DockNodeFindWindowByID(ImGuiDockNode* node, ImGuiID id);
    static void             DockNodeApplyPosSizeToWindows(ImGuiDockNode* node);
    static void             DockNodeRemoveWindow(ImGuiDockNode* node, ImGuiWindow* window, ImGuiID save_dock_id);
    static void             DockNodeHideHostWindow(ImGuiDockNode* node);
    static void             DockNodeUpdate(ImGuiDockNode* node);
    static void             DockNodeUpdateForRootNode(ImGuiDockNode* node);
    static void             DockNodeUpdateVisibleFlagAndInactiveChilds(ImGuiDockNode* node);
    static void             DockNodeUpdateTabBar(ImGuiDockNode* node, ImGuiWindow* host_window);
    static void             DockNodeAddTabBar(ImGuiDockNode* node);
    static void             DockNodeRemoveTabBar(ImGuiDockNode* node);
    static ImGuiID          DockNodeUpdateWindowMenu(ImGuiDockNode* node, ImGuiTabBar* tab_bar);
    static void             DockNodeUpdateVisibleFlag(ImGuiDockNode* node);
    static void             DockNodeStartMouseMovingWindow(ImGuiDockNode* node, ImGuiWindow* window);
    static bool             DockNodeIsDropAllowed(ImGuiWindow* host_window, ImGuiWindow* payload_window);
    static void             DockNodePreviewDockSetup(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* payload_window, ImGuiDockPreviewData* preview_data, bool is_explicit_target, bool is_outer_docking);
    static void             DockNodePreviewDockRender(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* payload_window, const ImGuiDockPreviewData* preview_data);
    static void             DockNodeCalcTabBarLayout(const ImGuiDockNode* node, ImRect* out_title_rect, ImRect* out_tab_bar_rect, ImVec2* out_window_menu_button_pos);
    static void             DockNodeCalcSplitRects(ImVec2& pos_old, ImVec2& size_old, ImVec2& pos_new, ImVec2& size_new, ImGuiDir dir, ImVec2 size_new_desired);
    static bool             DockNodeCalcDropRectsAndTestMousePos(const ImRect& parent, ImGuiDir dir, ImRect& out_draw, bool outer_docking, ImVec2* test_mouse_pos);
    static const char*      DockNodeGetHostWindowTitle(ImGuiDockNode* node, char* buf, int buf_size) { ImFormatString(buf, buf_size, "##DockNode_%02X", node->ID); return buf; }
    static int              DockNodeGetTabOrder(ImGuiWindow* window);

    // ImGuiDockNode tree manipulations
    static void             DockNodeTreeSplit(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiAxis split_axis, int split_first_child, float split_ratio, ImGuiDockNode* new_node);
    static void             DockNodeTreeMerge(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiDockNode* merge_lead_child);
    static void             DockNodeTreeUpdatePosSize(ImGuiDockNode* node, ImVec2 pos, ImVec2 size, bool only_write_to_marked_nodes = false);
    static void             DockNodeTreeUpdateSplitter(ImGuiDockNode* node);
    static ImGuiDockNode*   DockNodeTreeFindVisibleNodeByPos(ImGuiDockNode* node, ImVec2 pos);
    static ImGuiDockNode*   DockNodeTreeFindFallbackLeafNode(ImGuiDockNode* node);

    // Settings
    static void             DockSettingsRenameNodeReferences(ImGuiID old_node_id, ImGuiID new_node_id);
    static void             DockSettingsRemoveNodeReferences(ImGuiID* node_ids, int node_ids_count);
    static ImGuiDockNodeSettings*   DockSettingsFindNodeSettings(ImGuiContext* ctx, ImGuiID node_id);
    static void             DockSettingsHandler_ClearAll(ImGuiContext*, ImGuiSettingsHandler*);
    static void             DockSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*);
    static void*            DockSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);
    static void             DockSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);
    static void             DockSettingsHandler_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf);
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockContext
//-----------------------------------------------------------------------------
// The lifetime model is different from the one of regular windows: we always create a ImGuiDockNode for each ImGuiDockNodeSettings,
// or we always hold the entire docking node tree. Nodes are frequently hidden, e.g. if the window(s) or child nodes they host are not active.
// At boot time only, we run a simple GC to remove nodes that have no references.
// Because dock node settings (which are small, contiguous structures) are always mirrored by their corresponding dock nodes (more complete structures),
// we can also very easily recreate the nodes from scratch given the settings data (this is what DockContextRebuild() does).
// This is convenient as docking reconfiguration can be implemented by mostly poking at the simpler settings data.
//-----------------------------------------------------------------------------
// - DockContextInitialize()
// - DockContextShutdown()
// - DockContextClearNodes()
// - DockContextRebuildNodes()
// - DockContextNewFrameUpdateUndocking()
// - DockContextNewFrameUpdateDocking()
// - DockContextFindNodeByID()
// - DockContextBindNodeToWindow()
// - DockContextGenNodeID()
// - DockContextAddNode()
// - DockContextRemoveNode()
// - ImGuiDockContextPruneNodeData
// - DockContextPruneUnusedSettingsNodes()
// - DockContextBuildNodesFromSettings()
// - DockContextBuildAddWindowsToNodes()
//-----------------------------------------------------------------------------

void ImGui::DockContextInitialize(ImGuiContext* ctx)
{
    ImGuiContext& g = *ctx;

    // Add .ini handle for persistent docking data
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = "Docking";
    ini_handler.TypeHash = ImHashStr("Docking");
    ini_handler.ClearAllFn = DockSettingsHandler_ClearAll;
    ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
    ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen;
    ini_handler.ReadLineFn = DockSettingsHandler_ReadLine;
    ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll;
    ini_handler.WriteAllFn = DockSettingsHandler_WriteAll;
    g.SettingsHandlers.push_back(ini_handler);
}

void ImGui::DockContextShutdown(ImGuiContext* ctx)
{
    ImGuiDockContext* dc  = &ctx->DockContext;
    for (int n = 0; n < dc->Nodes.Data.Size; n++)
        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
            IM_DELETE(node);
}

void ImGui::DockContextClearNodes(ImGuiContext* ctx, ImGuiID root_id, bool clear_settings_refs)
{
    IM_UNUSED(ctx);
    IM_ASSERT(ctx == GImGui);
    DockBuilderRemoveNodeDockedWindows(root_id, clear_settings_refs);
    DockBuilderRemoveNodeChildNodes(root_id);
}

// [DEBUG] This function also acts as a defacto test to make sure we can rebuild from scratch without a glitch
// (Different from DockSettingsHandler_ClearAll() + DockSettingsHandler_ApplyAll() because this reuses current settings!)
void ImGui::DockContextRebuildNodes(ImGuiContext* ctx)
{
    IMGUI_DEBUG_LOG_DOCKING("DockContextRebuild()\n");
    ImGuiDockContext* dc  = &ctx->DockContext;
    SaveIniSettingsToMemory();
    ImGuiID root_id = 0; // Rebuild all
    DockContextClearNodes(ctx, root_id, false);
    DockContextBuildNodesFromSettings(ctx, dc->NodesSettings.Data, dc->NodesSettings.Size);
    DockContextBuildAddWindowsToNodes(ctx, root_id);
}

// Docking context update function, called by NewFrame()
void ImGui::DockContextNewFrameUpdateUndocking(ImGuiContext* ctx)
{
    ImGuiContext& g = *ctx;
    ImGuiDockContext* dc  = &ctx->DockContext;
    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
    {
        if (dc->Nodes.Data.Size > 0 || dc->Requests.Size > 0)
            DockContextClearNodes(ctx, 0, true);
        return;
    }

    // Setting NoSplit at runtime merges all nodes
    if (g.IO.ConfigDockingNoSplit)
        for (int n = 0; n < dc->Nodes.Data.Size; n++)
            if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
                if (node->IsRootNode() && node->IsSplitNode())
                {
                    DockBuilderRemoveNodeChildNodes(node->ID);
                    //dc->WantFullRebuild = true;
                }

    // Process full rebuild
#if 0
    if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
        dc->WantFullRebuild = true;
#endif
    if (dc->WantFullRebuild)
    {
        DockContextRebuildNodes(ctx);
        dc->WantFullRebuild = false;
    }

    // Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
    for (int n = 0; n < dc->Requests.Size; n++)
    {
        ImGuiDockRequest* req = &dc->Requests[n];
        if (req->Type == ImGuiDockRequestType_Undock && req->UndockTargetWindow)
            DockContextProcessUndockWindow(ctx, req->UndockTargetWindow);
        else if (req->Type == ImGuiDockRequestType_Undock && req->UndockTargetNode)
            DockContextProcessUndockNode(ctx, req->UndockTargetNode);
    }
}

// Docking context update function, called by NewFrame()
void ImGui::DockContextNewFrameUpdateDocking(ImGuiContext* ctx)
{
    ImGuiContext& g = *ctx;
    ImGuiDockContext* dc  = &ctx->DockContext;
    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        return;

    // [DEBUG] Store hovered dock node.
    // We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
    // Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
    g.HoveredDockNode = NULL;
    if (ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow)
    {
        if (hovered_window->DockNodeAsHost)
            g.HoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window->DockNodeAsHost, g.IO.MousePos);
        else if (hovered_window->RootWindow->DockNode)
            g.HoveredDockNode = hovered_window->RootWindow->DockNode;
    }

    // Process Docking requests
    for (int n = 0; n < dc->Requests.Size; n++)
        if (dc->Requests[n].Type == ImGuiDockRequestType_Dock)
            DockContextProcessDock(ctx, &dc->Requests[n]);
    dc->Requests.resize(0);

    // Create windows for each automatic docking nodes
    // We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
    for (int n = 0; n < dc->Nodes.Data.Size; n++)
        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
            if (node->IsFloatingNode())
                DockNodeUpdate(node);
}

static ImGuiDockNode* ImGui::DockContextFindNodeByID(ImGuiContext* ctx, ImGuiID id)
{
    return (ImGuiDockNode*)ctx->DockContext.Nodes.GetVoidPtr(id);
}

ImGuiID ImGui::DockContextGenNodeID(ImGuiContext* ctx)
{
    // Generate an ID for new node (the exact ID value doesn't matter as long as it is not already used)
    // FIXME-OPT FIXME-DOCK: This is suboptimal, even if the node count is small enough not to be a worry. We should poke in ctx->Nodes to find a suitable ID faster.
    ImGuiID id = 0x0001;
    while (DockContextFindNodeByID(ctx, id) != NULL)
        id++;
    return id;
}

static ImGuiDockNode* ImGui::DockContextAddNode(ImGuiContext* ctx, ImGuiID id)
{
    // Generate an ID for the new node (the exact ID value doesn't matter as long as it is not already used) and add the first window.
    if (id == 0)
        id = DockContextGenNodeID(ctx);
    else
        IM_ASSERT(DockContextFindNodeByID(ctx, id) == NULL);

    // We don't set node->LastFrameAlive on construction. Nodes are always created at all time to reflect .ini settings!
    IMGUI_DEBUG_LOG_DOCKING("DockContextAddNode 0x%08X\n", id);
    ImGuiDockNode* node = IM_NEW(ImGuiDockNode)(id);
    ctx->DockContext.Nodes.SetVoidPtr(node->ID, node);
    return node;
}

static void ImGui::DockContextRemoveNode(ImGuiContext* ctx, ImGuiDockNode* node, bool merge_sibling_into_parent_node)
{
    ImGuiContext& g = *ctx;
    ImGuiDockContext* dc  = &ctx->DockContext;

    IMGUI_DEBUG_LOG_DOCKING("DockContextRemoveNode 0x%08X\n", node->ID);
    IM_ASSERT(DockContextFindNodeByID(ctx, node->ID) == node);
    IM_ASSERT(node->ChildNodes[0] == NULL && node->ChildNodes[1] == NULL);
    IM_ASSERT(node->Windows.Size == 0);

    if (node->HostWindow)
        node->HostWindow->DockNodeAsHost = NULL;

    ImGuiDockNode* parent_node = node->ParentNode;
    const bool merge = (merge_sibling_into_parent_node && parent_node != NULL);
    if (merge)
    {
        IM_ASSERT(parent_node->ChildNodes[0] == node || parent_node->ChildNodes[1] == node);
        ImGuiDockNode* sibling_node = (parent_node->ChildNodes[0] == node ? parent_node->ChildNodes[1] : parent_node->ChildNodes[0]);
        DockNodeTreeMerge(&g, parent_node, sibling_node);
    }
    else
    {
        for (int n = 0; parent_node && n < IM_ARRAYSIZE(parent_node->ChildNodes); n++)
            if (parent_node->ChildNodes[n] == node)
                node->ParentNode->ChildNodes[n] = NULL;
        dc->Nodes.SetVoidPtr(node->ID, NULL);
        IM_DELETE(node);
    }
}

static int IMGUI_CDECL DockNodeComparerDepthMostFirst(const void* lhs, const void* rhs)
{
    const ImGuiDockNode* a = *(const ImGuiDockNode* const*)lhs;
    const ImGuiDockNode* b = *(const ImGuiDockNode* const*)rhs;
    return ImGui::DockNodeGetDepth(b) - ImGui::DockNodeGetDepth(a);
}

// Pre C++0x doesn't allow us to use a function-local type (without linkage) as template parameter, so we moved this here.
struct ImGuiDockContextPruneNodeData
{
    int         CountWindows, CountChildWindows, CountChildNodes;
    ImGuiID     RootId;
    ImGuiDockContextPruneNodeData() { CountWindows = CountChildWindows = CountChildNodes = 0; RootId = 0; }
};

// Garbage collect unused nodes (run once at init time)
static void ImGui::DockContextPruneUnusedSettingsNodes(ImGuiContext* ctx)
{
    ImGuiContext& g = *ctx;
    ImGuiDockContext* dc  = &ctx->DockContext;
    IM_ASSERT(g.Windows.Size == 0);

    ImPool<ImGuiDockContextPruneNodeData> pool;
    pool.Reserve(dc->NodesSettings.Size);

    // Count child nodes and compute RootID
    for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
    {
        ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
        ImGuiDockContextPruneNodeData* parent_data = settings->ParentNodeId ? pool.GetByKey(settings->ParentNodeId) : 0;
        pool.GetOrAddByKey(settings->ID)->RootId = parent_data ? parent_data->RootId : settings->ID;
        if (settings->ParentNodeId)
            pool.GetOrAddByKey(settings->ParentNodeId)->CountChildNodes++;
    }

    // Count reference to dock ids from dockspaces
    // We track the 'auto-DockNode <- manual-Window <- manual-DockSpace' in order to avoid 'auto-DockNode' being ditched by DockContextPruneUnusedSettingsNodes()
    for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
    {
        ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
        if (settings->ParentWindowId != 0)
            if (ImGuiWindowSettings* window_settings = FindWindowSettings(settings->ParentWindowId))
                if (window_settings->DockId)
                    if (ImGuiDockContextPruneNodeData* data = pool.GetByKey(window_settings->DockId))
                        data->CountChildNodes++;
    }

    // Count reference to dock ids from window settings
    // We guard against the possibility of an invalid .ini file (RootID may point to a missing node)
    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        if (ImGuiID dock_id = settings->DockId)
            if (ImGuiDockContextPruneNodeData* data = pool.GetByKey(dock_id))
            {
                data->CountWindows++;
                if (ImGuiDockContextPruneNodeData* data_root = (data->RootId == dock_id) ? data : pool.GetByKey(data->RootId))
                    data_root->CountChildWindows++;
            }

    // Prune
    for (int settings_n = 0; settings_n < dc->NodesSettings.Size; settings_n++)
    {
        ImGuiDockNodeSettings* settings = &dc->NodesSettings[settings_n];
        ImGuiDockContextPruneNodeData* data = pool.GetByKey(settings->ID);
        if (data->CountWindows > 1)
            continue;
        ImGuiDockContextPruneNodeData* data_root = (data->RootId == settings->ID) ? data : pool.GetByKey(data->RootId);

        bool remove = false;
        remove |= (data->CountWindows == 1 && settings->ParentNodeId == 0 && data->CountChildNodes == 0 && !(settings->Flags & ImGuiDockNodeFlags_CentralNode));  // Floating root node with only 1 window
        remove |= (data->CountWindows == 0 && settings->ParentNodeId == 0 && data->CountChildNodes == 0); // Leaf nodes with 0 window
        remove |= (data_root->CountChildWindows == 0);
        if (remove)
        {
            IMGUI_DEBUG_LOG_DOCKING("DockContextPruneUnusedSettingsNodes: Prune 0x%08X\n", settings->ID);
            DockSettingsRemoveNodeReferences(&settings->ID, 1);
            settings->ID = 0;
        }
    }
}

static void ImGui::DockContextBuildNodesFromSettings(ImGuiContext* ctx, ImGuiDockNodeSettings* node_settings_array, int node_settings_count)
{
    // Build nodes
    for (int node_n = 0; node_n < node_settings_count; node_n++)
    {
        ImGuiDockNodeSettings* settings = &node_settings_array[node_n];
        if (settings->ID == 0)
            continue;
        ImGuiDockNode* node = DockContextAddNode(ctx, settings->ID);
        node->ParentNode = settings->ParentNodeId ? DockContextFindNodeByID(ctx, settings->ParentNodeId) : NULL;
        node->Pos = ImVec2(settings->Pos.x, settings->Pos.y);
        node->Size = ImVec2(settings->Size.x, settings->Size.y);
        node->SizeRef = ImVec2(settings->SizeRef.x, settings->SizeRef.y);
        node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_DockNode;
        if (node->ParentNode && node->ParentNode->ChildNodes[0] == NULL)
            node->ParentNode->ChildNodes[0] = node;
        else if (node->ParentNode && node->ParentNode->ChildNodes[1] == NULL)
            node->ParentNode->ChildNodes[1] = node;
        node->SelectedTabId = settings->SelectedTabId;
        node->SplitAxis = (ImGuiAxis)settings->SplitAxis;
        node->LocalFlags |= (settings->Flags & ImGuiDockNodeFlags_SavedFlagsMask_);

        // Bind host window immediately if it already exist (in case of a rebuild)
        // This is useful as the RootWindowForTitleBarHighlight links necessary to highlight the currently focused node requires node->HostWindow to be set.
        char host_window_title[20];
        ImGuiDockNode* root_node = DockNodeGetRootNode(node);
        node->HostWindow = FindWindowByName(DockNodeGetHostWindowTitle(root_node, host_window_title, IM_ARRAYSIZE(host_window_title)));
    }
}

void ImGui::DockContextBuildAddWindowsToNodes(ImGuiContext* ctx, ImGuiID root_id)
{
    // Rebind all windows to nodes (they can also lazily rebind but we'll have a visible glitch during the first frame)
    ImGuiContext& g = *ctx;
    for (int n = 0; n < g.Windows.Size; n++)
    {
        ImGuiWindow* window = g.Windows[n];
        if (window->DockId == 0 || window->LastFrameActive < g.FrameCount - 1)
            continue;
        if (window->DockNode != NULL)
            continue;

        ImGuiDockNode* node = DockContextFindNodeByID(ctx, window->DockId);
        IM_ASSERT(node != NULL);   // This should have been called after DockContextBuildNodesFromSettings()
        if (root_id == 0 || DockNodeGetRootNode(node)->ID == root_id)
            DockNodeAddWindow(node, window, true);
    }
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockContext Docking/Undocking functions
//-----------------------------------------------------------------------------
// - DockContextQueueDock()
// - DockContextQueueUndockWindow()
// - DockContextQueueUndockNode()
// - DockContextQueueNotifyRemovedNode()
// - DockContextProcessDock()
// - DockContextProcessUndockWindow()
// - DockContextProcessUndockNode()
// - DockContextCalcDropPosForDocking()
//-----------------------------------------------------------------------------

void ImGui::DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* target_node, ImGuiWindow* payload, ImGuiDir split_dir, float split_ratio, bool split_outer)
{
    IM_ASSERT(target != payload);
    ImGuiDockRequest req;
    req.Type = ImGuiDockRequestType_Dock;
    req.DockTargetWindow = target;
    req.DockTargetNode = target_node;
    req.DockPayload = payload;
    req.DockSplitDir = split_dir;
    req.DockSplitRatio = split_ratio;
    req.DockSplitOuter = split_outer;
    ctx->DockContext.Requests.push_back(req);
}

void ImGui::DockContextQueueUndockWindow(ImGuiContext* ctx, ImGuiWindow* window)
{
    ImGuiDockRequest req;
    req.Type = ImGuiDockRequestType_Undock;
    req.UndockTargetWindow = window;
    ctx->DockContext.Requests.push_back(req);
}

void ImGui::DockContextQueueUndockNode(ImGuiContext* ctx, ImGuiDockNode* node)
{
    ImGuiDockRequest req;
    req.Type = ImGuiDockRequestType_Undock;
    req.UndockTargetNode = node;
    ctx->DockContext.Requests.push_back(req);
}

void ImGui::DockContextQueueNotifyRemovedNode(ImGuiContext* ctx, ImGuiDockNode* node)
{
    ImGuiDockContext* dc  = &ctx->DockContext;
    for (int n = 0; n < dc->Requests.Size; n++)
        if (dc->Requests[n].DockTargetNode == node)
            dc->Requests[n].Type = ImGuiDockRequestType_None;
}

void ImGui::DockContextProcessDock(ImGuiContext* ctx, ImGuiDockRequest* req)
{
    IM_ASSERT((req->Type == ImGuiDockRequestType_Dock && req->DockPayload != NULL) || (req->Type == ImGuiDockRequestType_Split && req->DockPayload == NULL));
    IM_ASSERT(req->DockTargetWindow != NULL || req->DockTargetNode != NULL);

    ImGuiContext& g = *ctx;
    IM_UNUSED(g);

    ImGuiWindow* payload_window = req->DockPayload;     // Optional
    ImGuiWindow* target_window = req->DockTargetWindow;
    ImGuiDockNode* node = req->DockTargetNode;
    if (payload_window)
        IMGUI_DEBUG_LOG_DOCKING("DockContextProcessDock node 0x%08X target '%s' dock window '%s', split_dir %d\n", node ? node->ID : 0, target_window ? target_window->Name : "NULL", payload_window ? payload_window->Name : "NULL", req->DockSplitDir);
    else
        IMGUI_DEBUG_LOG_DOCKING("DockContextProcessDock node 0x%08X, split_dir %d\n", node ? node->ID : 0, req->DockSplitDir);

    // Decide which Tab will be selected at the end of the operation
    ImGuiID next_selected_id = 0;
    ImGuiDockNode* payload_node = NULL;
    if (payload_window)
    {
        payload_node = payload_window->DockNodeAsHost;
        payload_window->DockNodeAsHost = NULL; // Important to clear this as the node will have its life as a child which might be merged/deleted later.
        if (payload_node && payload_node->IsLeafNode())
            next_selected_id = payload_node->TabBar->NextSelectedTabId ? payload_node->TabBar->NextSelectedTabId : payload_node->TabBar->SelectedTabId;
        if (payload_node == NULL)
            next_selected_id = payload_window->ID;
    }

    // FIXME-DOCK: When we are trying to dock an existing single-window node into a loose window, transfer Node ID as well
    // When processing an interactive split, usually LastFrameAlive will be < g.FrameCount. But DockBuilder operations can make it ==.
    if (node)
        IM_ASSERT(node->LastFrameAlive <= g.FrameCount);
    if (node && target_window && node == target_window->DockNodeAsHost)
        IM_ASSERT(node->Windows.Size > 0 || node->IsSplitNode() || node->IsCentralNode());

    // Create new node and add existing window to it
    if (node == NULL)
    {
        node = DockContextAddNode(ctx, 0);
        node->Pos = target_window->Pos;
        node->Size = target_window->Size;
        if (target_window->DockNodeAsHost == NULL)
        {
            DockNodeAddWindow(node, target_window, true);
            node->TabBar->Tabs[0].Flags &= ~ImGuiTabItemFlags_Unsorted;
            target_window->DockIsActive = true;
        }
    }

    ImGuiDir split_dir = req->DockSplitDir;
    if (split_dir != ImGuiDir_None)
    {
        // Split into two, one side will be our payload node unless we are dropping a loose window
        const ImGuiAxis split_axis = (split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
        const int split_inheritor_child_idx = (split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Up) ? 1 : 0; // Current contents will be moved to the opposite side
        const float split_ratio = req->DockSplitRatio;
        DockNodeTreeSplit(ctx, node, split_axis, split_inheritor_child_idx, split_ratio, payload_node);  // payload_node may be NULL here!
        ImGuiDockNode* new_node = node->ChildNodes[split_inheritor_child_idx ^ 1];
        new_node->HostWindow = node->HostWindow;
        node = new_node;
    }
    node->LocalFlags &= ~ImGuiDockNodeFlags_HiddenTabBar;

    if (node != payload_node)
    {
        // Create tab bar before we call DockNodeMoveWindows (which would attempt to move the old tab-bar, which would lead us to payload tabs wrongly appearing before target tabs!)
        if (node->Windows.Size > 0 && node->TabBar == NULL)
        {
            DockNodeAddTabBar(node);
            for (int n = 0; n < node->Windows.Size; n++)
                TabBarAddTab(node->TabBar, ImGuiTabItemFlags_None, node->Windows[n]);
        }

        if (payload_node != NULL)
        {
            // Transfer full payload node (with 1+ child windows or child nodes)
            if (payload_node->IsSplitNode())
            {
                if (node->Windows.Size > 0)
                {
                    // We can dock a split payload into a node that already has windows _only_ if our payload is a node tree with a single visible node.
                    // In this situation, we move the windows of the target node into the currently visible node of the payload.
                    // This allows us to preserve some of the underlying dock tree settings nicely.
                    IM_ASSERT(payload_node->OnlyNodeWithWindows != NULL); // The docking should have been blocked by DockNodePreviewDockSetup() early on and never submitted.
                    ImGuiDockNode* visible_node = payload_node->OnlyNodeWithWindows;
                    if (visible_node->TabBar)
                        IM_ASSERT(visible_node->TabBar->Tabs.Size > 0);
                    DockNodeMoveWindows(node, visible_node);
                    DockNodeMoveWindows(visible_node, node);
                    DockSettingsRenameNodeReferences(node->ID, visible_node->ID);
                }
                if (node->IsCentralNode())
                {
                    // Central node property needs to be moved to a leaf node, pick the last focused one.
                    // FIXME-DOCK: If we had to transfer other flags here, what would the policy be?
                    ImGuiDockNode* last_focused_node = DockContextFindNodeByID(ctx, payload_node->LastFocusedNodeId);
                    IM_ASSERT(last_focused_node != NULL);
                    ImGuiDockNode* last_focused_root_node = DockNodeGetRootNode(last_focused_node);
                    IM_ASSERT(last_focused_root_node == DockNodeGetRootNode(payload_node));
                    last_focused_node->LocalFlags |= ImGuiDockNodeFlags_CentralNode;
                    node->LocalFlags &= ~ImGuiDockNodeFlags_CentralNode;
                    last_focused_root_node->CentralNode = last_focused_node;
                }

                IM_ASSERT(node->Windows.Size == 0);
                DockNodeMoveChildNodes(node, payload_node);
            }
            else
            {
                const ImGuiID payload_dock_id = payload_node->ID;
                DockNodeMoveWindows(node, payload_node);
                DockSettingsRenameNodeReferences(payload_dock_id, node->ID);
            }
            DockContextRemoveNode(ctx, payload_node, true);
        }
        else if (payload_window)
        {
            // Transfer single window
            const ImGuiID payload_dock_id = payload_window->DockId;
            node->VisibleWindow = payload_window;
            DockNodeAddWindow(node, payload_window, true);
            if (payload_dock_id != 0)
                DockSettingsRenameNodeReferences(payload_dock_id, node->ID);
        }
    }
    else
    {
        // When docking a floating single window node we want to reevaluate auto-hiding of the tab bar
        node->WantHiddenTabBarUpdate = true;
    }

    // Update selection immediately
    if (ImGuiTabBar* tab_bar = node->TabBar)
        tab_bar->NextSelectedTabId = next_selected_id;
    MarkIniSettingsDirty();
}

// Problem:
//   Undocking a large (~full screen) window would leave it so large that the bottom right sizing corner would more
//   than likely be off the screen and the window would be hard to resize to fit on screen. This can be particularly problematic
//   with 'ConfigWindowsMoveFromTitleBarOnly=true' and/or with 'ConfigWindowsResizeFromEdges=false' as well (the later can be
//   due to missing ImGuiBackendFlags_HasMouseCursors backend flag).
// Solution:
//   When undocking a window we currently force its maximum size to 90% of the host viewport or monitor.
// Reevaluate this when we implement preserving docked/undocked size ("docking_wip/undocked_size" branch).
static ImVec2 FixLargeWindowsWhenUndocking(const ImVec2& size, ImGuiViewport* ref_viewport)
{
    if (ref_viewport == NULL)
        return size;

    ImGuiContext& g = *GImGui;
    ImVec2 max_size = ImFloor(ref_viewport->WorkSize * 0.90f);
    if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
    {
        const ImGuiPlatformMonitor* monitor = ImGui::GetViewportPlatformMonitor(ref_viewport);
        max_size = ImFloor(monitor->WorkSize * 0.90f);
    }
    return ImMin(size, max_size);
}

void ImGui::DockContextProcessUndockWindow(ImGuiContext* ctx, ImGuiWindow* window, bool clear_persistent_docking_ref)
{
    IMGUI_DEBUG_LOG_DOCKING("DockContextProcessUndockWindow window '%s', clear_persistent_docking_ref = %d\n", window->Name, clear_persistent_docking_ref);
    IM_UNUSED(ctx);
    if (window->DockNode)
        DockNodeRemoveWindow(window->DockNode, window, clear_persistent_docking_ref ? 0 : window->DockId);
    else
        window->DockId = 0;
    window->Collapsed = false;
    window->DockIsActive = false;
    window->DockTabIsVisible = false;
    window->Size = window->SizeFull = FixLargeWindowsWhenUndocking(window->SizeFull, window->Viewport);

    MarkIniSettingsDirty();
}

void ImGui::DockContextProcessUndockNode(ImGuiContext* ctx, ImGuiDockNode* node)
{
    IMGUI_DEBUG_LOG_DOCKING("DockContextProcessUndockNode node %08X\n", node->ID);
    IM_ASSERT(node->IsLeafNode());
    IM_ASSERT(node->Windows.Size >= 1);

    if (node->IsRootNode() || node->IsCentralNode())
    {
        // In the case of a root node or central node, the node will have to stay in place. Create a new node to receive the payload.
        ImGuiDockNode* new_node = DockContextAddNode(ctx, 0);
        new_node->Pos = node->Pos;
        new_node->Size = node->Size;
        new_node->SizeRef = node->SizeRef;
        DockNodeMoveWindows(new_node, node);
        DockSettingsRenameNodeReferences(node->ID, new_node->ID);
        for (int n = 0; n < new_node->Windows.Size; n++)
            UpdateWindowParentAndRootLinks(new_node->Windows[n], new_node->Windows[n]->Flags, NULL);
        node = new_node;
    }
    else
    {
        // Otherwise extract our node and merge our sibling back into the parent node.
        IM_ASSERT(node->ParentNode->ChildNodes[0] == node || node->ParentNode->ChildNodes[1] == node);
        int index_in_parent = (node->ParentNode->ChildNodes[0] == node) ? 0 : 1;
        node->ParentNode->ChildNodes[index_in_parent] = NULL;
        DockNodeTreeMerge(ctx, node->ParentNode, node->ParentNode->ChildNodes[index_in_parent ^ 1]);
        node->ParentNode->AuthorityForViewport = ImGuiDataAuthority_Window; // The node that stays in place keeps the viewport, so our newly dragged out node will create a new viewport
        node->ParentNode = NULL;
    }
    node->AuthorityForPos = node->AuthorityForSize = ImGuiDataAuthority_DockNode;
    node->Size = FixLargeWindowsWhenUndocking(node->Size, node->Windows[0]->Viewport);
    node->WantMouseMove = true;
    MarkIniSettingsDirty();
}

// This is mostly used for automation.
bool ImGui::DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* target_node, ImGuiWindow* payload, ImGuiDir split_dir, bool split_outer, ImVec2* out_pos)
{
    // In DockNodePreviewDockSetup() for a root central node instead of showing both "inner" and "outer" drop rects
    // (which would be functionally identical) we only show the outer one. Reflect this here.
    if (target_node && target_node->ParentNode == NULL && target_node->IsCentralNode() && split_dir != ImGuiDir_None)
        split_outer = true;
    ImGuiDockPreviewData split_data;
    DockNodePreviewDockSetup(target, target_node, payload, &split_data, false, split_outer);
    if (split_data.DropRectsDraw[split_dir+1].IsInverted())
        return false;
    *out_pos = split_data.DropRectsDraw[split_dir+1].GetCenter();
    return true;
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockNode
//-----------------------------------------------------------------------------
// - DockNodeGetTabOrder()
// - DockNodeAddWindow()
// - DockNodeRemoveWindow()
// - DockNodeMoveChildNodes()
// - DockNodeMoveWindows()
// - DockNodeApplyPosSizeToWindows()
// - DockNodeHideHostWindow()
// - ImGuiDockNodeFindInfoResults
// - DockNodeFindInfo()
// - DockNodeFindWindowByID()
// - DockNodeUpdateVisibleFlagAndInactiveChilds()
// - DockNodeUpdateVisibleFlag()
// - DockNodeStartMouseMovingWindow()
// - DockNodeUpdate()
// - DockNodeUpdateWindowMenu()
// - DockNodeBeginAmendTabBar()
// - DockNodeEndAmendTabBar()
// - DockNodeUpdateTabBar()
// - DockNodeAddTabBar()
// - DockNodeRemoveTabBar()
// - DockNodeIsDropAllowedOne()
// - DockNodeIsDropAllowed()
// - DockNodeCalcTabBarLayout()
// - DockNodeCalcSplitRects()
// - DockNodeCalcDropRectsAndTestMousePos()
// - DockNodePreviewDockSetup()
// - DockNodePreviewDockRender()
//-----------------------------------------------------------------------------

ImGuiDockNode::ImGuiDockNode(ImGuiID id)
{
    ID = id;
    SharedFlags = LocalFlags = ImGuiDockNodeFlags_None;
    ParentNode = ChildNodes[0] = ChildNodes[1] = NULL;
    TabBar = NULL;
    SplitAxis = ImGuiAxis_None;

    State = ImGuiDockNodeState_Unknown;
    HostWindow = VisibleWindow = NULL;
    CentralNode = OnlyNodeWithWindows = NULL;
    LastFrameAlive = LastFrameActive = LastFrameFocused = -1;
    LastFocusedNodeId = 0;
    SelectedTabId = 0;
    WantCloseTabId = 0;
    AuthorityForPos = AuthorityForSize = ImGuiDataAuthority_DockNode;
    AuthorityForViewport = ImGuiDataAuthority_Auto;
    IsVisible = true;
    IsFocused = HasCloseButton = HasWindowMenuButton = false;
    WantCloseAll = WantLockSizeOnce = WantMouseMove = WantHiddenTabBarUpdate = WantHiddenTabBarToggle = false;
    MarkedForPosSizeWrite = false;
}

ImGuiDockNode::~ImGuiDockNode()
{
    IM_DELETE(TabBar);
    TabBar = NULL;
    ChildNodes[0] = ChildNodes[1] = NULL;
}

int ImGui::DockNodeGetTabOrder(ImGuiWindow* window)
{
    ImGuiTabBar* tab_bar = window->DockNode->TabBar;
    if (tab_bar == NULL)
        return -1;
    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, window->ID);
    return tab ? tab_bar->GetTabOrder(tab) : -1;
}

static void DockNodeHideWindowDuringHostWindowCreation(ImGuiWindow* window)
{
    window->Hidden = true;
    window->HiddenFramesCanSkipItems = window->Active ? 1 : 2;
}

static void ImGui::DockNodeAddWindow(ImGuiDockNode* node, ImGuiWindow* window, bool add_to_tab_bar)
{
    ImGuiContext& g = *GImGui; (void)g;
    if (window->DockNode)
    {
        // Can overwrite an existing window->DockNode (e.g. pointing to a disabled DockSpace node)
        IM_ASSERT(window->DockNode->ID != node->ID);
        DockNodeRemoveWindow(window->DockNode, window, 0);
    }
    IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL);
    IMGUI_DEBUG_LOG_DOCKING("DockNodeAddWindow node 0x%08X window '%s'\n", node->ID, window->Name);

    // If more than 2 windows appeared on the same frame leading to the creation of a new hosting window,
    // we'll hide windows until the host window is ready. Hide the 1st window after its been output (so it is not visible for one frame).
    // We will call DockNodeHideWindowDuringHostWindowCreation() on ourselves in Begin()
    if (node->HostWindow == NULL && node->Windows.Size == 1 && node->Windows[0]->WasActive == false)
        DockNodeHideWindowDuringHostWindowCreation(node->Windows[0]);

    node->Windows.push_back(window);
    node->WantHiddenTabBarUpdate = true;
    window->DockNode = node;
    window->DockId = node->ID;
    window->DockIsActive = (node->Windows.Size > 1);
    window->DockTabWantClose = false;

    // When reactivating a node with one or two loose window, the window pos/size/viewport are authoritative over the node storage.
    // In particular it is important we init the viewport from the first window so we don't create two viewports and drop one.
    if (node->HostWindow == NULL && node->IsFloatingNode())
    {
        if (node->AuthorityForPos == ImGuiDataAuthority_Auto)
            node->AuthorityForPos = ImGuiDataAuthority_Window;
        if (node->AuthorityForSize == ImGuiDataAuthority_Auto)
            node->AuthorityForSize = ImGuiDataAuthority_Window;
        if (node->AuthorityForViewport == ImGuiDataAuthority_Auto)
            node->AuthorityForViewport = ImGuiDataAuthority_Window;
    }

    // Add to tab bar if requested
    if (add_to_tab_bar)
    {
        if (node->TabBar == NULL)
        {
            DockNodeAddTabBar(node);
            node->TabBar->SelectedTabId = node->TabBar->NextSelectedTabId = node->SelectedTabId;

            // Add existing windows
            for (int n = 0; n < node->Windows.Size - 1; n++)
                TabBarAddTab(node->TabBar, ImGuiTabItemFlags_None, node->Windows[n]);
        }
        TabBarAddTab(node->TabBar, ImGuiTabItemFlags_Unsorted, window);
    }

    DockNodeUpdateVisibleFlag(node);

    // Update this without waiting for the next time we Begin() in the window, so our host window will have the proper title bar color on its first frame.
    if (node->HostWindow)
        UpdateWindowParentAndRootLinks(window, window->Flags | ImGuiWindowFlags_ChildWindow, node->HostWindow);
}

static void ImGui::DockNodeRemoveWindow(ImGuiDockNode* node, ImGuiWindow* window, ImGuiID save_dock_id)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(window->DockNode == node);
    //IM_ASSERT(window->RootWindowDockTree == node->HostWindow);
    //IM_ASSERT(window->LastFrameActive < g.FrameCount);    // We may call this from Begin()
    IM_ASSERT(save_dock_id == 0 || save_dock_id == node->ID);
    IMGUI_DEBUG_LOG_DOCKING("DockNodeRemoveWindow node 0x%08X window '%s'\n", node->ID, window->Name);

    window->DockNode = NULL;
    window->DockIsActive = window->DockTabWantClose = false;
    window->DockId = save_dock_id;
    UpdateWindowParentAndRootLinks(window, window->Flags & ~ImGuiWindowFlags_ChildWindow, NULL); // Update immediately

    // Remove window
    bool erased = false;
    for (int n = 0; n < node->Windows.Size; n++)
        if (node->Windows[n] == window)
        {
            node->Windows.erase(node->Windows.Data + n);
            erased = true;
            break;
        }
    IM_ASSERT(erased);
    if (node->VisibleWindow == window)
        node->VisibleWindow = NULL;

    // Remove tab and possibly tab bar
    node->WantHiddenTabBarUpdate = true;
    if (node->TabBar)
    {
        TabBarRemoveTab(node->TabBar, window->ID);
        const int tab_count_threshold_for_tab_bar = node->IsCentralNode() ? 1 : 2;
        if (node->Windows.Size < tab_count_threshold_for_tab_bar)
            DockNodeRemoveTabBar(node);
    }

    if (node->Windows.Size == 0 && !node->IsCentralNode() && !node->IsDockSpace() && window->DockId != node->ID)
    {
        // Automatic dock node delete themselves if they are not holding at least one tab
        DockContextRemoveNode(&g, node, true);
        return;
    }

    if (node->Windows.Size == 1 && !node->IsCentralNode() && node->HostWindow)
    {
        ImGuiWindow* remaining_window = node->Windows[0];
        if (node->HostWindow->ViewportOwned && node->IsRootNode())
        {
            // Transfer viewport back to the remaining loose window
            IM_ASSERT(node->HostWindow->Viewport->Window == node->HostWindow);
            node->HostWindow->Viewport->Window = remaining_window;
            node->HostWindow->Viewport->ID = remaining_window->ID;
        }
        remaining_window->Collapsed = node->HostWindow->Collapsed;
    }

    // Update visibility immediately is required so the DockNodeUpdateRemoveInactiveChilds() processing can reflect changes up the tree
    DockNodeUpdateVisibleFlag(node);
}

static void ImGui::DockNodeMoveChildNodes(ImGuiDockNode* dst_node, ImGuiDockNode* src_node)
{
    IM_ASSERT(dst_node->Windows.Size == 0);
    dst_node->ChildNodes[0] = src_node->ChildNodes[0];
    dst_node->ChildNodes[1] = src_node->ChildNodes[1];
    if (dst_node->ChildNodes[0])
        dst_node->ChildNodes[0]->ParentNode = dst_node;
    if (dst_node->ChildNodes[1])
        dst_node->ChildNodes[1]->ParentNode = dst_node;
    dst_node->SplitAxis = src_node->SplitAxis;
    dst_node->SizeRef = src_node->SizeRef;
    src_node->ChildNodes[0] = src_node->ChildNodes[1] = NULL;
}

static void ImGui::DockNodeMoveWindows(ImGuiDockNode* dst_node, ImGuiDockNode* src_node)
{
    // Insert tabs in the same orders as currently ordered (node->Windows isn't ordered)
    IM_ASSERT(src_node && dst_node && dst_node != src_node);
    ImGuiTabBar* src_tab_bar = src_node->TabBar;
    if (src_tab_bar != NULL)
        IM_ASSERT(src_node->Windows.Size <= src_node->TabBar->Tabs.Size);

    // If the dst_node is empty we can just move the entire tab bar (to preserve selection, scrolling, etc.)
    bool move_tab_bar = (src_tab_bar != NULL) && (dst_node->TabBar == NULL);
    if (move_tab_bar)
    {
        dst_node->TabBar = src_node->TabBar;
        src_node->TabBar = NULL;
    }

    for (int n = 0; n < src_node->Windows.Size; n++)
    {
        // DockNode's TabBar may have non-window Tabs manually appended by user
        if (ImGuiWindow* window = src_tab_bar ? src_tab_bar->Tabs[n].Window : src_node->Windows[n])
        {
            window->DockNode = NULL;
            window->DockIsActive = false;
            DockNodeAddWindow(dst_node, window, move_tab_bar ? false : true);
        }
    }
    src_node->Windows.clear();

    if (!move_tab_bar && src_node->TabBar)
    {
        if (dst_node->TabBar)
            dst_node->TabBar->SelectedTabId = src_node->TabBar->SelectedTabId;
        DockNodeRemoveTabBar(src_node);
    }
}

static void ImGui::DockNodeApplyPosSizeToWindows(ImGuiDockNode* node)
{
    for (int n = 0; n < node->Windows.Size; n++)
    {
        SetWindowPos(node->Windows[n], node->Pos, ImGuiCond_Always); // We don't assign directly to Pos because it can break the calculation of SizeContents on next frame
        SetWindowSize(node->Windows[n], node->Size, ImGuiCond_Always);
    }
}

static void ImGui::DockNodeHideHostWindow(ImGuiDockNode* node)
{
    if (node->HostWindow)
    {
        if (node->HostWindow->DockNodeAsHost == node)
            node->HostWindow->DockNodeAsHost = NULL;
        node->HostWindow = NULL;
    }

    if (node->Windows.Size == 1)
    {
        node->VisibleWindow = node->Windows[0];
        node->Windows[0]->DockIsActive = false;
    }

    if (node->TabBar)
        DockNodeRemoveTabBar(node);
}

// Search function called once by root node in DockNodeUpdate()
struct ImGuiDockNodeFindInfoResults
{
    ImGuiDockNode*      CentralNode;
    ImGuiDockNode*      FirstNodeWithWindows;
    int                 CountNodesWithWindows;
    //ImGuiWindowClass  WindowClassForMerges;

    ImGuiDockNodeFindInfoResults() { CentralNode = FirstNodeWithWindows = NULL; CountNodesWithWindows = 0; }
};

static void DockNodeFindInfo(ImGuiDockNode* node, ImGuiDockNodeFindInfoResults* results)
{
    if (node->Windows.Size > 0)
    {
        if (results->FirstNodeWithWindows == NULL)
            results->FirstNodeWithWindows = node;
        results->CountNodesWithWindows++;
    }
    if (node->IsCentralNode())
    {
        IM_ASSERT(results->CentralNode == NULL); // Should be only one
        IM_ASSERT(node->IsLeafNode() && "If you get this assert: please submit .ini file + repro of actions leading to this.");
        results->CentralNode = node;
    }
    if (results->CountNodesWithWindows > 1 && results->CentralNode != NULL)
        return;
    if (node->ChildNodes[0])
        DockNodeFindInfo(node->ChildNodes[0], results);
    if (node->ChildNodes[1])
        DockNodeFindInfo(node->ChildNodes[1], results);
}

static ImGuiWindow* ImGui::DockNodeFindWindowByID(ImGuiDockNode* node, ImGuiID id)
{
    IM_ASSERT(id != 0);
    for (int n = 0; n < node->Windows.Size; n++)
        if (node->Windows[n]->ID == id)
            return node->Windows[n];
    return NULL;
}

// - Remove inactive windows/nodes.
// - Update visibility flag.
static void ImGui::DockNodeUpdateVisibleFlagAndInactiveChilds(ImGuiDockNode* node)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(node->ParentNode == NULL || node->ParentNode->ChildNodes[0] == node || node->ParentNode->ChildNodes[1] == node);

    // Inherit most flags
    if (node->ParentNode)
        node->SharedFlags = node->ParentNode->SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;

    // Recurse into children
    // There is the possibility that one of our child becoming empty will delete itself and moving its sibling contents into 'node'.
    // If 'node->ChildNode[0]' delete itself, then 'node->ChildNode[1]->Windows' will be moved into 'node'
    // If 'node->ChildNode[1]' delete itself, then 'node->ChildNode[0]->Windows' will be moved into 'node' and the "remove inactive windows" loop will have run twice on those windows (harmless)
    if (node->ChildNodes[0])
        DockNodeUpdateVisibleFlagAndInactiveChilds(node->ChildNodes[0]);
    if (node->ChildNodes[1])
        DockNodeUpdateVisibleFlagAndInactiveChilds(node->ChildNodes[1]);

    // Remove inactive windows
    // Merge node flags overrides stored in windows
    for (int window_n = 0; window_n < node->Windows.Size; window_n++)
    {
        ImGuiWindow* window = node->Windows[window_n];
        IM_ASSERT(window->DockNode == node);

        bool node_was_active = (node->LastFrameActive + 1 == g.FrameCount);
        bool remove = false;
        remove |= node_was_active && (window->LastFrameActive + 1 < g.FrameCount);
        remove |= node_was_active && (node->WantCloseAll || node->WantCloseTabId == window->ID) && window->HasCloseButton && !(window->Flags & ImGuiWindowFlags_UnsavedDocument);  // Submit all _expected_ closure from last frame
        remove |= (window->DockTabWantClose);
        if (remove)
        {
            window->DockTabWantClose = false;
            if (node->Windows.Size == 1 && !node->IsCentralNode())
            {
                DockNodeHideHostWindow(node);
                node->State = ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow;
                DockNodeRemoveWindow(node, window, node->ID); // Will delete the node so it'll be invalid on return
                return;
            }
            DockNodeRemoveWindow(node, window, node->ID);
            window_n--;
        }
        else
        {
            // FIXME-DOCKING: Missing policies for conflict resolution, hence the "Experimental" tag on this.
            node->LocalFlags &= ~window->WindowClass.DockNodeFlagsOverrideClear;
            node->LocalFlags |= window->WindowClass.DockNodeFlagsOverrideSet;
        }
    }

    // Auto-hide tab bar option
    ImGuiDockNodeFlags node_flags = node->GetMergedFlags();
    if (node->WantHiddenTabBarUpdate && node->Windows.Size == 1 && (node_flags & ImGuiDockNodeFlags_AutoHideTabBar) && !node->IsHiddenTabBar())
        node->WantHiddenTabBarToggle = true;
    node->WantHiddenTabBarUpdate = false;

    // Cancel toggling if we know our tab bar is enforced to be hidden at all times
    if (node->WantHiddenTabBarToggle && node->VisibleWindow && (node->VisibleWindow->WindowClass.DockNodeFlagsOverrideSet & ImGuiDockNodeFlags_HiddenTabBar))
        node->WantHiddenTabBarToggle = false;

    // Apply toggles at a single point of the frame (here!)
    if (node->Windows.Size > 1)
        node->LocalFlags &= ~ImGuiDockNodeFlags_HiddenTabBar;
    else if (node->WantHiddenTabBarToggle)
        node->LocalFlags ^= ImGuiDockNodeFlags_HiddenTabBar;
    node->WantHiddenTabBarToggle = false;

    DockNodeUpdateVisibleFlag(node);
}

static void ImGui::DockNodeUpdateVisibleFlag(ImGuiDockNode* node)
{
    // Update visibility flag
    bool is_visible = (node->ParentNode == NULL) ? node->IsDockSpace() : node->IsCentralNode();
    is_visible |= (node->Windows.Size > 0);
    is_visible |= (node->ChildNodes[0] && node->ChildNodes[0]->IsVisible);
    is_visible |= (node->ChildNodes[1] && node->ChildNodes[1]->IsVisible);
    node->IsVisible = is_visible;
}

static void ImGui::DockNodeStartMouseMovingWindow(ImGuiDockNode* node, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(node->WantMouseMove == true);
    StartMouseMovingWindow(window);
    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - node->Pos;
    g.MovingWindow = window; // If we are docked into a non moveable root window, StartMouseMovingWindow() won't set g.MovingWindow. Override that decision.
    node->WantMouseMove = false;
}

// Update CentralNode, OnlyNodeWithWindows, LastFocusedNodeID. Copy window class.
static void ImGui::DockNodeUpdateForRootNode(ImGuiDockNode* node)
{
    DockNodeUpdateVisibleFlagAndInactiveChilds(node);

    // FIXME-DOCK: Merge this scan into the one above.
    // - Setup central node pointers
    // - Find if there's only a single visible window in the hierarchy (in which case we need to display a regular title bar -> FIXME-DOCK: that last part is not done yet!)
    ImGuiDockNodeFindInfoResults results;
    DockNodeFindInfo(node, &results);
    node->CentralNode = results.CentralNode;
    node->OnlyNodeWithWindows = (results.CountNodesWithWindows == 1) ? results.FirstNodeWithWindows : NULL;
    if (node->LastFocusedNodeId == 0 && results.FirstNodeWithWindows != NULL)
        node->LastFocusedNodeId = results.FirstNodeWithWindows->ID;

    // Copy the window class from of our first window so it can be used for proper dock filtering.
    // When node has mixed windows, prioritize the class with the most constraint (DockingAllowUnclassed = false) as the reference to copy.
    // FIXME-DOCK: We don't recurse properly, this code could be reworked to work from DockNodeUpdateScanRec.
    if (ImGuiDockNode* first_node_with_windows = results.FirstNodeWithWindows)
    {
        node->WindowClass = first_node_with_windows->Windows[0]->WindowClass;
        for (int n = 1; n < first_node_with_windows->Windows.Size; n++)
            if (first_node_with_windows->Windows[n]->WindowClass.DockingAllowUnclassed == false)
            {
                node->WindowClass = first_node_with_windows->Windows[n]->WindowClass;
                break;
            }
    }
}

static void ImGui::DockNodeUpdate(ImGuiDockNode* node)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(node->LastFrameActive != g.FrameCount);
    node->LastFrameAlive = g.FrameCount;
    node->MarkedForPosSizeWrite = false;

    node->CentralNode = node->OnlyNodeWithWindows = NULL;
    if (node->IsRootNode())
        DockNodeUpdateForRootNode(node);

    // Remove tab bar if not needed
    if (node->TabBar && node->IsNoTabBar())
        DockNodeRemoveTabBar(node);

    // Early out for hidden root dock nodes (when all DockId references are in inactive windows, or there is only 1 floating window holding on the DockId)
    bool want_to_hide_host_window = false;
    if (node->Windows.Size <= 1 && node->IsFloatingNode() && node->IsLeafNode())
        if (!g.IO.ConfigDockingAlwaysTabBar && (node->Windows.Size == 0 || !node->Windows[0]->WindowClass.DockingAlwaysTabBar))
            want_to_hide_host_window = true;
    if (want_to_hide_host_window)
    {
        if (node->Windows.Size == 1)
        {
            // Floating window pos/size is authoritative
            ImGuiWindow* single_window = node->Windows[0];
            node->Pos = single_window->Pos;
            node->Size = single_window->SizeFull;
            node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Window;

            // Transfer focus immediately so when we revert to a regular window it is immediately selected
            if (node->HostWindow && g.NavWindow == node->HostWindow)
                FocusWindow(single_window);
            if (node->HostWindow)
            {
                single_window->Viewport = node->HostWindow->Viewport;
                single_window->ViewportId = node->HostWindow->ViewportId;
                if (node->HostWindow->ViewportOwned)
                {
                    single_window->Viewport->Window = single_window;
                    single_window->ViewportOwned = true;
                }
            }
        }

        DockNodeHideHostWindow(node);
        node->State = ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow;
        node->WantCloseAll = false;
        node->WantCloseTabId = 0;
        node->HasCloseButton = node->HasWindowMenuButton = false;
        node->LastFrameActive = g.FrameCount;

        if (node->WantMouseMove && node->Windows.Size == 1)
            DockNodeStartMouseMovingWindow(node, node->Windows[0]);
        return;
    }

    // In some circumstance we will defer creating the host window (so everything will be kept hidden),
    // while the expected visible window is resizing itself.
    // This is important for first-time (no ini settings restored) single window when io.ConfigDockingAlwaysTabBar is enabled,
    // otherwise the node ends up using the minimum window size. Effectively those windows will take an extra frame to show up:
    //   N+0: Begin(): window created (with no known size), node is created
    //   N+1: DockNodeUpdate(): node skip creating host window / Begin(): window size applied, not visible
    //   N+2: DockNodeUpdate(): node can create host window / Begin(): window becomes visible
    // We could remove this frame if we could reliably calculate the expected window size during node update, before the Begin() code.
    // It would require a generalization of CalcWindowExpectedSize(), probably extracting code away from Begin().
    // In reality it isn't very important as user quickly ends up with size data in .ini file.
    if (node->IsVisible && node->HostWindow == NULL && node->IsFloatingNode() && node->IsLeafNode())
    {
        IM_ASSERT(node->Windows.Size > 0);
        ImGuiWindow* ref_window = NULL;
        if (node->SelectedTabId != 0) // Note that we prune single-window-node settings on .ini loading, so this is generally 0 for them!
            ref_window = DockNodeFindWindowByID(node, node->SelectedTabId);
        if (ref_window == NULL)
            ref_window = node->Windows[0];
        if (ref_window->AutoFitFramesX > 0 || ref_window->AutoFitFramesY > 0)
        {
            node->State = ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing;
            return;
        }
    }

    const ImGuiDockNodeFlags node_flags = node->GetMergedFlags();

    // Decide if the node will have a close button and a window menu button
    node->HasWindowMenuButton = (node->Windows.Size > 0) && (node_flags & ImGuiDockNodeFlags_NoWindowMenuButton) == 0;
    node->HasCloseButton = false;
    for (int window_n = 0; window_n < node->Windows.Size; window_n++)
    {
        // FIXME-DOCK: Setting DockIsActive here means that for single active window in a leaf node, DockIsActive will be cleared until the next Begin() call.
        ImGuiWindow* window = node->Windows[window_n];
        node->HasCloseButton |= window->HasCloseButton;
        window->DockIsActive = (node->Windows.Size > 1);
    }
    if (node_flags & ImGuiDockNodeFlags_NoCloseButton)
        node->HasCloseButton = false;

    // Bind or create host window
    ImGuiWindow* host_window = NULL;
    bool beginned_into_host_window = false;
    if (node->IsDockSpace())
    {
        // [Explicit root dockspace node]
        IM_ASSERT(node->HostWindow);
        host_window = node->HostWindow;
    }
    else
    {
        // [Automatic root or child nodes]
        if (node->IsRootNode() && node->IsVisible)
        {
            ImGuiWindow* ref_window = (node->Windows.Size > 0) ? node->Windows[0] : NULL;

            // Sync Pos
            if (node->AuthorityForPos == ImGuiDataAuthority_Window && ref_window)
                SetNextWindowPos(ref_window->Pos);
            else if (node->AuthorityForPos == ImGuiDataAuthority_DockNode)
                SetNextWindowPos(node->Pos);

            // Sync Size
            if (node->AuthorityForSize == ImGuiDataAuthority_Window && ref_window)
                SetNextWindowSize(ref_window->SizeFull);
            else if (node->AuthorityForSize == ImGuiDataAuthority_DockNode)
                SetNextWindowSize(node->Size);

            // Sync Collapsed
            if (node->AuthorityForSize == ImGuiDataAuthority_Window && ref_window)
                SetNextWindowCollapsed(ref_window->Collapsed);

            // Sync Viewport
            if (node->AuthorityForViewport == ImGuiDataAuthority_Window && ref_window)
                SetNextWindowViewport(ref_window->ViewportId);

            SetNextWindowClass(&node->WindowClass);

            // Begin into the host window
            char window_label[20];
            DockNodeGetHostWindowTitle(node, window_label, IM_ARRAYSIZE(window_label));
            ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_DockNodeHost;
            window_flags |= ImGuiWindowFlags_NoFocusOnAppearing;
            window_flags |= ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoCollapse;
            window_flags |= ImGuiWindowFlags_NoTitleBar;

            PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
            Begin(window_label, NULL, window_flags);
            PopStyleVar();
            beginned_into_host_window = true;

            node->HostWindow = host_window = g.CurrentWindow;
            host_window->DockNodeAsHost = node;
            host_window->DC.CursorPos = host_window->Pos;
            node->Pos = host_window->Pos;
            node->Size = host_window->Size;

            // We set ImGuiWindowFlags_NoFocusOnAppearing because we don't want the host window to take full focus (e.g. steal NavWindow)
            // But we still it bring it to the front of display. There's no way to choose this precise behavior via window flags.
            // One simple case to ponder if: window A has a toggle to create windows B/C/D. Dock B/C/D together, clear the toggle and enable it again.
            // When reappearing B/C/D will request focus and be moved to the top of the display pile, but they are not linked to the dock host window
            // during the frame they appear. The dock host window would keep its old display order, and the sorting in EndFrame would move B/C/D back
            // after the dock host window, losing their top-most status.
            if (node->HostWindow->Appearing)
                BringWindowToDisplayFront(node->HostWindow);

            node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Auto;
        }
        else if (node->ParentNode)
        {
            node->HostWindow = host_window = node->ParentNode->HostWindow;
            node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Auto;
        }
        if (node->WantMouseMove && node->HostWindow)
            DockNodeStartMouseMovingWindow(node, node->HostWindow);
    }

    // Update focused node (the one whose title bar is highlight) within a node tree
    if (node->IsSplitNode())
        IM_ASSERT(node->TabBar == NULL);
    if (node->IsRootNode())
        if (g.NavWindow && g.NavWindow->RootWindow->DockNode && g.NavWindow->RootWindow->ParentWindow == host_window)
            node->LastFocusedNodeId = g.NavWindow->RootWindow->DockNode->ID;

    // We need to draw a background at the root level if requested by ImGuiDockNodeFlags_PassthruCentralNode, but we will only know the correct pos/size
    // _after_ processing the resizing splitters. So we are using the DrawList channel splitting facility to submit drawing primitives out of order!
    const bool render_dockspace_bg = node->IsRootNode() && host_window && (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) != 0;
    if (render_dockspace_bg)
    {
        host_window->DrawList->ChannelsSplit(2);
        host_window->DrawList->ChannelsSetCurrent(1);
    }

    // Register a hit-test hole in the window unless we are currently dragging a window that is compatible with our dockspace
    ImGuiDockNode* central_node = node->CentralNode;
    const bool central_node_hole = node->IsRootNode() && host_window && (node_flags & ImGuiDockNodeFlags_PassthruCentralNode) != 0 && central_node != NULL && central_node->IsEmpty();
    bool central_node_hole_register_hit_test_hole = central_node_hole;
    if (central_node_hole)
        if (const ImGuiPayload* payload = ImGui::GetDragDropPayload())
            if (payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && DockNodeIsDropAllowed(host_window, *(ImGuiWindow**)payload->Data))
                central_node_hole_register_hit_test_hole = false;
    if (central_node_hole_register_hit_test_hole)
    {
        // We add a little padding to match the "resize from edges" behavior and allow grabbing the splitter easily.
        // (But we only add it if there's something else on the other side of the hole, otherwise for e.g. fullscreen
        // covering passthru node we'd have a gap on the edge not covered by the hole)
        IM_ASSERT(node->IsDockSpace()); // We cannot pass this flag without the DockSpace() api. Testing this because we also setup the hole in host_window->ParentNode
        ImGuiDockNode* root_node = DockNodeGetRootNode(central_node);
        ImRect root_rect(root_node->Pos, root_node->Pos + root_node->Size);
        ImRect hole_rect(central_node->Pos, central_node->Pos + central_node->Size);
        if (hole_rect.Min.x > root_rect.Min.x) { hole_rect.Min.x += WINDOWS_HOVER_PADDING; }
        if (hole_rect.Max.x < root_rect.Max.x) { hole_rect.Max.x -= WINDOWS_HOVER_PADDING; }
        if (hole_rect.Min.y > root_rect.Min.y) { hole_rect.Min.y += WINDOWS_HOVER_PADDING; }
        if (hole_rect.Max.y < root_rect.Max.y) { hole_rect.Max.y -= WINDOWS_HOVER_PADDING; }
        //GetForegroundDrawList()->AddRect(hole_rect.Min, hole_rect.Max, IM_COL32(255, 0, 0, 255));
        if (central_node_hole && !hole_rect.IsInverted())
        {
            SetWindowHitTestHole(host_window, hole_rect.Min, hole_rect.Max - hole_rect.Min);
            SetWindowHitTestHole(host_window->ParentWindow, hole_rect.Min, hole_rect.Max - hole_rect.Min);
        }
    }

    // Update position/size, process and draw resizing splitters
    if (node->IsRootNode() && host_window)
    {
        DockNodeTreeUpdatePosSize(node, host_window->Pos, host_window->Size);
        DockNodeTreeUpdateSplitter(node);
    }

    // Draw empty node background (currently can only be the Central Node)
    if (host_window && node->IsEmpty() && node->IsVisible && !(node_flags & ImGuiDockNodeFlags_PassthruCentralNode))
        host_window->DrawList->AddRectFilled(node->Pos, node->Pos + node->Size, GetColorU32(ImGuiCol_DockingEmptyBg));

    // Draw whole dockspace background if ImGuiDockNodeFlags_PassthruCentralNode if set.
    if (render_dockspace_bg && node->IsVisible)
    {
        host_window->DrawList->ChannelsSetCurrent(0);
        if (central_node_hole)
            RenderRectFilledWithHole(host_window->DrawList, node->Rect(), central_node->Rect(), GetColorU32(ImGuiCol_WindowBg), 0.0f);
        else
            host_window->DrawList->AddRectFilled(node->Pos, node->Pos + node->Size, GetColorU32(ImGuiCol_WindowBg), 0.0f);
        host_window->DrawList->ChannelsMerge();
    }

    // Draw and populate Tab Bar
    if (host_window && node->Windows.Size > 0)
    {
        DockNodeUpdateTabBar(node, host_window);
    }
    else
    {
        node->WantCloseAll = false;
        node->WantCloseTabId = 0;
        node->IsFocused = false;
    }
    if (node->TabBar && node->TabBar->SelectedTabId)
        node->SelectedTabId = node->TabBar->SelectedTabId;
    else if (node->Windows.Size > 0)
        node->SelectedTabId = node->Windows[0]->ID;

    // Draw payload drop target
    if (host_window && node->IsVisible)
        if (node->IsRootNode() && (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != host_window))
            BeginDockableDragDropTarget(host_window);

    // We update this after DockNodeUpdateTabBar()
    node->LastFrameActive = g.FrameCount;

    // Recurse into children
    // FIXME-DOCK FIXME-OPT: Should not need to recurse into children
    if (host_window)
    {
        if (node->ChildNodes[0])
            DockNodeUpdate(node->ChildNodes[0]);
        if (node->ChildNodes[1])
            DockNodeUpdate(node->ChildNodes[1]);

        // Render outer borders last (after the tab bar)
        if (node->IsRootNode())
            RenderWindowOuterBorders(host_window);
    }

    // End host window
    if (beginned_into_host_window) //-V1020
        End();
}

// Compare TabItem nodes given the last known DockOrder (will persist in .ini file as hint), used to sort tabs when multiple tabs are added on the same frame.
static int IMGUI_CDECL TabItemComparerByDockOrder(const void* lhs, const void* rhs)
{
    ImGuiWindow* a = ((const ImGuiTabItem*)lhs)->Window;
    ImGuiWindow* b = ((const ImGuiTabItem*)rhs)->Window;
    if (int d = ((a->DockOrder == -1) ? INT_MAX : a->DockOrder) - ((b->DockOrder == -1) ? INT_MAX : b->DockOrder))
        return d;
    return (a->BeginOrderWithinContext - b->BeginOrderWithinContext);
}

static ImGuiID ImGui::DockNodeUpdateWindowMenu(ImGuiDockNode* node, ImGuiTabBar* tab_bar)
{
    // Try to position the menu so it is more likely to stays within the same viewport
    ImGuiContext& g = *GImGui;
    ImGuiID ret_tab_id = 0;
    if (g.Style.WindowMenuButtonPosition == ImGuiDir_Left)
        SetNextWindowPos(ImVec2(node->Pos.x, node->Pos.y + GetFrameHeight()), ImGuiCond_Always, ImVec2(0.0f, 0.0f));
    else
        SetNextWindowPos(ImVec2(node->Pos.x + node->Size.x, node->Pos.y + GetFrameHeight()), ImGuiCond_Always, ImVec2(1.0f, 0.0f));
    if (BeginPopup("#WindowMenu"))
    {
        node->IsFocused = true;
        if (tab_bar->Tabs.Size == 1)
        {
            if (MenuItem("Hide tab bar", NULL, node->IsHiddenTabBar()))
                node->WantHiddenTabBarToggle = true;
        }
        else
        {
            for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
            {
                ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
                if (tab->Flags & ImGuiTabItemFlags_Button)
                    continue;
                if (Selectable(tab_bar->GetTabName(tab), tab->ID == tab_bar->SelectedTabId))
                    ret_tab_id = tab->ID;
                SameLine();
                Text("   ");
            }
        }
        EndPopup();
    }
    return ret_tab_id;
}

// User helper to append/amend into a dock node tab bar. Most commonly used to add e.g. a "+" button.
bool ImGui::DockNodeBeginAmendTabBar(ImGuiDockNode* node)
{
    if (node->TabBar == NULL || node->HostWindow == NULL)
        return false;
    if (node->SharedFlags & ImGuiDockNodeFlags_KeepAliveOnly)
        return false;
    Begin(node->HostWindow->Name);
    PushOverrideID(node->ID);
    bool ret = BeginTabBarEx(node->TabBar, node->TabBar->BarRect, node->TabBar->Flags, node);
    IM_UNUSED(ret);
    IM_ASSERT(ret);
    return true;
}

void ImGui::DockNodeEndAmendTabBar()
{
    EndTabBar();
    PopID();
    End();
}

// Submit the tab bar corresponding to a dock node and various housekeeping details.
static void ImGui::DockNodeUpdateTabBar(ImGuiDockNode* node, ImGuiWindow* host_window)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;

    const bool node_was_active = (node->LastFrameActive + 1 == g.FrameCount);
    const bool closed_all = node->WantCloseAll && node_was_active;
    const ImGuiID closed_one = node->WantCloseTabId && node_was_active;
    node->WantCloseAll = false;
    node->WantCloseTabId = 0;

    // Decide if we should use a focused title bar color
    bool is_focused = false;
    ImGuiDockNode* root_node = DockNodeGetRootNode(node);
    if (g.NavWindowingTarget)
        is_focused = (g.NavWindowingTarget->DockNode == node);
    else if (g.NavWindow && g.NavWindow->RootWindowForTitleBarHighlight == host_window->RootWindowDockTree && root_node->LastFocusedNodeId == node->ID)
        is_focused = true;

    // Hidden tab bar will show a triangle on the upper-left (in Begin)
    if (node->IsHiddenTabBar() || node->IsNoTabBar())
    {
        node->VisibleWindow = (node->Windows.Size > 0) ? node->Windows[0] : NULL;
        node->IsFocused = is_focused;
        if (is_focused)
            node->LastFrameFocused = g.FrameCount;
        if (node->VisibleWindow)
        {
            // Notify root of visible window (used to display title in OS task bar)
            if (is_focused || root_node->VisibleWindow == NULL)
                root_node->VisibleWindow = node->VisibleWindow;
            if (node->TabBar)
                node->TabBar->VisibleTabId = node->VisibleWindow->ID;
        }
        return;
    }

    // Move ourselves to the Menu layer (so we can be accessed by tapping Alt) + undo SkipItems flag in order to draw over the title bar even if the window is collapsed
    bool backup_skip_item = host_window->SkipItems;
    if (!node->IsDockSpace())
    {
        host_window->SkipItems = false;
        host_window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
    }

    // Use PushOverrideID() instead of PushID() to use the node id _without_ the host window ID.
    // This is to facilitate computing those ID from the outside, and will affect more or less only the ID of the collapse button, popup and tabs,
    // as docked windows themselves will override the stack with their own root ID.
    PushOverrideID(node->ID);
    ImGuiTabBar* tab_bar = node->TabBar;
    bool tab_bar_is_recreated = (tab_bar == NULL); // Tab bar are automatically destroyed when a node gets hidden
    if (tab_bar == NULL)
    {
        DockNodeAddTabBar(node);
        tab_bar = node->TabBar;
    }

    ImGuiID focus_tab_id = 0;
    node->IsFocused = is_focused;

    const ImGuiDockNodeFlags node_flags = node->GetMergedFlags();
    const bool has_window_menu_button = (node_flags & ImGuiDockNodeFlags_NoWindowMenuButton) == 0 && (style.WindowMenuButtonPosition != ImGuiDir_None);

    // In a dock node, the Collapse Button turns into the Window Menu button.
    // FIXME-DOCK FIXME-OPT: Could we recycle popups id across multiple dock nodes?
    if (has_window_menu_button && IsPopupOpen("#WindowMenu"))
    {
        if (ImGuiID tab_id = DockNodeUpdateWindowMenu(node, tab_bar))
            focus_tab_id = tab_bar->NextSelectedTabId = tab_id;
        is_focused |= node->IsFocused;
    }

    // Layout
    ImRect title_bar_rect, tab_bar_rect;
    ImVec2 window_menu_button_pos;
    DockNodeCalcTabBarLayout(node, &title_bar_rect, &tab_bar_rect, &window_menu_button_pos);

    // Submit new tabs, they will be added as Unsorted and sorted below based on relative DockOrder value.
    const int tabs_count_old = tab_bar->Tabs.Size;
    for (int window_n = 0; window_n < node->Windows.Size; window_n++)
    {
        ImGuiWindow* window = node->Windows[window_n];
        if (TabBarFindTabByID(tab_bar, window->ID) == NULL)
            TabBarAddTab(tab_bar, ImGuiTabItemFlags_Unsorted, window);
    }

    // Title bar
    if (is_focused)
        node->LastFrameFocused = g.FrameCount;
    ImU32 title_bar_col = GetColorU32(host_window->Collapsed ? ImGuiCol_TitleBgCollapsed : is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
    host_window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, host_window->WindowRounding, ImDrawFlags_RoundCornersTop);

    // Docking/Collapse button
    if (has_window_menu_button)
    {
        if (CollapseButton(host_window->GetID("#COLLAPSE"), window_menu_button_pos, node)) // == DockNodeGetWindowMenuButtonId(node)
            OpenPopup("#WindowMenu");
        if (IsItemActive())
            focus_tab_id = tab_bar->SelectedTabId;
    }

    // If multiple tabs are appearing on the same frame, sort them based on their persistent DockOrder value
    int tabs_unsorted_start = tab_bar->Tabs.Size;
    for (int tab_n = tab_bar->Tabs.Size - 1; tab_n >= 0 && (tab_bar->Tabs[tab_n].Flags & ImGuiTabItemFlags_Unsorted); tab_n--)
    {
        // FIXME-DOCK: Consider only clearing the flag after the tab has been alive for a few consecutive frames, allowing late comers to not break sorting?
        tab_bar->Tabs[tab_n].Flags &= ~ImGuiTabItemFlags_Unsorted;
        tabs_unsorted_start = tab_n;
    }
    if (tab_bar->Tabs.Size > tabs_unsorted_start)
    {
        IMGUI_DEBUG_LOG_DOCKING("In node 0x%08X: %d new appearing tabs:%s\n", node->ID, tab_bar->Tabs.Size - tabs_unsorted_start, (tab_bar->Tabs.Size > tabs_unsorted_start + 1) ? " (will sort)" : "");
        for (int tab_n = tabs_unsorted_start; tab_n < tab_bar->Tabs.Size; tab_n++)
            IMGUI_DEBUG_LOG_DOCKING(" - Tab '%s' Order %d\n", tab_bar->Tabs[tab_n].Window->Name, tab_bar->Tabs[tab_n].Window->DockOrder);
        if (tab_bar->Tabs.Size > tabs_unsorted_start + 1)
            ImQsort(tab_bar->Tabs.Data + tabs_unsorted_start, tab_bar->Tabs.Size - tabs_unsorted_start, sizeof(ImGuiTabItem), TabItemComparerByDockOrder);
    }

    // Apply NavWindow focus back to the tab bar
    if (g.NavWindow && g.NavWindow->RootWindow->DockNode == node)
        tab_bar->SelectedTabId = g.NavWindow->RootWindow->ID;

    // Selected newly added tabs, or persistent tab ID if the tab bar was just recreated
    if (tab_bar_is_recreated && TabBarFindTabByID(tab_bar, node->SelectedTabId) != NULL)
        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = node->SelectedTabId;
    else if (tab_bar->Tabs.Size > tabs_count_old)
        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = tab_bar->Tabs.back().Window->ID;

    // Begin tab bar
    ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_Reorderable | ImGuiTabBarFlags_AutoSelectNewTabs; // | ImGuiTabBarFlags_NoTabListScrollingButtons);
    tab_bar_flags |= ImGuiTabBarFlags_SaveSettings | ImGuiTabBarFlags_DockNode;
    if (!host_window->Collapsed && is_focused)
        tab_bar_flags |= ImGuiTabBarFlags_IsFocused;
    BeginTabBarEx(tab_bar, tab_bar_rect, tab_bar_flags, node);
    //host_window->DrawList->AddRect(tab_bar_rect.Min, tab_bar_rect.Max, IM_COL32(255,0,255,255));

    // Backup style colors
    ImVec4 backup_style_cols[ImGuiWindowDockStyleCol_COUNT];
    for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
        backup_style_cols[color_n] = g.Style.Colors[GWindowDockStyleColors[color_n]];

    // Submit actual tabs
    node->VisibleWindow = NULL;
    for (int window_n = 0; window_n < node->Windows.Size; window_n++)
    {
        ImGuiWindow* window = node->Windows[window_n];
        if ((closed_all || closed_one == window->ID) && window->HasCloseButton && !(window->Flags & ImGuiWindowFlags_UnsavedDocument))
            continue;
        if (window->LastFrameActive + 1 >= g.FrameCount || !node_was_active)
        {
            ImGuiTabItemFlags tab_item_flags = 0;
            tab_item_flags |= window->WindowClass.TabItemFlagsOverrideSet;
            if (window->Flags & ImGuiWindowFlags_UnsavedDocument)
                tab_item_flags |= ImGuiTabItemFlags_UnsavedDocument;
            if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)
                tab_item_flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;

            // Apply stored style overrides for the window
            for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
                g.Style.Colors[GWindowDockStyleColors[color_n]] = ColorConvertU32ToFloat4(window->DockStyle.Colors[color_n]);

            bool tab_open = true;
            TabItemEx(tab_bar, window->Name, window->HasCloseButton ? &tab_open : NULL, tab_item_flags, window);
            if (!tab_open)
                node->WantCloseTabId = window->ID;
            if (tab_bar->VisibleTabId == window->ID)
                node->VisibleWindow = window;

            // Store last item data so it can be queried with IsItemXXX functions after the user Begin() call
            window->DockTabItemStatusFlags = host_window->DC.LastItemStatusFlags;
            window->DockTabItemRect = host_window->DC.LastItemRect;

            // Update navigation ID on menu layer
            if (g.NavWindow && g.NavWindow->RootWindow == window && (window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0)
                host_window->NavLastIds[1] = window->ID;
        }
    }

    // Restore style colors
    for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
        g.Style.Colors[GWindowDockStyleColors[color_n]] = backup_style_cols[color_n];

    // Notify root of visible window (used to display title in OS task bar)
    if (node->VisibleWindow)
        if (is_focused || root_node->VisibleWindow == NULL)
            root_node->VisibleWindow = node->VisibleWindow;

    // Close button (after VisibleWindow was updated)
    // Note that VisibleWindow may have been overrided by CTRL+Tabbing, so VisibleWindow->ID may be != from tab_bar->SelectedTabId
    const bool close_button_is_enabled = node->HasCloseButton && node->VisibleWindow && node->VisibleWindow->HasCloseButton;
    const bool close_button_is_visible = node->HasCloseButton;
    //const bool close_button_is_visible = close_button_is_enabled; // Most people would expect this behavior of not even showing the button (leaving a hole since we can't claim that space as other windows in the tba bar have one)
    if (close_button_is_visible)
    {
        if (!close_button_is_enabled)
        {
            PushItemFlag(ImGuiItemFlags_Disabled, true);
            PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_Text] * ImVec4(1.0f,1.0f,1.0f,0.4f));
        }
        const float button_sz = g.FontSize;
        if (CloseButton(host_window->GetID("#CLOSE"), title_bar_rect.GetTR() + ImVec2(-style.FramePadding.x * 2.0f - button_sz, 0.0f)))
            if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_bar->VisibleTabId))
            {
                node->WantCloseTabId = tab->ID;
                TabBarCloseTab(tab_bar, tab);
            }
        //if (IsItemActive())
        //    focus_tab_id = tab_bar->SelectedTabId;
        if (!close_button_is_enabled)
        {
            PopStyleColor();
            PopItemFlag();
        }
    }

    // When clicking on the title bar outside of tabs, we still focus the selected tab for that node
    // FIXME: TabItem use AllowItemOverlap so we manually perform a more specific test for now (hovered || held)
    ImGuiID title_bar_id = host_window->GetID("#TITLEBAR");
    if (g.HoveredId == 0 || g.HoveredId == title_bar_id || g.ActiveId == title_bar_id)
    {
        bool held;
        ButtonBehavior(title_bar_rect, title_bar_id, NULL, &held, ImGuiButtonFlags_AllowItemOverlap);
        if (g.HoveredId == title_bar_id)
        {
            // ImGuiButtonFlags_AllowItemOverlap + SetItemAllowOverlap() required for appending into dock node tab bar,
            // otherwise dragging window will steal HoveredId and amended tabs cannot get them.
            host_window->DC.LastItemId = title_bar_id;
            SetItemAllowOverlap();
        }
        if (held)
        {
            if (IsMouseClicked(0))
                focus_tab_id = tab_bar->SelectedTabId;

            // Forward moving request to selected window
            if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))
                StartMouseMovingWindowOrNode(tab->Window ? tab->Window : node->HostWindow, node, false);
        }
    }

    // Forward focus from host node to selected window
    //if (is_focused && g.NavWindow == host_window && !g.NavWindowingTarget)
    //    focus_tab_id = tab_bar->SelectedTabId;

    // When clicked on a tab we requested focus to the docked child
    // This overrides the value set by "forward focus from host node to selected window".
    if (tab_bar->NextSelectedTabId)
        focus_tab_id = tab_bar->NextSelectedTabId;

    // Apply navigation focus
    if (focus_tab_id != 0)
        if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, focus_tab_id))
            if (tab->Window)
            {
                FocusWindow(tab->Window);
                NavInitWindow(tab->Window, false);
            }

    EndTabBar();
    PopID();

    // Restore SkipItems flag
    if (!node->IsDockSpace())
    {
        host_window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
        host_window->SkipItems = backup_skip_item;
    }
}

static void ImGui::DockNodeAddTabBar(ImGuiDockNode* node)
{
    IM_ASSERT(node->TabBar == NULL);
    node->TabBar = IM_NEW(ImGuiTabBar);
}

static void ImGui::DockNodeRemoveTabBar(ImGuiDockNode* node)
{
    if (node->TabBar == NULL)
        return;
    IM_DELETE(node->TabBar);
    node->TabBar = NULL;
}

static bool DockNodeIsDropAllowedOne(ImGuiWindow* payload, ImGuiWindow* host_window)
{
    if (host_window->DockNodeAsHost && host_window->DockNodeAsHost->IsDockSpace() && payload->BeginOrderWithinContext < host_window->BeginOrderWithinContext)
        return false;

    ImGuiWindowClass* host_class = host_window->DockNodeAsHost ? &host_window->DockNodeAsHost->WindowClass : &host_window->WindowClass;
    ImGuiWindowClass* payload_class = &payload->WindowClass;
    if (host_class->ClassId != payload_class->ClassId)
    {
        if (host_class->ClassId != 0 && host_class->DockingAllowUnclassed && payload_class->ClassId == 0)
            return true;
        if (payload_class->ClassId != 0 && payload_class->DockingAllowUnclassed && host_class->ClassId == 0)
            return true;
        return false;
    }

    return true;
}

static bool ImGui::DockNodeIsDropAllowed(ImGuiWindow* host_window, ImGuiWindow* root_payload)
{
    if (root_payload->DockNodeAsHost && root_payload->DockNodeAsHost->IsSplitNode())
        return true;

    const int payload_count = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->Windows.Size : 1;
    for (int payload_n = 0; payload_n < payload_count; payload_n++)
    {
        ImGuiWindow* payload = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->Windows[payload_n] : root_payload;
        if (DockNodeIsDropAllowedOne(payload, host_window))
            return true;
    }
    return false;
}

// window menu button == collapse button when not in a dock node.
// FIXME: This is similar to RenderWindowTitleBarContents, may want to share code.
static void ImGui::DockNodeCalcTabBarLayout(const ImGuiDockNode* node, ImRect* out_title_rect, ImRect* out_tab_bar_rect, ImVec2* out_window_menu_button_pos)
{
    ImGuiContext& g = *GImGui;
    ImRect r = ImRect(node->Pos.x, node->Pos.y, node->Pos.x + node->Size.x, node->Pos.y + g.FontSize + g.Style.FramePadding.y * 2.0f);
    if (out_title_rect) { *out_title_rect = r; }

    ImVec2 window_menu_button_pos = r.Min;
    r.Min.x += g.Style.FramePadding.x;
    r.Max.x -= g.Style.FramePadding.x;
    if (node->HasCloseButton)
    {
        r.Max.x -= g.FontSize;// +1.0f; // In DockNodeUpdateTabBar() we currently display a disabled close button even if there is none.
    }
    if (node->HasWindowMenuButton && g.Style.WindowMenuButtonPosition == ImGuiDir_Left)
    {
        r.Min.x += g.FontSize; // + g.Style.ItemInnerSpacing.x; // <-- Adding ItemInnerSpacing makes the title text moves slightly when in a docking tab bar. Instead we adjusted RenderArrowDockMenu()
    }
    else if (node->HasWindowMenuButton && g.Style.WindowMenuButtonPosition == ImGuiDir_Right)
    {
        r.Max.x -= g.FontSize + g.Style.FramePadding.x;
        window_menu_button_pos = ImVec2(r.Max.x, r.Min.y);
    }
    if (out_tab_bar_rect) { *out_tab_bar_rect = r; }
    if (out_window_menu_button_pos) { *out_window_menu_button_pos = window_menu_button_pos; }
}

void ImGui::DockNodeCalcSplitRects(ImVec2& pos_old, ImVec2& size_old, ImVec2& pos_new, ImVec2& size_new, ImGuiDir dir, ImVec2 size_new_desired)
{
    ImGuiContext& g = *GImGui;
    const float dock_spacing = g.Style.ItemInnerSpacing.x;
    const ImGuiAxis axis = (dir == ImGuiDir_Left || dir == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
    pos_new[axis ^ 1] = pos_old[axis ^ 1];
    size_new[axis ^ 1] = size_old[axis ^ 1];

    // Distribute size on given axis (with a desired size or equally)
    const float w_avail = size_old[axis] - dock_spacing;
    if (size_new_desired[axis] > 0.0f && size_new_desired[axis] <= w_avail * 0.5f)
    {
        size_new[axis] = size_new_desired[axis];
        size_old[axis] = IM_FLOOR(w_avail - size_new[axis]);
    }
    else
    {
        size_new[axis] = IM_FLOOR(w_avail * 0.5f);
        size_old[axis] = IM_FLOOR(w_avail - size_new[axis]);
    }

    // Position each node
    if (dir == ImGuiDir_Right || dir == ImGuiDir_Down)
    {
        pos_new[axis] = pos_old[axis] + size_old[axis] + dock_spacing;
    }
    else if (dir == ImGuiDir_Left || dir == ImGuiDir_Up)
    {
        pos_new[axis] = pos_old[axis];
        pos_old[axis] = pos_new[axis] + size_new[axis] + dock_spacing;
    }
}

// Retrieve the drop rectangles for a given direction or for the center + perform hit testing.
bool ImGui::DockNodeCalcDropRectsAndTestMousePos(const ImRect& parent, ImGuiDir dir, ImRect& out_r, bool outer_docking, ImVec2* test_mouse_pos)
{
    ImGuiContext& g = *GImGui;

    const float parent_smaller_axis = ImMin(parent.GetWidth(), parent.GetHeight());
    const float hs_for_central_nodes = ImMin(g.FontSize * 1.5f, ImMax(g.FontSize * 0.5f, parent_smaller_axis / 8.0f));
    float hs_w; // Half-size, longer axis
    float hs_h; // Half-size, smaller axis
    ImVec2 off; // Distance from edge or center
    if (outer_docking)
    {
        //hs_w = ImFloor(ImClamp(parent_smaller_axis - hs_for_central_nodes * 4.0f, g.FontSize * 0.5f, g.FontSize * 8.0f));
        //hs_h = ImFloor(hs_w * 0.15f);
        //off = ImVec2(ImFloor(parent.GetWidth() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h), ImFloor(parent.GetHeight() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h));
        hs_w = ImFloor(hs_for_central_nodes * 1.50f);
        hs_h = ImFloor(hs_for_central_nodes * 0.80f);
        off = ImVec2(ImFloor(parent.GetWidth() * 0.5f - hs_h), ImFloor(parent.GetHeight() * 0.5f - hs_h));
    }
    else
    {
        hs_w = ImFloor(hs_for_central_nodes);
        hs_h = ImFloor(hs_for_central_nodes * 0.90f);
        off = ImVec2(ImFloor(hs_w * 2.40f), ImFloor(hs_w * 2.40f));
    }

    ImVec2 c = ImFloor(parent.GetCenter());
    if      (dir == ImGuiDir_None)  { out_r = ImRect(c.x - hs_w, c.y - hs_w,         c.x + hs_w, c.y + hs_w);         }
    else if (dir == ImGuiDir_Up)    { out_r = ImRect(c.x - hs_w, c.y - off.y - hs_h, c.x + hs_w, c.y - off.y + hs_h); }
    else if (dir == ImGuiDir_Down)  { out_r = ImRect(c.x - hs_w, c.y + off.y - hs_h, c.x + hs_w, c.y + off.y + hs_h); }
    else if (dir == ImGuiDir_Left)  { out_r = ImRect(c.x - off.x - hs_h, c.y - hs_w, c.x - off.x + hs_h, c.y + hs_w); }
    else if (dir == ImGuiDir_Right) { out_r = ImRect(c.x + off.x - hs_h, c.y - hs_w, c.x + off.x + hs_h, c.y + hs_w); }

    if (test_mouse_pos == NULL)
        return false;

    ImRect hit_r = out_r;
    if (!outer_docking)
    {
        // Custom hit testing for the 5-way selection, designed to reduce flickering when moving diagonally between sides
        hit_r.Expand(ImFloor(hs_w * 0.30f));
        ImVec2 mouse_delta = (*test_mouse_pos - c);
        float mouse_delta_len2 = ImLengthSqr(mouse_delta);
        float r_threshold_center = hs_w * 1.4f;
        float r_threshold_sides = hs_w * (1.4f + 1.2f);
        if (mouse_delta_len2 < r_threshold_center * r_threshold_center)
            return (dir == ImGuiDir_None);
        if (mouse_delta_len2 < r_threshold_sides * r_threshold_sides)
            return (dir == ImGetDirQuadrantFromDelta(mouse_delta.x, mouse_delta.y));
    }
    return hit_r.Contains(*test_mouse_pos);
}

// host_node may be NULL if the window doesn't have a DockNode already.
// FIXME-DOCK: This is misnamed since it's also doing the filtering.
static void ImGui::DockNodePreviewDockSetup(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* root_payload, ImGuiDockPreviewData* data, bool is_explicit_target, bool is_outer_docking)
{
    ImGuiContext& g = *GImGui;

    // There is an edge case when docking into a dockspace which only has inactive nodes.
    // In this case DockNodeTreeFindNodeByPos() will have selected a leaf node which is inactive.
    // Because the inactive leaf node doesn't have proper pos/size yet, we'll use the root node as reference.
    ImGuiDockNode* root_payload_as_host = root_payload->DockNodeAsHost;
    ImGuiDockNode* ref_node_for_rect = (host_node && !host_node->IsVisible) ? DockNodeGetRootNode(host_node) : host_node;
    if (ref_node_for_rect)
        IM_ASSERT(ref_node_for_rect->IsVisible);

    // Filter, figure out where we are allowed to dock
    ImGuiDockNodeFlags src_node_flags = root_payload_as_host ? root_payload_as_host->GetMergedFlags() : root_payload->WindowClass.DockNodeFlagsOverrideSet;
    ImGuiDockNodeFlags dst_node_flags = host_node ? host_node->GetMergedFlags() : host_window->WindowClass.DockNodeFlagsOverrideSet;
    data->IsCenterAvailable = true;
    if (is_outer_docking)
        data->IsCenterAvailable = false;
    else if (dst_node_flags & ImGuiDockNodeFlags_NoDocking)
        data->IsCenterAvailable = false;
    else if (host_node && (dst_node_flags & ImGuiDockNodeFlags_NoDockingInCentralNode) && host_node->IsCentralNode())
        data->IsCenterAvailable = false;
    else if ((!host_node || !host_node->IsEmpty()) && root_payload_as_host && root_payload_as_host->IsSplitNode() && (root_payload_as_host->OnlyNodeWithWindows == NULL)) // Is _visibly_ split?
        data->IsCenterAvailable = false;
    else if ((dst_node_flags & ImGuiDockNodeFlags_NoDockingOverMe) || (src_node_flags & ImGuiDockNodeFlags_NoDockingOverOther))
        data->IsCenterAvailable = false;

    data->IsSidesAvailable = true;
    if ((dst_node_flags & ImGuiDockNodeFlags_NoSplit) || g.IO.ConfigDockingNoSplit)
        data->IsSidesAvailable = false;
    else if (!is_outer_docking && host_node && host_node->ParentNode == NULL && host_node->IsCentralNode())
        data->IsSidesAvailable = false;
    else if ((dst_node_flags & ImGuiDockNodeFlags_NoDockingSplitMe) || (src_node_flags & ImGuiDockNodeFlags_NoDockingSplitOther))
        data->IsSidesAvailable = false;

    // Build a tentative future node (reuse same structure because it is practical. Shape will be readjusted when previewing a split)
    data->FutureNode.HasCloseButton = (host_node ? host_node->HasCloseButton : host_window->HasCloseButton) || (root_payload->HasCloseButton);
    data->FutureNode.HasWindowMenuButton = host_node ? true : ((host_window->Flags & ImGuiWindowFlags_NoCollapse) == 0);
    data->FutureNode.Pos = ref_node_for_rect ? ref_node_for_rect->Pos : host_window->Pos;
    data->FutureNode.Size = ref_node_for_rect ? ref_node_for_rect->Size : host_window->Size;

    // Calculate drop shapes geometry for allowed splitting directions
    IM_ASSERT(ImGuiDir_None == -1);
    data->SplitNode = host_node;
    data->SplitDir = ImGuiDir_None;
    data->IsSplitDirExplicit = false;
    if (!host_window->Collapsed)
        for (int dir = ImGuiDir_None; dir < ImGuiDir_COUNT; dir++)
        {
            if (dir == ImGuiDir_None && !data->IsCenterAvailable)
                continue;
            if (dir != ImGuiDir_None && !data->IsSidesAvailable)
                continue;
            if (DockNodeCalcDropRectsAndTestMousePos(data->FutureNode.Rect(), (ImGuiDir)dir, data->DropRectsDraw[dir+1], is_outer_docking, &g.IO.MousePos))
            {
                data->SplitDir = (ImGuiDir)dir;
                data->IsSplitDirExplicit = true;
            }
        }

    // We only allow and preview docking when hovering over a drop rect or over the title bar
    data->IsDropAllowed = (data->SplitDir != ImGuiDir_None) || (data->IsCenterAvailable);
    if (!is_explicit_target && !data->IsSplitDirExplicit)
        data->IsDropAllowed = false;

    // Calculate split area
    data->SplitRatio = 0.0f;
    if (data->SplitDir != ImGuiDir_None)
    {
        ImGuiDir split_dir = data->SplitDir;
        ImGuiAxis split_axis = (split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
        ImVec2 pos_new, pos_old = data->FutureNode.Pos;
        ImVec2 size_new, size_old = data->FutureNode.Size;
        DockNodeCalcSplitRects(pos_old, size_old, pos_new, size_new, split_dir, root_payload->Size);

        // Calculate split ratio so we can pass it down the docking request
        float split_ratio = ImSaturate(size_new[split_axis] / data->FutureNode.Size[split_axis]);
        data->FutureNode.Pos = pos_new;
        data->FutureNode.Size = size_new;
        data->SplitRatio = (split_dir == ImGuiDir_Right || split_dir == ImGuiDir_Down) ? (1.0f - split_ratio) : (split_ratio);
    }
}

static void ImGui::DockNodePreviewDockRender(ImGuiWindow* host_window, ImGuiDockNode* host_node, ImGuiWindow* root_payload, const ImGuiDockPreviewData* data)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.CurrentWindow == host_window);   // Because we rely on font size to calculate tab sizes

    // With this option, we only display the preview on the target viewport, and the payload viewport is made transparent.
    // To compensate for the single layer obstructed by the payload, we'll increase the alpha of the preview nodes.
    const bool is_transparent_payload = g.IO.ConfigDockingTransparentPayload;

    // In case the two windows involved are on different viewports, we will draw the overlay on each of them.
    int overlay_draw_lists_count = 0;
    ImDrawList* overlay_draw_lists[2];
    overlay_draw_lists[overlay_draw_lists_count++] = GetForegroundDrawList(host_window->Viewport);
    if (host_window->Viewport != root_payload->Viewport && !is_transparent_payload)
        overlay_draw_lists[overlay_draw_lists_count++] = GetForegroundDrawList(root_payload->Viewport);

    // Draw main preview rectangle
    const ImU32 overlay_col_main = GetColorU32(ImGuiCol_DockingPreview, is_transparent_payload ? 0.60f : 0.40f);
    const ImU32 overlay_col_drop = GetColorU32(ImGuiCol_DockingPreview, is_transparent_payload ? 0.90f : 0.70f);
    const ImU32 overlay_col_drop_hovered = GetColorU32(ImGuiCol_DockingPreview, is_transparent_payload ? 1.20f : 1.00f);
    const ImU32 overlay_col_lines = GetColorU32(ImGuiCol_NavWindowingHighlight, is_transparent_payload ? 0.80f : 0.60f);

    // Display area preview
    const bool can_preview_tabs = (root_payload->DockNodeAsHost == NULL || root_payload->DockNodeAsHost->Windows.Size > 0);
    if (data->IsDropAllowed)
    {
        ImRect overlay_rect = data->FutureNode.Rect();
        if (data->SplitDir == ImGuiDir_None && can_preview_tabs)
            overlay_rect.Min.y += GetFrameHeight();
        if (data->SplitDir != ImGuiDir_None || data->IsCenterAvailable)
            for (int overlay_n = 0; overlay_n < overlay_draw_lists_count; overlay_n++)
                overlay_draw_lists[overlay_n]->AddRectFilled(overlay_rect.Min, overlay_rect.Max, overlay_col_main, host_window->WindowRounding);
    }

    // Display tab shape/label preview unless we are splitting node (it generally makes the situation harder to read)
    if (data->IsDropAllowed && can_preview_tabs && data->SplitDir == ImGuiDir_None && data->IsCenterAvailable)
    {
        // Compute target tab bar geometry so we can locate our preview tabs
        ImRect tab_bar_rect;
        DockNodeCalcTabBarLayout(&data->FutureNode, NULL, &tab_bar_rect, NULL);
        ImVec2 tab_pos = tab_bar_rect.Min;
        if (host_node && host_node->TabBar)
        {
            if (!host_node->IsHiddenTabBar() && !host_node->IsNoTabBar())
                tab_pos.x += host_node->TabBar->WidthAllTabs + g.Style.ItemInnerSpacing.x; // We don't use OffsetNewTab because when using non-persistent-order tab bar it is incremented with each Tab submission.
            else
                tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_node->Windows[0]->Name, host_node->Windows[0]->HasCloseButton).x;
        }
        else if (!(host_window->Flags & ImGuiWindowFlags_DockNodeHost))
        {
            tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_window->Name, host_window->HasCloseButton).x; // Account for slight offset which will be added when changing from title bar to tab bar
        }

        // Draw tab shape/label preview (payload may be a loose window or a host window carrying multiple tabbed windows)
        if (root_payload->DockNodeAsHost)
            IM_ASSERT(root_payload->DockNodeAsHost->Windows.Size <= root_payload->DockNodeAsHost->TabBar->Tabs.Size);
        ImGuiTabBar* tab_bar_with_payload = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->TabBar : NULL;
        const int payload_count = tab_bar_with_payload ? tab_bar_with_payload->Tabs.Size : 1;
        for (int payload_n = 0; payload_n < payload_count; payload_n++)
        {
            // DockNode's TabBar may have non-window Tabs manually appended by user
            ImGuiWindow* payload_window = tab_bar_with_payload ? tab_bar_with_payload->Tabs[payload_n].Window : root_payload;
            if (tab_bar_with_payload && payload_window == NULL)
                continue;
            if (!DockNodeIsDropAllowedOne(payload_window, host_window))
                continue;

            // Calculate the tab bounding box for each payload window
            ImVec2 tab_size = TabItemCalcSize(payload_window->Name, payload_window->HasCloseButton);
            ImRect tab_bb(tab_pos.x, tab_pos.y, tab_pos.x + tab_size.x, tab_pos.y + tab_size.y);
            tab_pos.x += tab_size.x + g.Style.ItemInnerSpacing.x;
            const ImU32 overlay_col_text = GetColorU32(payload_window->DockStyle.Colors[ImGuiWindowDockStyleCol_Text]);
            const ImU32 overlay_col_tabs = GetColorU32(payload_window->DockStyle.Colors[ImGuiWindowDockStyleCol_TabActive]);
            PushStyleColor(ImGuiCol_Text, overlay_col_text);
            for (int overlay_n = 0; overlay_n < overlay_draw_lists_count; overlay_n++)
            {
                ImGuiTabItemFlags tab_flags = ImGuiTabItemFlags_Preview | ((payload_window->Flags & ImGuiWindowFlags_UnsavedDocument) ? ImGuiTabItemFlags_UnsavedDocument : 0);
                if (!tab_bar_rect.Contains(tab_bb))
                    overlay_draw_lists[overlay_n]->PushClipRect(tab_bar_rect.Min, tab_bar_rect.Max);
                TabItemBackground(overlay_draw_lists[overlay_n], tab_bb, tab_flags, overlay_col_tabs);
                TabItemLabelAndCloseButton(overlay_draw_lists[overlay_n], tab_bb, tab_flags, g.Style.FramePadding, payload_window->Name, 0, 0, false, NULL, NULL);
                if (!tab_bar_rect.Contains(tab_bb))
                    overlay_draw_lists[overlay_n]->PopClipRect();
            }
            PopStyleColor();
        }
    }

    // Display drop boxes
    const float overlay_rounding = ImMax(3.0f, g.Style.FrameRounding);
    for (int dir = ImGuiDir_None; dir < ImGuiDir_COUNT; dir++)
    {
        if (!data->DropRectsDraw[dir + 1].IsInverted())
        {
            ImRect draw_r = data->DropRectsDraw[dir + 1];
            ImRect draw_r_in = draw_r;
            draw_r_in.Expand(-2.0f);
            ImU32 overlay_col = (data->SplitDir == (ImGuiDir)dir && data->IsSplitDirExplicit) ? overlay_col_drop_hovered : overlay_col_drop;
            for (int overlay_n = 0; overlay_n < overlay_draw_lists_count; overlay_n++)
            {
                ImVec2 center = ImFloor(draw_r_in.GetCenter());
                overlay_draw_lists[overlay_n]->AddRectFilled(draw_r.Min, draw_r.Max, overlay_col, overlay_rounding);
                overlay_draw_lists[overlay_n]->AddRect(draw_r_in.Min, draw_r_in.Max, overlay_col_lines, overlay_rounding);
                if (dir == ImGuiDir_Left || dir == ImGuiDir_Right)
                    overlay_draw_lists[overlay_n]->AddLine(ImVec2(center.x, draw_r_in.Min.y), ImVec2(center.x, draw_r_in.Max.y), overlay_col_lines);
                if (dir == ImGuiDir_Up || dir == ImGuiDir_Down)
                    overlay_draw_lists[overlay_n]->AddLine(ImVec2(draw_r_in.Min.x, center.y), ImVec2(draw_r_in.Max.x, center.y), overlay_col_lines);
            }
        }

        // Stop after ImGuiDir_None
        if ((host_node && (host_node->GetMergedFlags() & ImGuiDockNodeFlags_NoSplit)) || g.IO.ConfigDockingNoSplit)
            return;
    }
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockNode Tree manipulation functions
//-----------------------------------------------------------------------------
// - DockNodeTreeSplit()
// - DockNodeTreeMerge()
// - DockNodeTreeUpdatePosSize()
// - DockNodeTreeUpdateSplitterFindTouchingNode()
// - DockNodeTreeUpdateSplitter()
// - DockNodeTreeFindFallbackLeafNode()
// - DockNodeTreeFindNodeByPos()
//-----------------------------------------------------------------------------

void ImGui::DockNodeTreeSplit(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiAxis split_axis, int split_inheritor_child_idx, float split_ratio, ImGuiDockNode* new_node)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(split_axis != ImGuiAxis_None);

    ImGuiDockNode* child_0 = (new_node && split_inheritor_child_idx != 0) ? new_node : DockContextAddNode(ctx, 0);
    child_0->ParentNode = parent_node;

    ImGuiDockNode* child_1 = (new_node && split_inheritor_child_idx != 1) ? new_node : DockContextAddNode(ctx, 0);
    child_1->ParentNode = parent_node;

    ImGuiDockNode* child_inheritor = (split_inheritor_child_idx == 0) ? child_0 : child_1;
    DockNodeMoveChildNodes(child_inheritor, parent_node);
    parent_node->ChildNodes[0] = child_0;
    parent_node->ChildNodes[1] = child_1;
    parent_node->ChildNodes[split_inheritor_child_idx]->VisibleWindow = parent_node->VisibleWindow;
    parent_node->SplitAxis = split_axis;
    parent_node->VisibleWindow = NULL;
    parent_node->AuthorityForPos = parent_node->AuthorityForSize = ImGuiDataAuthority_DockNode;

    float size_avail = (parent_node->Size[split_axis] - DOCKING_SPLITTER_SIZE);
    size_avail = ImMax(size_avail, g.Style.WindowMinSize[split_axis] * 2.0f);
    IM_ASSERT(size_avail > 0.0f); // If you created a node manually with DockBuilderAddNode(), you need to also call DockBuilderSetNodeSize() before splitting.
    child_0->SizeRef = child_1->SizeRef = parent_node->Size;
    child_0->SizeRef[split_axis] = ImFloor(size_avail * split_ratio);
    child_1->SizeRef[split_axis] = ImFloor(size_avail - child_0->SizeRef[split_axis]);

    DockNodeMoveWindows(parent_node->ChildNodes[split_inheritor_child_idx], parent_node);
    DockSettingsRenameNodeReferences(parent_node->ID, parent_node->ChildNodes[split_inheritor_child_idx]->ID);
    DockNodeTreeUpdatePosSize(parent_node, parent_node->Pos, parent_node->Size);

    // Flags transfer (e.g. this is where we transfer the ImGuiDockNodeFlags_CentralNode property)
    child_0->SharedFlags = parent_node->SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
    child_1->SharedFlags = parent_node->SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
    child_inheritor->LocalFlags = parent_node->LocalFlags & ImGuiDockNodeFlags_LocalFlagsTransferMask_;
    parent_node->LocalFlags &= ~ImGuiDockNodeFlags_LocalFlagsTransferMask_;
    if (child_inheritor->IsCentralNode())
        DockNodeGetRootNode(parent_node)->CentralNode = child_inheritor;
}

void ImGui::DockNodeTreeMerge(ImGuiContext* ctx, ImGuiDockNode* parent_node, ImGuiDockNode* merge_lead_child)
{
    // When called from DockContextProcessUndockNode() it is possible that one of the child is NULL.
    ImGuiDockNode* child_0 = parent_node->ChildNodes[0];
    ImGuiDockNode* child_1 = parent_node->ChildNodes[1];
    IM_ASSERT(child_0 || child_1);
    IM_ASSERT(merge_lead_child == child_0 || merge_lead_child == child_1);
    if ((child_0 && child_0->Windows.Size > 0) || (child_1 && child_1->Windows.Size > 0))
    {
        IM_ASSERT(parent_node->TabBar == NULL);
        IM_ASSERT(parent_node->Windows.Size == 0);
    }
    IMGUI_DEBUG_LOG_DOCKING("DockNodeTreeMerge 0x%08X & 0x%08X back into parent 0x%08X\n", child_0 ? child_0->ID : 0, child_1 ? child_1->ID : 0, parent_node->ID);

    ImVec2 backup_last_explicit_size = parent_node->SizeRef;
    DockNodeMoveChildNodes(parent_node, merge_lead_child);
    if (child_0)
    {
        DockNodeMoveWindows(parent_node, child_0); // Generally only 1 of the 2 child node will have windows
        DockSettingsRenameNodeReferences(child_0->ID, parent_node->ID);
    }
    if (child_1)
    {
        DockNodeMoveWindows(parent_node, child_1);
        DockSettingsRenameNodeReferences(child_1->ID, parent_node->ID);
    }
    DockNodeApplyPosSizeToWindows(parent_node);
    parent_node->AuthorityForPos = parent_node->AuthorityForSize = parent_node->AuthorityForViewport = ImGuiDataAuthority_Auto;
    parent_node->VisibleWindow = merge_lead_child->VisibleWindow;
    parent_node->SizeRef = backup_last_explicit_size;

    // Flags transfer
    parent_node->LocalFlags &= ~ImGuiDockNodeFlags_LocalFlagsTransferMask_; // Preserve Dockspace flag
    parent_node->LocalFlags |= (child_0 ? child_0->LocalFlags : 0) & ImGuiDockNodeFlags_LocalFlagsTransferMask_;
    parent_node->LocalFlags |= (child_1 ? child_1->LocalFlags : 0) & ImGuiDockNodeFlags_LocalFlagsTransferMask_;

    if (child_0)
    {
        ctx->DockContext.Nodes.SetVoidPtr(child_0->ID, NULL);
        IM_DELETE(child_0);
    }
    if (child_1)
    {
        ctx->DockContext.Nodes.SetVoidPtr(child_1->ID, NULL);
        IM_DELETE(child_1);
    }
}

// Update Pos/Size for a node hierarchy (don't affect child Windows yet)
void ImGui::DockNodeTreeUpdatePosSize(ImGuiDockNode* node, ImVec2 pos, ImVec2 size, bool only_write_to_marked_nodes)
{
    // During the regular dock node update we write to all nodes.
    // 'only_write_to_marked_nodes' is only set when turning a node visible mid-frame and we need its size right-away.
    const bool write_to_node = (only_write_to_marked_nodes == false) || (node->MarkedForPosSizeWrite);
    if (write_to_node)
    {
        node->Pos = pos;
        node->Size = size;
    }

    if (node->IsLeafNode())
        return;

    ImGuiDockNode* child_0 = node->ChildNodes[0];
    ImGuiDockNode* child_1 = node->ChildNodes[1];
    ImVec2 child_0_pos = pos, child_1_pos = pos;
    ImVec2 child_0_size = size, child_1_size = size;
    if (child_0->IsVisible && child_1->IsVisible)
    {
        const float spacing = DOCKING_SPLITTER_SIZE;
        const ImGuiAxis axis = (ImGuiAxis)node->SplitAxis;
        const float size_avail = ImMax(size[axis] - spacing, 0.0f);

        // Size allocation policy
        // 1) The first 0..WindowMinSize[axis]*2 are allocated evenly to both windows.
        ImGuiContext& g = *GImGui;
        const float size_min_each = ImFloor(ImMin(size_avail, g.Style.WindowMinSize[axis] * 2.0f) * 0.5f);

        // 2) Process locked absolute size (during a splitter resize we preserve the child of nodes not touching the splitter edge)
        if (child_0->WantLockSizeOnce && !child_1->WantLockSizeOnce)
        {
            child_0_size[axis] = child_0->SizeRef[axis] = ImMin(size_avail - 1.0f, child_0->Size[axis]);
            child_1_size[axis] = child_1->SizeRef[axis] = (size_avail - child_0_size[axis]);
            IM_ASSERT(child_0->SizeRef[axis] > 0.0f && child_1->SizeRef[axis] > 0.0f);
        }
        else if (child_1->WantLockSizeOnce && !child_0->WantLockSizeOnce)
        {
            child_1_size[axis] = child_1->SizeRef[axis] = ImMin(size_avail - 1.0f, child_1->Size[axis]);
            child_0_size[axis] = child_0->SizeRef[axis] = (size_avail - child_1_size[axis]);
            IM_ASSERT(child_0->SizeRef[axis] > 0.0f && child_1->SizeRef[axis] > 0.0f);
        }
        else if (child_0->WantLockSizeOnce && child_1->WantLockSizeOnce)
        {
            // FIXME-DOCK: We cannot honor the requested size, so apply ratio.
            // Currently this path will only be taken if code programmatically sets WantLockSizeOnce
            float ratio_0 = child_0_size[axis] / (child_0_size[axis] + child_1_size[axis]);
            child_0_size[axis] = child_0->SizeRef[axis] = ImFloor(size_avail * ratio_0);
            child_1_size[axis] = child_1->SizeRef[axis] = (size_avail - child_0_size[axis]);
            IM_ASSERT(child_0->SizeRef[axis] > 0.0f && child_1->SizeRef[axis] > 0.0f);
        }

        // 3) If one window is the central node (~ use remaining space, should be made explicit!), use explicit size from the other, and remainder for the central node
        else if (child_1->IsCentralNode() && child_0->SizeRef[axis] != 0.0f)
        {
            child_0_size[axis] = ImMin(size_avail - size_min_each, child_0->SizeRef[axis]);
            child_1_size[axis] = (size_avail - child_0_size[axis]);
        }
        else if (child_0->IsCentralNode() && child_1->SizeRef[axis] != 0.0f)
        {
            child_1_size[axis] = ImMin(size_avail - size_min_each, child_1->SizeRef[axis]);
            child_0_size[axis] = (size_avail - child_1_size[axis]);
        }
        else
        {
            // 4) Otherwise distribute according to the relative ratio of each SizeRef value
            float split_ratio = child_0->SizeRef[axis] / (child_0->SizeRef[axis] + child_1->SizeRef[axis]);
            child_0_size[axis] = ImMax(size_min_each, ImFloor(size_avail * split_ratio + 0.5F));
            child_1_size[axis] = (size_avail - child_0_size[axis]);
        }

        child_1_pos[axis] += spacing + child_0_size[axis];
    }
    child_0->WantLockSizeOnce = child_1->WantLockSizeOnce = false;

    if (child_0->IsVisible)
        DockNodeTreeUpdatePosSize(child_0, child_0_pos, child_0_size);
    if (child_1->IsVisible)
        DockNodeTreeUpdatePosSize(child_1, child_1_pos, child_1_size);
}

static void DockNodeTreeUpdateSplitterFindTouchingNode(ImGuiDockNode* node, ImGuiAxis axis, int side, ImVector<ImGuiDockNode*>* touching_nodes)
{
    if (node->IsLeafNode())
    {
        touching_nodes->push_back(node);
        return;
    }
    if (node->ChildNodes[0]->IsVisible)
        if (node->SplitAxis != axis || side == 0 || !node->ChildNodes[1]->IsVisible)
            DockNodeTreeUpdateSplitterFindTouchingNode(node->ChildNodes[0], axis, side, touching_nodes);
    if (node->ChildNodes[1]->IsVisible)
        if (node->SplitAxis != axis || side == 1 || !node->ChildNodes[0]->IsVisible)
            DockNodeTreeUpdateSplitterFindTouchingNode(node->ChildNodes[1], axis, side, touching_nodes);
}

void ImGui::DockNodeTreeUpdateSplitter(ImGuiDockNode* node)
{
    if (node->IsLeafNode())
        return;

    ImGuiContext& g = *GImGui;

    ImGuiDockNode* child_0 = node->ChildNodes[0];
    ImGuiDockNode* child_1 = node->ChildNodes[1];
    if (child_0->IsVisible && child_1->IsVisible)
    {
        // Bounding box of the splitter cover the space between both nodes (w = Spacing, h = Size[xy^1] for when splitting horizontally)
        const ImGuiAxis axis = (ImGuiAxis)node->SplitAxis;
        IM_ASSERT(axis != ImGuiAxis_None);
        ImRect bb;
        bb.Min = child_0->Pos;
        bb.Max = child_1->Pos;
        bb.Min[axis] += child_0->Size[axis];
        bb.Max[axis ^ 1] += child_1->Size[axis ^ 1];
        //if (g.IO.KeyCtrl) GetForegroundDrawList(g.CurrentWindow->Viewport)->AddRect(bb.Min, bb.Max, IM_COL32(255,0,255,255));

        const ImGuiDockNodeFlags merged_flags = child_0->GetMergedFlags() | child_1->GetMergedFlags();
        const ImGuiDockNodeFlags no_resize_axis_flag = (axis == ImGuiAxis_X) ? ImGuiDockNodeFlags_NoResizeX : ImGuiDockNodeFlags_NoResizeY;
        if ((merged_flags & ImGuiDockNodeFlags_NoResize) || (merged_flags & no_resize_axis_flag))
        {
            ImGuiWindow* window = g.CurrentWindow;
            window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator), g.Style.FrameRounding);
        }
        else
        {
            //bb.Min[axis] += 1; // Display a little inward so highlight doesn't connect with nearby tabs on the neighbor node.
            //bb.Max[axis] -= 1;
            PushID(node->ID);

            // Gather list of nodes that are touching the splitter line. Find resizing limits based on those nodes.
            ImVector<ImGuiDockNode*> touching_nodes[2];
            float min_size = g.Style.WindowMinSize[axis];
            float resize_limits[2];
            resize_limits[0] = node->ChildNodes[0]->Pos[axis] + min_size;
            resize_limits[1] = node->ChildNodes[1]->Pos[axis] + node->ChildNodes[1]->Size[axis] - min_size;

            ImGuiID splitter_id = GetID("##Splitter");
            if (g.ActiveId == splitter_id)
            {
                // Only process when splitter is active
                DockNodeTreeUpdateSplitterFindTouchingNode(child_0, axis, 1, &touching_nodes[0]);
                DockNodeTreeUpdateSplitterFindTouchingNode(child_1, axis, 0, &touching_nodes[1]);
                for (int touching_node_n = 0; touching_node_n < touching_nodes[0].Size; touching_node_n++)
                    resize_limits[0] = ImMax(resize_limits[0], touching_nodes[0][touching_node_n]->Rect().Min[axis] + min_size);
                for (int touching_node_n = 0; touching_node_n < touching_nodes[1].Size; touching_node_n++)
                    resize_limits[1] = ImMin(resize_limits[1], touching_nodes[1][touching_node_n]->Rect().Max[axis] - min_size);

                /*
                // [DEBUG] Render limits
                ImDrawList* draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
                for (int n = 0; n < 2; n++)
                    if (axis == ImGuiAxis_X)
                        draw_list->AddLine(ImVec2(resize_limits[n], node->ChildNodes[n]->Pos.y), ImVec2(resize_limits[n], node->ChildNodes[n]->Pos.y + node->ChildNodes[n]->Size.y), IM_COL32(255, 0, 255, 255), 3.0f);
                    else
                        draw_list->AddLine(ImVec2(node->ChildNodes[n]->Pos.x, resize_limits[n]), ImVec2(node->ChildNodes[n]->Pos.x + node->ChildNodes[n]->Size.x, resize_limits[n]), IM_COL32(255, 0, 255, 255), 3.0f);
                */
            }

            // Use a short delay before highlighting the splitter (and changing the mouse cursor) in order for regular mouse movement to not highlight many splitters
            float cur_size_0 = child_0->Size[axis];
            float cur_size_1 = child_1->Size[axis];
            float min_size_0 = resize_limits[0] - child_0->Pos[axis];
            float min_size_1 = child_1->Pos[axis] + child_1->Size[axis] - resize_limits[1];
            if (SplitterBehavior(bb, GetID("##Splitter"), axis, &cur_size_0, &cur_size_1, min_size_0, min_size_1, WINDOWS_HOVER_PADDING, WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER))
            {
                if (touching_nodes[0].Size > 0 && touching_nodes[1].Size > 0)
                {
                    child_0->Size[axis] = child_0->SizeRef[axis] = cur_size_0;
                    child_1->Pos[axis] -= cur_size_1 - child_1->Size[axis];
                    child_1->Size[axis] = child_1->SizeRef[axis] = cur_size_1;

                    // Lock the size of every node that is a sibling of the node we are touching
                    // This might be less desirable if we can merge sibling of a same axis into the same parental level.
                    for (int side_n = 0; side_n < 2; side_n++)
                        for (int touching_node_n = 0; touching_node_n < touching_nodes[side_n].Size; touching_node_n++)
                        {
                            ImGuiDockNode* touching_node = touching_nodes[side_n][touching_node_n];
                            //ImDrawList* draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
                            //draw_list->AddRect(touching_node->Pos, touching_node->Pos + touching_node->Size, IM_COL32(255, 128, 0, 255));
                            while (touching_node->ParentNode != node)
                            {
                                if (touching_node->ParentNode->SplitAxis == axis)
                                {
                                    // Mark other node so its size will be preserved during the upcoming call to DockNodeTreeUpdatePosSize().
                                    ImGuiDockNode* node_to_preserve = touching_node->ParentNode->ChildNodes[side_n];
                                    node_to_preserve->WantLockSizeOnce = true;
                                    //draw_list->AddRect(touching_node->Pos, touching_node->Rect().Max, IM_COL32(255, 0, 0, 255));
                                    //draw_list->AddRectFilled(node_to_preserve->Pos, node_to_preserve->Rect().Max, IM_COL32(0, 255, 0, 100));
                                }
                                touching_node = touching_node->ParentNode;
                            }
                        }

                    DockNodeTreeUpdatePosSize(child_0, child_0->Pos, child_0->Size);
                    DockNodeTreeUpdatePosSize(child_1, child_1->Pos, child_1->Size);
                    MarkIniSettingsDirty();
                }
            }
            PopID();
        }
    }

    if (child_0->IsVisible)
        DockNodeTreeUpdateSplitter(child_0);
    if (child_1->IsVisible)
        DockNodeTreeUpdateSplitter(child_1);
}

ImGuiDockNode* ImGui::DockNodeTreeFindFallbackLeafNode(ImGuiDockNode* node)
{
    if (node->IsLeafNode())
        return node;
    if (ImGuiDockNode* leaf_node = DockNodeTreeFindFallbackLeafNode(node->ChildNodes[0]))
        return leaf_node;
    if (ImGuiDockNode* leaf_node = DockNodeTreeFindFallbackLeafNode(node->ChildNodes[1]))
        return leaf_node;
    return NULL;
}

ImGuiDockNode* ImGui::DockNodeTreeFindVisibleNodeByPos(ImGuiDockNode* node, ImVec2 pos)
{
    if (!node->IsVisible)
        return NULL;

    const float dock_spacing = 0.0f;// g.Style.ItemInnerSpacing.x; // FIXME: Relation to DOCKING_SPLITTER_SIZE?
    ImRect r(node->Pos, node->Pos + node->Size);
    r.Expand(dock_spacing * 0.5f);
    bool inside = r.Contains(pos);
    if (!inside)
        return NULL;

    if (node->IsLeafNode())
        return node;
    if (ImGuiDockNode* hovered_node = DockNodeTreeFindVisibleNodeByPos(node->ChildNodes[0], pos))
        return hovered_node;
    if (ImGuiDockNode* hovered_node = DockNodeTreeFindVisibleNodeByPos(node->ChildNodes[1], pos))
        return hovered_node;

    return NULL;
}

//-----------------------------------------------------------------------------
// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
//-----------------------------------------------------------------------------
// - SetWindowDock() [Internal]
// - DockSpace()
// - DockSpaceOverViewport()
//-----------------------------------------------------------------------------

// [Internal] Called via SetNextWindowDockID()
void ImGui::SetWindowDock(ImGuiWindow* window, ImGuiID dock_id, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowDockAllowFlags & cond) == 0)
        return;
    window->SetWindowDockAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    if (window->DockId == dock_id)
        return;

    // If the user attempt to set a dock id that is a split node, we'll dig within to find a suitable docking spot
    ImGuiContext* ctx = GImGui;
    if (ImGuiDockNode* new_node = DockContextFindNodeByID(ctx, dock_id))
        if (new_node->IsSplitNode())
        {
            // Policy: Find central node or latest focused node. We first move back to our root node.
            new_node = DockNodeGetRootNode(new_node);
            if (new_node->CentralNode)
            {
                IM_ASSERT(new_node->CentralNode->IsCentralNode());
                dock_id = new_node->CentralNode->ID;
            }
            else
            {
                dock_id = new_node->LastFocusedNodeId;
            }
        }

    if (window->DockId == dock_id)
        return;

    if (window->DockNode)
        DockNodeRemoveWindow(window->DockNode, window, 0);
    window->DockId = dock_id;
}

// Create an explicit dockspace node within an existing window. Also expose dock node flags and creates a CentralNode by default.
// The Central Node is always displayed even when empty and shrink/extend according to the requested size of its neighbors.
// DockSpace() needs to be submitted _before_ any window they can host. If you use a dockspace, submit it early in your app.
ImGuiID ImGui::DockSpace(ImGuiID id, const ImVec2& size_arg, ImGuiDockNodeFlags flags, const ImGuiWindowClass* window_class)
{
    ImGuiContext* ctx = GImGui;
    ImGuiContext& g = *ctx;
    ImGuiWindow* window = GetCurrentWindow();
    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        return 0;

    // Early out if parent window is hidden/collapsed
    // This is faster but also DockNodeUpdateTabBar() relies on TabBarLayout() running (which won't if SkipItems=true) to set NextSelectedTabId = 0). See #2960.
    // If for whichever reason this is causing problem we would need to ensure that DockNodeUpdateTabBar() ends up clearing NextSelectedTabId even if SkipItems=true.
    if (window->SkipItems)
        flags |= ImGuiDockNodeFlags_KeepAliveOnly;

    IM_ASSERT((flags & ImGuiDockNodeFlags_DockSpace) == 0);
    IM_ASSERT(id != 0);
    ImGuiDockNode* node = DockContextFindNodeByID(ctx, id);
    if (!node)
    {
        IMGUI_DEBUG_LOG_DOCKING("DockSpace: dockspace node 0x%08X created\n", id);
        node = DockContextAddNode(ctx, id);
        node->LocalFlags |= ImGuiDockNodeFlags_CentralNode;
    }
    if (window_class && window_class->ClassId != node->WindowClass.ClassId)
        IMGUI_DEBUG_LOG_DOCKING("DockSpace: dockspace node 0x%08X: setup WindowClass 0x%08X -> 0x%08X\n", id, node->WindowClass.ClassId, window_class->ClassId);
    node->SharedFlags = flags;
    node->WindowClass = window_class ? *window_class : ImGuiWindowClass();

    // When a DockSpace transitioned form implicit to explicit this may be called a second time
    // It is possible that the node has already been claimed by a docked window which appeared before the DockSpace() node, so we overwrite IsDockSpace again.
    if (node->LastFrameActive == g.FrameCount && !(flags & ImGuiDockNodeFlags_KeepAliveOnly))
    {
        IM_ASSERT(node->IsDockSpace() == false && "Cannot call DockSpace() twice a frame with the same ID");
        node->LocalFlags |= ImGuiDockNodeFlags_DockSpace;
        return id;
    }
    node->LocalFlags |= ImGuiDockNodeFlags_DockSpace;

    // Keep alive mode, this is allow windows docked into this node so stay docked even if they are not visible
    if (flags & ImGuiDockNodeFlags_KeepAliveOnly)
    {
        node->LastFrameAlive = g.FrameCount;
        return id;
    }

    const ImVec2 content_avail = GetContentRegionAvail();
    ImVec2 size = ImFloor(size_arg);
    if (size.x <= 0.0f)
        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
    if (size.y <= 0.0f)
        size.y = ImMax(content_avail.y + size.y, 4.0f);
    IM_ASSERT(size.x > 0.0f && size.y > 0.0f);

    node->Pos = window->DC.CursorPos;
    node->Size = node->SizeRef = size;
    SetNextWindowPos(node->Pos);
    SetNextWindowSize(node->Size);
    g.NextWindowData.PosUndock = false;

    // FIXME-DOCK: Why do we need a child window to host a dockspace, could we host it in the existing window?
    // FIXME-DOCK: What is the reason for not simply calling BeginChild()? (OK to have a reason but should be commented)
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_DockNodeHost;
    window_flags |= ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar;
    window_flags |= ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse;
    window_flags |= ImGuiWindowFlags_NoBackground;

    char title[256];
    ImFormatString(title, IM_ARRAYSIZE(title), "%s/DockSpace_%08X", window->Name, id);

    PushStyleVar(ImGuiStyleVar_ChildBorderSize, 0.0f);
    Begin(title, NULL, window_flags);
    PopStyleVar();

    ImGuiWindow* host_window = g.CurrentWindow;
    host_window->DockNodeAsHost = node;
    host_window->ChildId = window->GetID(title);
    node->HostWindow = host_window;
    node->OnlyNodeWithWindows = NULL;

    IM_ASSERT(node->IsRootNode());

    // We need to handle the rare case were a central node is missing.
    // This can happen if the node was first created manually with DockBuilderAddNode() but _without_ the ImGuiDockNodeFlags_Dockspace.
    // Doing it correctly would set the _CentralNode flags, which would then propagate according to subsequent split.
    // It would also be ambiguous to attempt to assign a central node while there are split nodes, so we wait until there's a single node remaining.
    // The specific sub-property of _CentralNode we are interested in recovering here is the "Don't delete when empty" property,
    // as it doesn't make sense for an empty dockspace to not have this property.
    if (node->IsLeafNode() && !node->IsCentralNode())
        node->LocalFlags |= ImGuiDockNodeFlags_CentralNode;

    // Update the node
    DockNodeUpdate(node);

    End();
    ItemSize(size);
    return id;
}

// Tips: Use with ImGuiDockNodeFlags_PassthruCentralNode!
// The limitation with this call is that your window won't have a menu bar.
// Even though we could pass window flags, it would also require the user to be able to call BeginMenuBar() somehow meaning we can't Begin/End in a single function.
// But you can also use BeginMainMenuBar(). If you really want a menu bar inside the same window as the one hosting the dockspace, you will need to copy this code somewhere and tweak it.
ImGuiID ImGui::DockSpaceOverViewport(const ImGuiViewport* viewport, ImGuiDockNodeFlags dockspace_flags, const ImGuiWindowClass* window_class)
{
    if (viewport == NULL)
        viewport = GetMainViewport();

    SetNextWindowPos(viewport->WorkPos);
    SetNextWindowSize(viewport->WorkSize);
    SetNextWindowViewport(viewport->ID);

    ImGuiWindowFlags host_window_flags = 0;
    host_window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoDocking;
    host_window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
    if (dockspace_flags & ImGuiDockNodeFlags_PassthruCentralNode)
        host_window_flags |= ImGuiWindowFlags_NoBackground;

    char label[32];
    ImFormatString(label, IM_ARRAYSIZE(label), "DockSpaceViewport_%08X", viewport->ID);

    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
    PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
    Begin(label, NULL, host_window_flags);
    PopStyleVar(3);

    ImGuiID dockspace_id = GetID("DockSpace");
    DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), dockspace_flags, window_class);
    End();

    return dockspace_id;
}

//-----------------------------------------------------------------------------
// Docking: Builder Functions
//-----------------------------------------------------------------------------
// Very early end-user API to manipulate dock nodes.
// Only available in imgui_internal.h. Expect this API to change/break!
// It is expected that those functions are all called _before_ the dockspace node submission.
//-----------------------------------------------------------------------------
// - DockBuilderDockWindow()
// - DockBuilderGetNode()
// - DockBuilderSetNodePos()
// - DockBuilderSetNodeSize()
// - DockBuilderAddNode()
// - DockBuilderRemoveNode()
// - DockBuilderRemoveNodeChildNodes()
// - DockBuilderRemoveNodeDockedWindows()
// - DockBuilderSplitNode()
// - DockBuilderCopyNodeRec()
// - DockBuilderCopyNode()
// - DockBuilderCopyWindowSettings()
// - DockBuilderCopyDockSpace()
// - DockBuilderFinish()
//-----------------------------------------------------------------------------

void ImGui::DockBuilderDockWindow(const char* window_name, ImGuiID node_id)
{
    // We don't preserve relative order of multiple docked windows (by clearing DockOrder back to -1)
    ImGuiID window_id = ImHashStr(window_name);
    if (ImGuiWindow* window = FindWindowByID(window_id))
    {
        // Apply to created window
        SetWindowDock(window, node_id, ImGuiCond_Always);
        window->DockOrder = -1;
    }
    else
    {
        // Apply to settings
        ImGuiWindowSettings* settings = FindWindowSettings(window_id);
        if (settings == NULL)
            settings = CreateNewWindowSettings(window_name);
        settings->DockId = node_id;
        settings->DockOrder = -1;
    }
}

ImGuiDockNode* ImGui::DockBuilderGetNode(ImGuiID node_id)
{
    ImGuiContext* ctx = GImGui;
    return DockContextFindNodeByID(ctx, node_id);
}

void ImGui::DockBuilderSetNodePos(ImGuiID node_id, ImVec2 pos)
{
    ImGuiContext* ctx = GImGui;
    ImGuiDockNode* node = DockContextFindNodeByID(ctx, node_id);
    if (node == NULL)
        return;
    node->Pos = pos;
    node->AuthorityForPos = ImGuiDataAuthority_DockNode;
}

void ImGui::DockBuilderSetNodeSize(ImGuiID node_id, ImVec2 size)
{
    ImGuiContext* ctx = GImGui;
    ImGuiDockNode* node = DockContextFindNodeByID(ctx, node_id);
    if (node == NULL)
        return;
    IM_ASSERT(size.x > 0.0f && size.y > 0.0f);
    node->Size = node->SizeRef = size;
    node->AuthorityForSize = ImGuiDataAuthority_DockNode;
}

// Make sure to use the ImGuiDockNodeFlags_DockSpace flag to create a dockspace node! Otherwise this will create a floating node!
// - Floating node: you can then call DockBuilderSetNodePos()/DockBuilderSetNodeSize() to position and size the floating node.
// - Dockspace node: calling DockBuilderSetNodePos() is unnecessary.
// - If you intend to split a node immediately after creation using DockBuilderSplitNode(), make sure to call DockBuilderSetNodeSize() beforehand!
//   For various reason, the splitting code currently needs a base size otherwise space may not be allocated as precisely as you would expect.
// - Use (id == 0) to let the system allocate a node identifier.
// - Existing node with a same id will be removed.
ImGuiID ImGui::DockBuilderAddNode(ImGuiID id, ImGuiDockNodeFlags flags)
{
    ImGuiContext* ctx = GImGui;
    ImGuiDockNode* node = NULL;

    if (id != 0)
        DockBuilderRemoveNode(id);

    if (flags & ImGuiDockNodeFlags_DockSpace)
    {
        DockSpace(id, ImVec2(0, 0), (flags & ~ImGuiDockNodeFlags_DockSpace) | ImGuiDockNodeFlags_KeepAliveOnly);
        node = DockContextFindNodeByID(ctx, id);
    }
    else
    {
        node = DockContextAddNode(ctx, id);
        node->LocalFlags = flags;
    }
    node->LastFrameAlive = ctx->FrameCount;   // Set this otherwise BeginDocked will undock during the same frame.
    return node->ID;
}

void ImGui::DockBuilderRemoveNode(ImGuiID node_id)
{
    ImGuiContext* ctx = GImGui;
    ImGuiDockNode* node = DockContextFindNodeByID(ctx, node_id);
    if (node == NULL)
        return;
    DockBuilderRemoveNodeDockedWindows(node_id, true);
    DockBuilderRemoveNodeChildNodes(node_id);
    if (node->IsCentralNode() && node->ParentNode)
        node->ParentNode->LocalFlags |= ImGuiDockNodeFlags_CentralNode;
    DockContextRemoveNode(ctx, node, true);
}

// root_id = 0 to remove all, root_id != 0 to remove child of given node.
void ImGui::DockBuilderRemoveNodeChildNodes(ImGuiID root_id)
{
    ImGuiContext* ctx = GImGui;
    ImGuiDockContext* dc  = &ctx->DockContext;

    ImGuiDockNode* root_node = root_id ? DockContextFindNodeByID(ctx, root_id) : NULL;
    if (root_id && root_node == NULL)
        return;
    bool has_central_node = false;

    ImGuiDataAuthority backup_root_node_authority_for_pos = root_node ? root_node->AuthorityForPos : ImGuiDataAuthority_Auto;
    ImGuiDataAuthority backup_root_node_authority_for_size = root_node ? root_node->AuthorityForSize : ImGuiDataAuthority_Auto;

    // Process active windows
    ImVector<ImGuiDockNode*> nodes_to_remove;
    for (int n = 0; n < dc->Nodes.Data.Size; n++)
        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
        {
            bool want_removal = (root_id == 0) || (node->ID != root_id && DockNodeGetRootNode(node)->ID == root_id);
            if (want_removal)
            {
                if (node->IsCentralNode())
                    has_central_node = true;
                if (root_id != 0)
                    DockContextQueueNotifyRemovedNode(ctx, node);
                if (root_node)
                {
                    DockNodeMoveWindows(root_node, node);
                    DockSettingsRenameNodeReferences(node->ID, root_node->ID);
                }
                nodes_to_remove.push_back(node);
            }
        }

    // DockNodeMoveWindows->DockNodeAddWindow will normally set those when reaching two windows (which is only adequate during interactive merge)
    // Make sure we don't lose our current pos/size. (FIXME-DOCK: Consider tidying up that code in DockNodeAddWindow instead)
    if (root_node)
    {
        root_node->AuthorityForPos = backup_root_node_authority_for_pos;
        root_node->AuthorityForSize = backup_root_node_authority_for_size;
    }

    // Apply to settings
    for (ImGuiWindowSettings* settings = ctx->SettingsWindows.begin(); settings != NULL; settings = ctx->SettingsWindows.next_chunk(settings))
        if (ImGuiID window_settings_dock_id = settings->DockId)
            for (int n = 0; n < nodes_to_remove.Size; n++)
                if (nodes_to_remove[n]->ID == window_settings_dock_id)
                {
                    settings->DockId = root_id;
                    break;
                }

    // Not really efficient, but easier to destroy a whole hierarchy considering DockContextRemoveNode is attempting to merge nodes
    if (nodes_to_remove.Size > 1)
        ImQsort(nodes_to_remove.Data, nodes_to_remove.Size, sizeof(ImGuiDockNode*), DockNodeComparerDepthMostFirst);
    for (int n = 0; n < nodes_to_remove.Size; n++)
        DockContextRemoveNode(ctx, nodes_to_remove[n], false);

    if (root_id == 0)
    {
        dc->Nodes.Clear();
        dc->Requests.clear();
    }
    else if (has_central_node)
    {
        root_node->LocalFlags |= ImGuiDockNodeFlags_CentralNode;
        root_node->CentralNode = root_node;
    }
}

void ImGui::DockBuilderRemoveNodeDockedWindows(ImGuiID root_id, bool clear_settings_refs)
{
    // Clear references in settings
    ImGuiContext* ctx = GImGui;
    ImGuiContext& g = *ctx;
    if (clear_settings_refs)
    {
        for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        {
            bool want_removal = (root_id == 0) || (settings->DockId == root_id);
            if (!want_removal && settings->DockId != 0)
                if (ImGuiDockNode* node = DockContextFindNodeByID(ctx, settings->DockId))
                    if (DockNodeGetRootNode(node)->ID == root_id)
                        want_removal = true;
            if (want_removal)
                settings->DockId = 0;
        }
    }

    // Clear references in windows
    for (int n = 0; n < g.Windows.Size; n++)
    {
        ImGuiWindow* window = g.Windows[n];
        bool want_removal = (root_id == 0) || (window->DockNode && DockNodeGetRootNode(window->DockNode)->ID == root_id) || (window->DockNodeAsHost && window->DockNodeAsHost->ID == root_id);
        if (want_removal)
        {
            const ImGuiID backup_dock_id = window->DockId;
            IM_UNUSED(backup_dock_id);
            DockContextProcessUndockWindow(ctx, window, clear_settings_refs);
            if (!clear_settings_refs)
                IM_ASSERT(window->DockId == backup_dock_id);
        }
    }
}

// If 'out_id_at_dir' or 'out_id_at_opposite_dir' are non NULL, the function will write out the ID of the two new nodes created.
// Return value is ID of the node at the specified direction, so same as (*out_id_at_dir) if that pointer is set.
// FIXME-DOCK: We are not exposing nor using split_outer.
ImGuiID ImGui::DockBuilderSplitNode(ImGuiID id, ImGuiDir split_dir, float size_ratio_for_node_at_dir, ImGuiID* out_id_at_dir, ImGuiID* out_id_at_opposite_dir)
{
    ImGuiContext* ctx = GImGui;
    IM_ASSERT(split_dir != ImGuiDir_None);
    IMGUI_DEBUG_LOG_DOCKING("DockBuilderSplitNode node 0x%08X, split_dir %d\n", id, split_dir);

    ImGuiDockNode* node = DockContextFindNodeByID(ctx, id);
    if (node == NULL)
    {
        IM_ASSERT(node != NULL);
        return 0;
    }

    IM_ASSERT(!node->IsSplitNode()); // Assert if already Split

    ImGuiDockRequest req;
    req.Type = ImGuiDockRequestType_Split;
    req.DockTargetWindow = NULL;
    req.DockTargetNode = node;
    req.DockPayload = NULL;
    req.DockSplitDir = split_dir;
    req.DockSplitRatio = ImSaturate((split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Up) ? size_ratio_for_node_at_dir : 1.0f - size_ratio_for_node_at_dir);
    req.DockSplitOuter = false;
    DockContextProcessDock(ctx, &req);

    ImGuiID id_at_dir = node->ChildNodes[(split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Up) ? 0 : 1]->ID;
    ImGuiID id_at_opposite_dir = node->ChildNodes[(split_dir == ImGuiDir_Left || split_dir == ImGuiDir_Up) ? 1 : 0]->ID;
    if (out_id_at_dir)
        *out_id_at_dir = id_at_dir;
    if (out_id_at_opposite_dir)
        *out_id_at_opposite_dir = id_at_opposite_dir;
    return id_at_dir;
}

static ImGuiDockNode* DockBuilderCopyNodeRec(ImGuiDockNode* src_node, ImGuiID dst_node_id_if_known, ImVector<ImGuiID>* out_node_remap_pairs)
{
    ImGuiContext* ctx = GImGui;
    ImGuiDockNode* dst_node = ImGui::DockContextAddNode(ctx, dst_node_id_if_known);
    dst_node->SharedFlags = src_node->SharedFlags;
    dst_node->LocalFlags = src_node->LocalFlags;
    dst_node->Pos = src_node->Pos;
    dst_node->Size = src_node->Size;
    dst_node->SizeRef = src_node->SizeRef;
    dst_node->SplitAxis = src_node->SplitAxis;

    out_node_remap_pairs->push_back(src_node->ID);
    out_node_remap_pairs->push_back(dst_node->ID);

    for (int child_n = 0; child_n < IM_ARRAYSIZE(src_node->ChildNodes); child_n++)
        if (src_node->ChildNodes[child_n])
        {
            dst_node->ChildNodes[child_n] = DockBuilderCopyNodeRec(src_node->ChildNodes[child_n], 0, out_node_remap_pairs);
            dst_node->ChildNodes[child_n]->ParentNode = dst_node;
        }

    IMGUI_DEBUG_LOG_DOCKING("Fork node %08X -> %08X (%d childs)\n", src_node->ID, dst_node->ID, dst_node->IsSplitNode() ? 2 : 0);
    return dst_node;
}

void ImGui::DockBuilderCopyNode(ImGuiID src_node_id, ImGuiID dst_node_id, ImVector<ImGuiID>* out_node_remap_pairs)
{
    ImGuiContext* ctx = GImGui;
    IM_ASSERT(src_node_id != 0);
    IM_ASSERT(dst_node_id != 0);
    IM_ASSERT(out_node_remap_pairs != NULL);

    ImGuiDockNode* src_node = DockContextFindNodeByID(ctx, src_node_id);
    IM_ASSERT(src_node != NULL);

    out_node_remap_pairs->clear();
    DockBuilderRemoveNode(dst_node_id);
    DockBuilderCopyNodeRec(src_node, dst_node_id, out_node_remap_pairs);

    IM_ASSERT((out_node_remap_pairs->Size % 2) == 0);
}

void ImGui::DockBuilderCopyWindowSettings(const char* src_name, const char* dst_name)
{
    ImGuiWindow* src_window = FindWindowByName(src_name);
    if (src_window == NULL)
        return;
    if (ImGuiWindow* dst_window = FindWindowByName(dst_name))
    {
        dst_window->Pos = src_window->Pos;
        dst_window->Size = src_window->Size;
        dst_window->SizeFull = src_window->SizeFull;
        dst_window->Collapsed = src_window->Collapsed;
    }
    else if (ImGuiWindowSettings* dst_settings = FindOrCreateWindowSettings(dst_name))
    {
        ImVec2ih window_pos_2ih = ImVec2ih(src_window->Pos);
        if (src_window->ViewportId != 0 && src_window->ViewportId != IMGUI_VIEWPORT_DEFAULT_ID)
        {
            dst_settings->ViewportPos = window_pos_2ih;
            dst_settings->ViewportId = src_window->ViewportId;
            dst_settings->Pos = ImVec2ih(0, 0);
        }
        else
        {
            dst_settings->Pos = window_pos_2ih;
        }
        dst_settings->Size = ImVec2ih(src_window->SizeFull);
        dst_settings->Collapsed = src_window->Collapsed;
    }
}

// FIXME: Will probably want to change this signature, in particular how the window remapping pairs are passed.
void ImGui::DockBuilderCopyDockSpace(ImGuiID src_dockspace_id, ImGuiID dst_dockspace_id, ImVector<const char*>* in_window_remap_pairs)
{
    IM_ASSERT(src_dockspace_id != 0);
    IM_ASSERT(dst_dockspace_id != 0);
    IM_ASSERT(in_window_remap_pairs != NULL);
    IM_ASSERT((in_window_remap_pairs->Size % 2) == 0);

    // Duplicate entire dock
    // FIXME: When overwriting dst_dockspace_id, windows that aren't part of our dockspace window class but that are docked in a same node will be split apart,
    // whereas we could attempt to at least keep them together in a new, same floating node.
    ImVector<ImGuiID> node_remap_pairs;
    DockBuilderCopyNode(src_dockspace_id, dst_dockspace_id, &node_remap_pairs);

    // Attempt to transition all the upcoming windows associated to dst_dockspace_id into the newly created hierarchy of dock nodes
    // (The windows associated to src_dockspace_id are staying in place)
    ImVector<ImGuiID> src_windows;
    for (int remap_window_n = 0; remap_window_n < in_window_remap_pairs->Size; remap_window_n += 2)
    {
        const char* src_window_name = (*in_window_remap_pairs)[remap_window_n];
        const char* dst_window_name = (*in_window_remap_pairs)[remap_window_n + 1];
        ImGuiID src_window_id = ImHashStr(src_window_name);
        src_windows.push_back(src_window_id);

        // Search in the remapping tables
        ImGuiID src_dock_id = 0;
        if (ImGuiWindow* src_window = FindWindowByID(src_window_id))
            src_dock_id = src_window->DockId;
        else if (ImGuiWindowSettings* src_window_settings = FindWindowSettings(src_window_id))
            src_dock_id = src_window_settings->DockId;
        ImGuiID dst_dock_id = 0;
        for (int dock_remap_n = 0; dock_remap_n < node_remap_pairs.Size; dock_remap_n += 2)
            if (node_remap_pairs[dock_remap_n] == src_dock_id)
            {
                dst_dock_id = node_remap_pairs[dock_remap_n + 1];
                //node_remap_pairs[dock_remap_n] = node_remap_pairs[dock_remap_n + 1] = 0; // Clear
                break;
            }

        if (dst_dock_id != 0)
        {
            // Docked windows gets redocked into the new node hierarchy.
            IMGUI_DEBUG_LOG_DOCKING("Remap live window '%s' 0x%08X -> '%s' 0x%08X\n", src_window_name, src_dock_id, dst_window_name, dst_dock_id);
            DockBuilderDockWindow(dst_window_name, dst_dock_id);
        }
        else
        {
            // Floating windows gets their settings transferred (regardless of whether the new window already exist or not)
            // When this is leading to a Copy and not a Move, we would get two overlapping floating windows. Could we possibly dock them together?
            IMGUI_DEBUG_LOG_DOCKING("Remap window settings '%s' -> '%s'\n", src_window_name, dst_window_name);
            DockBuilderCopyWindowSettings(src_window_name, dst_window_name);
        }
    }

    // Anything else in the source nodes of 'node_remap_pairs' are windows that were docked in src_dockspace_id but are not owned by it (unaffiliated windows, e.g. "ImGui Demo")
    // Find those windows and move to them to the cloned dock node. This may be optional?
    for (int dock_remap_n = 0; dock_remap_n < node_remap_pairs.Size; dock_remap_n += 2)
        if (ImGuiID src_dock_id = node_remap_pairs[dock_remap_n])
        {
            ImGuiID dst_dock_id = node_remap_pairs[dock_remap_n + 1];
            ImGuiDockNode* node = DockBuilderGetNode(src_dock_id);
            for (int window_n = 0; window_n < node->Windows.Size; window_n++)
            {
                ImGuiWindow* window = node->Windows[window_n];
                if (src_windows.contains(window->ID))
                    continue;

                // Docked windows gets redocked into the new node hierarchy.
                IMGUI_DEBUG_LOG_DOCKING("Remap window '%s' %08X -> %08X\n", window->Name, src_dock_id, dst_dock_id);
                DockBuilderDockWindow(window->Name, dst_dock_id);
            }
        }
}

void ImGui::DockBuilderFinish(ImGuiID root_id)
{
    ImGuiContext* ctx = GImGui;
    //DockContextRebuild(ctx);
    DockContextBuildAddWindowsToNodes(ctx, root_id);
}

//-----------------------------------------------------------------------------
// Docking: Begin/End Support Functions (called from Begin/End)
//-----------------------------------------------------------------------------
// - GetWindowAlwaysWantOwnTabBar()
// - DockContextBindNodeToWindow()
// - BeginDocked()
// - BeginDockableDragDropSource()
// - BeginDockableDragDropTarget()
//-----------------------------------------------------------------------------

bool ImGui::GetWindowAlwaysWantOwnTabBar(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.IO.ConfigDockingAlwaysTabBar || window->WindowClass.DockingAlwaysTabBar)
        if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking)) == 0)
            if (!window->IsFallbackWindow)    // We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
                return true;
    return false;
}

static ImGuiDockNode* ImGui::DockContextBindNodeToWindow(ImGuiContext* ctx, ImGuiWindow* window)
{
    ImGuiContext& g = *ctx;
    ImGuiDockNode* node = DockContextFindNodeByID(ctx, window->DockId);
    IM_ASSERT(window->DockNode == NULL);

    // We should not be docking into a split node (SetWindowDock should avoid this)
    if (node && node->IsSplitNode())
    {
        DockContextProcessUndockWindow(ctx, window);
        return NULL;
    }

    // Create node
    if (node == NULL)
    {
        node = DockContextAddNode(ctx, window->DockId);
        node->AuthorityForPos = node->AuthorityForSize = node->AuthorityForViewport = ImGuiDataAuthority_Window;
        node->LastFrameAlive = g.FrameCount;
    }

    // If the node just turned visible and is part of a hierarchy, it doesn't have a Size assigned by DockNodeTreeUpdatePosSize() yet,
    // so we're forcing a Pos/Size update from the first ancestor that is already visible (often it will be the root node).
    // If we don't do this, the window will be assigned a zero-size on its first frame, which won't ideally warm up the layout.
    // This is a little wonky because we don't normally update the Pos/Size of visible node mid-frame.
    if (!node->IsVisible)
    {
        ImGuiDockNode* ancestor_node = node;
        while (!ancestor_node->IsVisible)
        {
            ancestor_node->IsVisible = true;
            ancestor_node->MarkedForPosSizeWrite = true;
            if (ancestor_node->ParentNode)
                ancestor_node = ancestor_node->ParentNode;
        }
        IM_ASSERT(ancestor_node->Size.x > 0.0f && ancestor_node->Size.y > 0.0f);
        DockNodeTreeUpdatePosSize(ancestor_node, ancestor_node->Pos, ancestor_node->Size, true);
    }

    // Add window to node
    DockNodeAddWindow(node, window, true);
    IM_ASSERT(node == window->DockNode);
    return node;
}

void ImGui::BeginDocked(ImGuiWindow* window, bool* p_open)
{
    ImGuiContext* ctx = GImGui;
    ImGuiContext& g = *ctx;

    const bool auto_dock_node = GetWindowAlwaysWantOwnTabBar(window);
    if (auto_dock_node)
    {
        if (window->DockId == 0)
        {
            IM_ASSERT(window->DockNode == NULL);
            window->DockId = DockContextGenNodeID(ctx);
        }
    }
    else
    {
        // Calling SetNextWindowPos() undock windows by default (by setting PosUndock)
        bool want_undock = false;
        want_undock |= (window->Flags & ImGuiWindowFlags_NoDocking) != 0;
        want_undock |= (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) && (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) && g.NextWindowData.PosUndock;
        if (want_undock)
        {
            DockContextProcessUndockWindow(ctx, window);
            return;
        }
    }

    // Bind to our dock node
    ImGuiDockNode* node = window->DockNode;
    if (node != NULL)
        IM_ASSERT(window->DockId == node->ID);
    if (window->DockId != 0 && node == NULL)
    {
        node = DockContextBindNodeToWindow(ctx, window);
        if (node == NULL)
            return;
    }

#if 0
    // Undock if the ImGuiDockNodeFlags_NoDockingInCentralNode got set
    if (node->IsCentralNode && (node->Flags & ImGuiDockNodeFlags_NoDockingInCentralNode))
    {
        DockContextProcessUndockWindow(ctx, window);
        return;
    }
#endif

    // Undock if our dockspace node disappeared
    // Note how we are testing for LastFrameAlive and NOT LastFrameActive. A DockSpace node can be maintained alive while being inactive with ImGuiDockNodeFlags_KeepAliveOnly.
    if (node->LastFrameAlive < g.FrameCount)
    {
        // If the window has been orphaned, transition the docknode to an implicit node processed in DockContextNewFrameUpdateDocking()
        ImGuiDockNode* root_node = DockNodeGetRootNode(node);
        if (root_node->LastFrameAlive < g.FrameCount)
        {
            DockContextProcessUndockWindow(ctx, window);
        }
        else
        {
            window->DockIsActive = true;
            window->DockTabIsVisible = false;
        }
        return;
    }

    // Store style overrides
    for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
        window->DockStyle.Colors[color_n] = ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);

    // Fast path return. It is common for windows to hold on a persistent DockId but be the only visible window,
    // and never create neither a host window neither a tab bar.
    // FIXME-DOCK: replace ->HostWindow NULL compare with something more explicit (~was initially intended as a first frame test)
    if (node->HostWindow == NULL)
    {
        window->DockIsActive = (node->State == ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing);
        window->DockTabIsVisible = false;
        if (node->Windows.Size > 1)
            DockNodeHideWindowDuringHostWindowCreation(window);
        return;
    }

    // We can have zero-sized nodes (e.g. children of a small-size dockspace)
    IM_ASSERT(node->HostWindow);
    IM_ASSERT(node->IsLeafNode());
    IM_ASSERT(node->Size.x >= 0.0f && node->Size.y >= 0.0f);
    node->State = ImGuiDockNodeState_HostWindowVisible;

    // Undock if we are submitted earlier than the host window
    if (window->BeginOrderWithinContext < node->HostWindow->BeginOrderWithinContext)
    {
        DockContextProcessUndockWindow(ctx, window);
        return;
    }

    // Position/Size window
    SetNextWindowPos(node->Pos);
    SetNextWindowSize(node->Size);
    g.NextWindowData.PosUndock = false; // Cancel implicit undocking of SetNextWindowPos()
    window->DockIsActive = true;
    window->DockTabIsVisible = false;
    if (node->SharedFlags & ImGuiDockNodeFlags_KeepAliveOnly)
        return;

    // When the window is selected we mark it as visible.
    if (node->VisibleWindow == window)
        window->DockTabIsVisible = true;

    // Update window flag
    IM_ASSERT((window->Flags & ImGuiWindowFlags_ChildWindow) == 0);
    window->Flags |= ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_NoResize;
    if (node->IsHiddenTabBar() || node->IsNoTabBar())
        window->Flags |= ImGuiWindowFlags_NoTitleBar;
    else
        window->Flags &= ~ImGuiWindowFlags_NoTitleBar;      // Clear the NoTitleBar flag in case the user set it: confusingly enough we need a title bar height so we are correctly offset, but it won't be displayed!

    // Save new dock order only if the window has been visible once already
    // This allows multiple windows to be created in the same frame and have their respective dock orders preserved.
    if (node->TabBar && window->WasActive)
        window->DockOrder = (short)DockNodeGetTabOrder(window);

    if ((node->WantCloseAll || node->WantCloseTabId == window->ID) && p_open != NULL)
        *p_open = false;

    // Update ChildId to allow returning from Child to Parent with Escape
    ImGuiWindow* parent_window = window->DockNode->HostWindow;
    window->ChildId = parent_window->GetID(window->Name);
}

void ImGui::BeginDockableDragDropSource(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.ActiveId == window->MoveId);
    IM_ASSERT(g.MovingWindow == window);

    window->DC.LastItemId = window->MoveId;
    window = window->RootWindowDockTree;
    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
    bool is_drag_docking = ImRect(0, 0, window->SizeFull.x, GetFrameHeight()).Contains(g.ActiveIdClickOffset); // FIXME-DOCKING: Need to make this stateful and explicit
    if (is_drag_docking && BeginDragDropSource(ImGuiDragDropFlags_SourceNoPreviewTooltip | ImGuiDragDropFlags_SourceNoHoldToOpenOthers | ImGuiDragDropFlags_SourceAutoExpirePayload))
    {
        SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, sizeof(window));
        EndDragDropSource();

        // Store style overrides
        for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
            window->DockStyle.Colors[color_n] = ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);
    }
}

void ImGui::BeginDockableDragDropTarget(ImGuiWindow* window)
{
    ImGuiContext* ctx = GImGui;
    ImGuiContext& g = *ctx;

    //IM_ASSERT(window->RootWindowDockTree == window); // May also be a DockSpace
    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
    if (!g.DragDropActive)
        return;
    //GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
    if (!BeginDragDropTargetCustom(window->Rect(), window->ID))
        return;

    // Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
    // (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
    const ImGuiPayload* payload = &g.DragDropPayload;
    if (!payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) || !DockNodeIsDropAllowed(window, *(ImGuiWindow**)payload->Data))
    {
        EndDragDropTarget();
        return;
    }

    ImGuiWindow* payload_window = *(ImGuiWindow**)payload->Data;
    if (AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect))
    {
        // Select target node
        // (Important: we cannot use g.HoveredDockNode here! Because each of our target node have filters based on payload, each candidate drop target will do its own evaluation)
        bool dock_into_floating_window = false;
        ImGuiDockNode* node = NULL;
        if (window->DockNodeAsHost)
        {
            // Cannot assume that node will != NULL even though we passed the rectangle test: it depends on padding/spacing handled by DockNodeTreeFindVisibleNodeByPos().
            node = DockNodeTreeFindVisibleNodeByPos(window->DockNodeAsHost, g.IO.MousePos);

            // There is an edge case when docking into a dockspace which only has _inactive_ nodes (because none of the windows are active)
            // In this case we need to fallback into any leaf mode, possibly the central node.
            // FIXME-20181220: We should not have to test for IsLeafNode() here but we have another bug to fix first.
            if (node && node->IsDockSpace() && node->IsRootNode())
                node = (node->CentralNode && node->IsLeafNode()) ? node->CentralNode : DockNodeTreeFindFallbackLeafNode(node);
        }
        else
        {
            if (window->DockNode)
                node = window->DockNode;
            else
                dock_into_floating_window = true; // Dock into a regular window
        }

        const ImRect explicit_target_rect = (node && node->TabBar && !node->IsHiddenTabBar() && !node->IsNoTabBar()) ? node->TabBar->BarRect : ImRect(window->Pos, window->Pos + ImVec2(window->Size.x, GetFrameHeight()));
        const bool is_explicit_target = IsMouseHoveringRect(explicit_target_rect.Min, explicit_target_rect.Max);

        // Preview docking request and find out split direction/ratio
        //const bool do_preview = true;     // Ignore testing for payload->IsPreview() which removes one frame of delay, but breaks overlapping drop targets within the same window.
        const bool do_preview = payload->IsPreview() || payload->IsDelivery();
        if (do_preview && (node != NULL || dock_into_floating_window))
        {
            ImGuiDockPreviewData split_inner;
            ImGuiDockPreviewData split_outer;
            ImGuiDockPreviewData* split_data = &split_inner;
            if (node && (node->ParentNode || node->IsCentralNode()))
                if (ImGuiDockNode* root_node = DockNodeGetRootNode(node))
                {
                    DockNodePreviewDockSetup(window, root_node, payload_window, &split_outer, is_explicit_target, true);
                    if (split_outer.IsSplitDirExplicit)
                        split_data = &split_outer;
                }
            DockNodePreviewDockSetup(window, node, payload_window, &split_inner, is_explicit_target, false);
            if (split_data == &split_outer)
                split_inner.IsDropAllowed = false;

            // Draw inner then outer, so that previewed tab (in inner data) will be behind the outer drop boxes
            DockNodePreviewDockRender(window, node, payload_window, &split_inner);
            DockNodePreviewDockRender(window, node, payload_window, &split_outer);

            // Queue docking request
            if (split_data->IsDropAllowed && payload->IsDelivery())
                DockContextQueueDock(ctx, window, split_data->SplitNode, payload_window, split_data->SplitDir, split_data->SplitRatio, split_data == &split_outer);
        }
    }
    EndDragDropTarget();
}

//-----------------------------------------------------------------------------
// Docking: Settings
//-----------------------------------------------------------------------------
// - DockSettingsRenameNodeReferences()
// - DockSettingsRemoveNodeReferences()
// - DockSettingsFindNodeSettings()
// - DockSettingsHandler_ApplyAll()
// - DockSettingsHandler_ReadOpen()
// - DockSettingsHandler_ReadLine()
// - DockSettingsHandler_DockNodeToSettings()
// - DockSettingsHandler_WriteAll()
//-----------------------------------------------------------------------------

static void ImGui::DockSettingsRenameNodeReferences(ImGuiID old_node_id, ImGuiID new_node_id)
{
    ImGuiContext& g = *GImGui;
    IMGUI_DEBUG_LOG_DOCKING("DockSettingsRenameNodeReferences: from 0x%08X -> to 0x%08X\n", old_node_id, new_node_id);
    for (int window_n = 0; window_n < g.Windows.Size; window_n++)
    {
        ImGuiWindow* window = g.Windows[window_n];
        if (window->DockId == old_node_id && window->DockNode == NULL)
            window->DockId = new_node_id;
    }
    //// FIXME-OPT: We could remove this loop by storing the index in the map
    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        if (settings->DockId == old_node_id)
            settings->DockId = new_node_id;
}

// Remove references stored in ImGuiWindowSettings to the given ImGuiDockNodeSettings
static void ImGui::DockSettingsRemoveNodeReferences(ImGuiID* node_ids, int node_ids_count)
{
    ImGuiContext& g = *GImGui;
    int found = 0;
    //// FIXME-OPT: We could remove this loop by storing the index in the map
    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
        for (int node_n = 0; node_n < node_ids_count; node_n++)
            if (settings->DockId == node_ids[node_n])
            {
                settings->DockId = 0;
                settings->DockOrder = -1;
                if (++found < node_ids_count)
                    break;
                return;
            }
}

static ImGuiDockNodeSettings* ImGui::DockSettingsFindNodeSettings(ImGuiContext* ctx, ImGuiID id)
{
    // FIXME-OPT
    ImGuiDockContext* dc  = &ctx->DockContext;
    for (int n = 0; n < dc->NodesSettings.Size; n++)
        if (dc->NodesSettings[n].ID == id)
            return &dc->NodesSettings[n];
    return NULL;
}

// Clear settings data
static void ImGui::DockSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiDockContext* dc  = &ctx->DockContext;
    dc->NodesSettings.clear();
    DockContextClearNodes(ctx, 0, true);
}

// Recreate nodes based on settings data
static void ImGui::DockSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    // Prune settings at boot time only
    ImGuiDockContext* dc  = &ctx->DockContext;
    if (ctx->Windows.Size == 0)
        DockContextPruneUnusedSettingsNodes(ctx);
    DockContextBuildNodesFromSettings(ctx, dc->NodesSettings.Data, dc->NodesSettings.Size);
    DockContextBuildAddWindowsToNodes(ctx, 0);
}

static void* ImGui::DockSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    if (strcmp(name, "Data") != 0)
        return NULL;
    return (void*)1;
}

static void ImGui::DockSettingsHandler_ReadLine(ImGuiContext* ctx, ImGuiSettingsHandler*, void*, const char* line)
{
    char c = 0;
    int x = 0, y = 0;
    int r = 0;

    // Parsing, e.g.
    // " DockNode   ID=0x00000001 Pos=383,193 Size=201,322 Split=Y,0.506 "
    // "   DockNode ID=0x00000002 Parent=0x00000001 "
    // Important: this code expect currently fields in a fixed order.
    ImGuiDockNodeSettings node;
    line = ImStrSkipBlank(line);
    if      (strncmp(line, "DockNode", 8) == 0)  { line = ImStrSkipBlank(line + strlen("DockNode")); }
    else if (strncmp(line, "DockSpace", 9) == 0) { line = ImStrSkipBlank(line + strlen("DockSpace")); node.Flags |= ImGuiDockNodeFlags_DockSpace; }
    else return;
    if (sscanf(line, "ID=0x%08X%n",      &node.ID, &r) == 1)            { line += r; } else return;
    if (sscanf(line, " Parent=0x%08X%n", &node.ParentNodeId, &r) == 1)  { line += r; if (node.ParentNodeId == 0) return; }
    if (sscanf(line, " Window=0x%08X%n", &node.ParentWindowId, &r) ==1) { line += r; if (node.ParentWindowId == 0) return; }
    if (node.ParentNodeId == 0)
    {
        if (sscanf(line, " Pos=%i,%i%n",  &x, &y, &r) == 2)         { line += r; node.Pos = ImVec2ih((short)x, (short)y); } else return;
        if (sscanf(line, " Size=%i,%i%n", &x, &y, &r) == 2)         { line += r; node.Size = ImVec2ih((short)x, (short)y); } else return;
    }
    else
    {
        if (sscanf(line, " SizeRef=%i,%i%n", &x, &y, &r) == 2)      { line += r; node.SizeRef = ImVec2ih((short)x, (short)y); }
    }
    if (sscanf(line, " Split=%c%n", &c, &r) == 1)                   { line += r; if (c == 'X') node.SplitAxis = ImGuiAxis_X; else if (c == 'Y') node.SplitAxis = ImGuiAxis_Y; }
    if (sscanf(line, " NoResize=%d%n", &x, &r) == 1)                { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoResize; }
    if (sscanf(line, " CentralNode=%d%n", &x, &r) == 1)             { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_CentralNode; }
    if (sscanf(line, " NoTabBar=%d%n", &x, &r) == 1)                { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoTabBar; }
    if (sscanf(line, " HiddenTabBar=%d%n", &x, &r) == 1)            { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_HiddenTabBar; }
    if (sscanf(line, " NoWindowMenuButton=%d%n", &x, &r) == 1)      { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoWindowMenuButton; }
    if (sscanf(line, " NoCloseButton=%d%n", &x, &r) == 1)           { line += r; if (x != 0) node.Flags |= ImGuiDockNodeFlags_NoCloseButton; }
    if (sscanf(line, " Selected=0x%08X%n", &node.SelectedTabId,&r) == 1) { line += r; }
    if (node.ParentNodeId != 0)
        if (ImGuiDockNodeSettings* parent_settings = DockSettingsFindNodeSettings(ctx, node.ParentNodeId))
            node.Depth = parent_settings->Depth + 1;
    ctx->DockContext.NodesSettings.push_back(node);
}

static void DockSettingsHandler_DockNodeToSettings(ImGuiDockContext* dc, ImGuiDockNode* node, int depth)
{
    ImGuiDockNodeSettings node_settings;
    IM_ASSERT(depth < (1 << (sizeof(node_settings.Depth) << 3)));
    node_settings.ID = node->ID;
    node_settings.ParentNodeId = node->ParentNode ? node->ParentNode->ID : 0;
    node_settings.ParentWindowId = (node->IsDockSpace() && node->HostWindow && node->HostWindow->ParentWindow) ? node->HostWindow->ParentWindow->ID : 0;
    node_settings.SelectedTabId = node->SelectedTabId;
    node_settings.SplitAxis = (signed char)(node->IsSplitNode() ? node->SplitAxis : ImGuiAxis_None);
    node_settings.Depth = (char)depth;
    node_settings.Flags = (node->LocalFlags & ImGuiDockNodeFlags_SavedFlagsMask_);
    node_settings.Pos = ImVec2ih(node->Pos);
    node_settings.Size = ImVec2ih(node->Size);
    node_settings.SizeRef = ImVec2ih(node->SizeRef);
    dc->NodesSettings.push_back(node_settings);
    if (node->ChildNodes[0])
        DockSettingsHandler_DockNodeToSettings(dc, node->ChildNodes[0], depth + 1);
    if (node->ChildNodes[1])
        DockSettingsHandler_DockNodeToSettings(dc, node->ChildNodes[1], depth + 1);
}

static void ImGui::DockSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
    ImGuiContext& g = *ctx;
    ImGuiDockContext* dc = &ctx->DockContext;
    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
        return;

    // Gather settings data
    // (unlike our windows settings, because nodes are always built we can do a full rewrite of the SettingsNode buffer)
    dc->NodesSettings.resize(0);
    dc->NodesSettings.reserve(dc->Nodes.Data.Size);
    for (int n = 0; n < dc->Nodes.Data.Size; n++)
        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
            if (node->IsRootNode())
                DockSettingsHandler_DockNodeToSettings(dc, node, 0);

    int max_depth = 0;
    for (int node_n = 0; node_n < dc->NodesSettings.Size; node_n++)
        max_depth = ImMax((int)dc->NodesSettings[node_n].Depth, max_depth);

    // Write to text buffer
    buf->appendf("[%s][Data]\n", handler->TypeName);
    for (int node_n = 0; node_n < dc->NodesSettings.Size; node_n++)
    {
        const int line_start_pos = buf->size(); (void)line_start_pos;
        const ImGuiDockNodeSettings* node_settings = &dc->NodesSettings[node_n];
        buf->appendf("%*s%s%*s", node_settings->Depth * 2, "", (node_settings->Flags & ImGuiDockNodeFlags_DockSpace) ? "DockSpace" : "DockNode ", (max_depth - node_settings->Depth) * 2, "");  // Text align nodes to facilitate looking at .ini file
        buf->appendf(" ID=0x%08X", node_settings->ID);
        if (node_settings->ParentNodeId)
        {
            buf->appendf(" Parent=0x%08X SizeRef=%d,%d", node_settings->ParentNodeId, node_settings->SizeRef.x, node_settings->SizeRef.y);
        }
        else
        {
            if (node_settings->ParentWindowId)
                buf->appendf(" Window=0x%08X", node_settings->ParentWindowId);
            buf->appendf(" Pos=%d,%d Size=%d,%d", node_settings->Pos.x, node_settings->Pos.y, node_settings->Size.x, node_settings->Size.y);
        }
        if (node_settings->SplitAxis != ImGuiAxis_None)
            buf->appendf(" Split=%c", (node_settings->SplitAxis == ImGuiAxis_X) ? 'X' : 'Y');
        if (node_settings->Flags & ImGuiDockNodeFlags_NoResize)
            buf->appendf(" NoResize=1");
        if (node_settings->Flags & ImGuiDockNodeFlags_CentralNode)
            buf->appendf(" CentralNode=1");
        if (node_settings->Flags & ImGuiDockNodeFlags_NoTabBar)
            buf->appendf(" NoTabBar=1");
        if (node_settings->Flags & ImGuiDockNodeFlags_HiddenTabBar)
            buf->appendf(" HiddenTabBar=1");
        if (node_settings->Flags & ImGuiDockNodeFlags_NoWindowMenuButton)
            buf->appendf(" NoWindowMenuButton=1");
        if (node_settings->Flags & ImGuiDockNodeFlags_NoCloseButton)
            buf->appendf(" NoCloseButton=1");
        if (node_settings->SelectedTabId)
            buf->appendf(" Selected=0x%08X", node_settings->SelectedTabId);

#if IMGUI_DEBUG_INI_SETTINGS
        // [DEBUG] Include comments in the .ini file to ease debugging
        if (ImGuiDockNode* node = DockContextFindNodeByID(ctx, node_settings->ID))
        {
            buf->appendf("%*s", ImMax(2, (line_start_pos + 92) - buf->size()), "");     // Align everything
            if (node->IsDockSpace() && node->HostWindow && node->HostWindow->ParentWindow)
                buf->appendf(" ; in '%s'", node->HostWindow->ParentWindow->Name);
            // Iterate settings so we can give info about windows that didn't exist during the session.
            int contains_window = 0;
            for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
                if (settings->DockId == node_settings->ID)
                {
                    if (contains_window++ == 0)
                        buf->appendf(" ; contains ");
                    buf->appendf("'%s' ", settings->GetName());
                }
        }
#endif
        buf->appendf("\n");
    }
    buf->appendf("\n");
}


//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#pragma comment(lib, "kernel32")
#endif

// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    ImGuiContext& g = *GImGui;
    g.ClipboardHandlerData.clear();
    if (!::OpenClipboard(NULL))
        return NULL;
    HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return NULL;
    }
    if (const WCHAR* wbuf_global = (const WCHAR*)::GlobalLock(wbuf_handle))
    {
        int buf_len = ::WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1, NULL, 0, NULL, NULL);
        g.ClipboardHandlerData.resize(buf_len);
        ::WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1, g.ClipboardHandlerData.Data, buf_len, NULL, NULL);
    }
    ::GlobalUnlock(wbuf_handle);
    ::CloseClipboard();
    return g.ClipboardHandlerData.Data;
}

static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    if (!::OpenClipboard(NULL))
        return;
    const int wbuf_length = ::MultiByteToWideChar(CP_UTF8, 0, text, -1, NULL, 0);
    HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(WCHAR));
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return;
    }
    WCHAR* wbuf_global = (WCHAR*)::GlobalLock(wbuf_handle);
    ::MultiByteToWideChar(CP_UTF8, 0, text, -1, wbuf_global, wbuf_length);
    ::GlobalUnlock(wbuf_handle);
    ::EmptyClipboard();
    if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)
        ::GlobalFree(wbuf_handle);
    ::CloseClipboard();
}

#elif defined(__APPLE__) && TARGET_OS_OSX && defined(IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS)

#include <Carbon/Carbon.h>  // Use old API to avoid need for separate .mm file
static PasteboardRef main_clipboard = 0;

// OSX clipboard implementation
// If you enable this you will need to add '-framework ApplicationServices' to your linker command-line!
static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    if (!main_clipboard)
        PasteboardCreate(kPasteboardClipboard, &main_clipboard);
    PasteboardClear(main_clipboard);
    CFDataRef cf_data = CFDataCreate(kCFAllocatorDefault, (const UInt8*)text, strlen(text));
    if (cf_data)
    {
        PasteboardPutItemFlavor(main_clipboard, (PasteboardItemID)1, CFSTR("public.utf8-plain-text"), cf_data, 0);
        CFRelease(cf_data);
    }
}

static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    if (!main_clipboard)
        PasteboardCreate(kPasteboardClipboard, &main_clipboard);
    PasteboardSynchronize(main_clipboard);

    ItemCount item_count = 0;
    PasteboardGetItemCount(main_clipboard, &item_count);
    for (ItemCount i = 0; i < item_count; i++)
    {
        PasteboardItemID item_id = 0;
        PasteboardGetItemIdentifier(main_clipboard, i + 1, &item_id);
        CFArrayRef flavor_type_array = 0;
        PasteboardCopyItemFlavors(main_clipboard, item_id, &flavor_type_array);
        for (CFIndex j = 0, nj = CFArrayGetCount(flavor_type_array); j < nj; j++)
        {
            CFDataRef cf_data;
            if (PasteboardCopyItemFlavorData(main_clipboard, item_id, CFSTR("public.utf8-plain-text"), &cf_data) == noErr)
            {
                ImGuiContext& g = *GImGui;
                g.ClipboardHandlerData.clear();
                int length = (int)CFDataGetLength(cf_data);
                g.ClipboardHandlerData.resize(length + 1);
                CFDataGetBytes(cf_data, CFRangeMake(0, length), (UInt8*)g.ClipboardHandlerData.Data);
                g.ClipboardHandlerData[length] = 0;
                CFRelease(cf_data);
                return g.ClipboardHandlerData.Data;
            }
        }
    }
    return NULL;
}

#else

// Local Dear ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers.
static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    ImGuiContext& g = *GImGui;
    return g.ClipboardHandlerData.empty() ? NULL : g.ClipboardHandlerData.begin();
}

static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    ImGuiContext& g = *GImGui;
    g.ClipboardHandlerData.clear();
    const char* text_end = text + strlen(text);
    g.ClipboardHandlerData.resize((int)(text_end - text) + 1);
    memcpy(&g.ClipboardHandlerData[0], text, (size_t)(text_end - text));
    g.ClipboardHandlerData[(int)(text_end - text)] = 0;
}

#endif

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUGGER WINDOW
//-----------------------------------------------------------------------------
// - RenderViewportThumbnail() [Internal]
// - RenderViewportsThumbnails() [Internal]
// - MetricsHelpMarker() [Internal]
// - ShowMetricsWindow()
// - DebugNodeColumns() [Internal]
// - DebugNodeDockNode() [Internal]
// - DebugNodeDrawList() [Internal]
// - DebugNodeDrawCmdShowMeshAndBoundingBox() [Internal]
// - DebugNodeStorage() [Internal]
// - DebugNodeTabBar() [Internal]
// - DebugNodeViewport() [Internal]
// - DebugNodeWindow() [Internal]
// - DebugNodeWindowSettings() [Internal]
// - DebugNodeWindowsList() [Internal]
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_METRICS_WINDOW

void ImGui::DebugRenderViewportThumbnail(ImDrawList* draw_list, ImGuiViewportP* viewport, const ImRect& bb)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    ImVec2 scale = bb.GetSize() / viewport->Size;
    ImVec2 off = bb.Min - viewport->Pos * scale;
    float alpha_mul = (viewport->Flags & ImGuiViewportFlags_Minimized) ? 0.30f : 1.00f;
    window->DrawList->AddRectFilled(bb.Min, bb.Max, ImGui::GetColorU32(ImGuiCol_Border, alpha_mul * 0.40f));
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* thumb_window = g.Windows[i];
        if (!thumb_window->WasActive || (thumb_window->Flags & ImGuiWindowFlags_ChildWindow))
            continue;
        if (thumb_window->Viewport != viewport)
            continue;

        ImRect thumb_r = thumb_window->Rect();
        ImRect title_r = thumb_window->TitleBarRect();
        thumb_r = ImRect(ImFloor(off + thumb_r.Min * scale), ImFloor(off +  thumb_r.Max * scale));
        title_r = ImRect(ImFloor(off + title_r.Min * scale), ImFloor(off +  ImVec2(title_r.Max.x, title_r.Min.y) * scale) + ImVec2(0,5)); // Exaggerate title bar height
        thumb_r.ClipWithFull(bb);
        title_r.ClipWithFull(bb);
        const bool window_is_focused = (g.NavWindow && thumb_window->RootWindowForTitleBarHighlight == g.NavWindow->RootWindowForTitleBarHighlight);
        window->DrawList->AddRectFilled(thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_WindowBg, alpha_mul));
        window->DrawList->AddRectFilled(title_r.Min, title_r.Max, GetColorU32(window_is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg, alpha_mul));
        window->DrawList->AddRect(thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_Border, alpha_mul));
        window->DrawList->AddText(g.Font, g.FontSize * 1.0f, title_r.Min, GetColorU32(ImGuiCol_Text, alpha_mul), thumb_window->Name, FindRenderedTextEnd(thumb_window->Name));
    }
    draw_list->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_Border, alpha_mul));
}

static void RenderViewportsThumbnails()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // We don't display full monitor bounds (we could, but it often looks awkward), instead we display just enough to cover all of our viewports.
    float SCALE = 1.0f / 8.0f;
    ImRect bb_full(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
    for (int n = 0; n < g.Viewports.Size; n++)
        bb_full.Add(g.Viewports[n]->GetMainRect());
    ImVec2 p = window->DC.CursorPos;
    ImVec2 off = p - bb_full.Min * SCALE;
    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        ImRect viewport_draw_bb(off + (viewport->Pos) * SCALE, off + (viewport->Pos + viewport->Size) * SCALE);
        ImGui::DebugRenderViewportThumbnail(window->DrawList, viewport, viewport_draw_bb);
    }
    ImGui::Dummy(bb_full.GetSize() * SCALE);
}

static int IMGUI_CDECL ViewportComparerByFrontMostStampCount(const void* lhs, const void* rhs)
{
    const ImGuiViewportP* a = *(const ImGuiViewportP* const *)lhs;
    const ImGuiViewportP* b = *(const ImGuiViewportP* const *)rhs;
    return b->LastFrontMostStampCount - a->LastFrontMostStampCount;
}

// Avoid naming collision with imgui_demo.cpp's HelpMarker() for unity builds.
static void MetricsHelpMarker(const char* desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

void ImGui::ShowMetricsWindow(bool* p_open)
{
    if (!Begin("Dear ImGui Metrics/Debugger", p_open))
    {
        End();
        return;
    }

    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;
    ImGuiMetricsConfig* cfg = &g.DebugMetricsConfig;

    // Basic info
    Text("Dear ImGui %s", GetVersion());
    Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
    Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
    Text("%d active windows (%d visible)", io.MetricsActiveWindows, io.MetricsRenderWindows);
    Text("%d active allocations", io.MetricsActiveAllocations);
    //SameLine(); if (SmallButton("GC")) { g.GcCompactAll = true; }

    Separator();

    // Debugging enums
    enum { WRT_OuterRect, WRT_OuterRectClipped, WRT_InnerRect, WRT_InnerClipRect, WRT_WorkRect, WRT_Content, WRT_ContentIdeal, WRT_ContentRegionRect, WRT_Count }; // Windows Rect Type
    const char* wrt_rects_names[WRT_Count] = { "OuterRect", "OuterRectClipped", "InnerRect", "InnerClipRect", "WorkRect", "Content", "ContentIdeal", "ContentRegionRect" };
    enum { TRT_OuterRect, TRT_InnerRect, TRT_WorkRect, TRT_HostClipRect, TRT_InnerClipRect, TRT_BackgroundClipRect, TRT_ColumnsRect, TRT_ColumnsWorkRect, TRT_ColumnsClipRect, TRT_ColumnsContentHeadersUsed, TRT_ColumnsContentHeadersIdeal, TRT_ColumnsContentFrozen, TRT_ColumnsContentUnfrozen, TRT_Count }; // Tables Rect Type
    const char* trt_rects_names[TRT_Count] = { "OuterRect", "InnerRect", "WorkRect", "HostClipRect", "InnerClipRect", "BackgroundClipRect", "ColumnsRect", "ColumnsWorkRect", "ColumnsClipRect", "ColumnsContentHeadersUsed", "ColumnsContentHeadersIdeal", "ColumnsContentFrozen", "ColumnsContentUnfrozen" };
    if (cfg->ShowWindowsRectsType < 0)
        cfg->ShowWindowsRectsType = WRT_WorkRect;
    if (cfg->ShowTablesRectsType < 0)
        cfg->ShowTablesRectsType = TRT_WorkRect;

    struct Funcs
    {
        static ImRect GetTableRect(ImGuiTable* table, int rect_type, int n)
        {
            if (rect_type == TRT_OuterRect)                     { return table->OuterRect; }
            else if (rect_type == TRT_InnerRect)                { return table->InnerRect; }
            else if (rect_type == TRT_WorkRect)                 { return table->WorkRect; }
            else if (rect_type == TRT_HostClipRect)             { return table->HostClipRect; }
            else if (rect_type == TRT_InnerClipRect)            { return table->InnerClipRect; }
            else if (rect_type == TRT_BackgroundClipRect)       { return table->BgClipRect; }
            else if (rect_type == TRT_ColumnsRect)              { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->MinX, table->InnerClipRect.Min.y, c->MaxX, table->InnerClipRect.Min.y + table->LastOuterHeight); }
            else if (rect_type == TRT_ColumnsWorkRect)          { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->WorkRect.Min.y, c->WorkMaxX, table->WorkRect.Max.y); }
            else if (rect_type == TRT_ColumnsClipRect)          { ImGuiTableColumn* c = &table->Columns[n]; return c->ClipRect; }
            else if (rect_type == TRT_ColumnsContentHeadersUsed){ ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXHeadersUsed, table->InnerClipRect.Min.y + table->LastFirstRowHeight); } // Note: y1/y2 not always accurate
            else if (rect_type == TRT_ColumnsContentHeadersIdeal){ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXHeadersIdeal, table->InnerClipRect.Min.y + table->LastFirstRowHeight); }
            else if (rect_type == TRT_ColumnsContentFrozen)     { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXFrozen, table->InnerClipRect.Min.y + table->LastFirstRowHeight); }
            else if (rect_type == TRT_ColumnsContentUnfrozen)   { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y + table->LastFirstRowHeight, c->ContentMaxXUnfrozen, table->InnerClipRect.Max.y); }
            IM_ASSERT(0);
            return ImRect();
        }

        static ImRect GetWindowRect(ImGuiWindow* window, int rect_type)
        {
            if (rect_type == WRT_OuterRect)                 { return window->Rect(); }
            else if (rect_type == WRT_OuterRectClipped)     { return window->OuterRectClipped; }
            else if (rect_type == WRT_InnerRect)            { return window->InnerRect; }
            else if (rect_type == WRT_InnerClipRect)        { return window->InnerClipRect; }
            else if (rect_type == WRT_WorkRect)             { return window->WorkRect; }
            else if (rect_type == WRT_Content)       { ImVec2 min = window->InnerRect.Min - window->Scroll + window->WindowPadding; return ImRect(min, min + window->ContentSize); }
            else if (rect_type == WRT_ContentIdeal)         { ImVec2 min = window->InnerRect.Min - window->Scroll + window->WindowPadding; return ImRect(min, min + window->ContentSizeIdeal); }
            else if (rect_type == WRT_ContentRegionRect)    { return window->ContentRegionRect; }
            IM_ASSERT(0);
            return ImRect();
        }
    };

    // Tools
    if (TreeNode("Tools"))
    {
        // The Item Picker tool is super useful to visually select an item and break into the call-stack of where it was submitted.
        if (Button("Item Picker.."))
            DebugStartItemPicker();
        SameLine();
        MetricsHelpMarker("Will call the IM_DEBUG_BREAK() macro to break in debugger.\nWarning: If you don't have a debugger attached, this will probably crash.");

        Checkbox("Show windows begin order", &cfg->ShowWindowsBeginOrder);
        Checkbox("Show windows rectangles", &cfg->ShowWindowsRects);
        SameLine();
        SetNextItemWidth(GetFontSize() * 12);
        cfg->ShowWindowsRects |= Combo("##show_windows_rect_type", &cfg->ShowWindowsRectsType, wrt_rects_names, WRT_Count, WRT_Count);
        if (cfg->ShowWindowsRects && g.NavWindow != NULL)
        {
            BulletText("'%s':", g.NavWindow->Name);
            Indent();
            for (int rect_n = 0; rect_n < WRT_Count; rect_n++)
            {
                ImRect r = Funcs::GetWindowRect(g.NavWindow, rect_n);
                Text("(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), wrt_rects_names[rect_n]);
            }
            Unindent();
        }
        Checkbox("Show ImDrawCmd mesh when hovering", &cfg->ShowDrawCmdMesh);
        Checkbox("Show ImDrawCmd bounding boxes when hovering", &cfg->ShowDrawCmdBoundingBoxes);

        Checkbox("Show tables rectangles", &cfg->ShowTablesRects);
        SameLine();
        SetNextItemWidth(GetFontSize() * 12);
        cfg->ShowTablesRects |= Combo("##show_table_rects_type", &cfg->ShowTablesRectsType, trt_rects_names, TRT_Count, TRT_Count);
        if (cfg->ShowTablesRects && g.NavWindow != NULL)
        {
            for (int table_n = 0; table_n < g.Tables.GetSize(); table_n++)
            {
                ImGuiTable* table = g.Tables.GetByIndex(table_n);
                if (table->LastFrameActive < g.FrameCount - 1 || (table->OuterWindow != g.NavWindow && table->InnerWindow != g.NavWindow))
                    continue;

                BulletText("Table 0x%08X (%d columns, in '%s')", table->ID, table->ColumnsCount, table->OuterWindow->Name);
                if (IsItemHovered())
                    GetForegroundDrawList()->AddRect(table->OuterRect.Min - ImVec2(1, 1), table->OuterRect.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
                Indent();
                char buf[128];
                for (int rect_n = 0; rect_n < TRT_Count; rect_n++)
                {
                    if (rect_n >= TRT_ColumnsRect)
                    {
                        if (rect_n != TRT_ColumnsRect && rect_n != TRT_ColumnsClipRect)
                            continue;
                        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                        {
                            ImRect r = Funcs::GetTableRect(table, rect_n, column_n);
                            ImFormatString(buf, IM_ARRAYSIZE(buf), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) Col %d %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), column_n, trt_rects_names[rect_n]);
                            Selectable(buf);
                            if (IsItemHovered())
                                GetForegroundDrawList()->AddRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
                        }
                    }
                    else
                    {
                        ImRect r = Funcs::GetTableRect(table, rect_n, -1);
                        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), trt_rects_names[rect_n]);
                        Selectable(buf);
                        if (IsItemHovered())
                            GetForegroundDrawList()->AddRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
                    }
                }
                Unindent();
            }
        }

        TreePop();
    }

    // Windows
    DebugNodeWindowsList(&g.Windows, "Windows");
    //DebugNodeWindowsList(&g.WindowsFocusOrder, "WindowsFocusOrder");

    // DrawLists
    int drawlist_count = 0;
    for (int viewport_i = 0; viewport_i < g.Viewports.Size; viewport_i++)
        drawlist_count += g.Viewports[viewport_i]->DrawDataBuilder.GetDrawListCount();
    if (TreeNode("DrawLists", "DrawLists (%d)", drawlist_count))
    {
        for (int viewport_i = 0; viewport_i < g.Viewports.Size; viewport_i++)
        {
            ImGuiViewportP* viewport = g.Viewports[viewport_i];
            bool viewport_has_drawlist = false;
            for (int layer_i = 0; layer_i < IM_ARRAYSIZE(viewport->DrawDataBuilder.Layers); layer_i++)
                for (int draw_list_i = 0; draw_list_i < viewport->DrawDataBuilder.Layers[layer_i].Size; draw_list_i++)
                {
                    if (!viewport_has_drawlist)
                        Text("Active DrawLists in Viewport #%d, ID: 0x%08X", viewport->Idx, viewport->ID);
                    viewport_has_drawlist = true;
                    DebugNodeDrawList(NULL, viewport, viewport->DrawDataBuilder.Layers[layer_i][draw_list_i], "DrawList");
                }
        }
        TreePop();
    }

    // Viewports
    if (TreeNode("Viewports", "Viewports (%d)", g.Viewports.Size))
    {
        Indent(GetTreeNodeToLabelSpacing());
        RenderViewportsThumbnails();
        Unindent(GetTreeNodeToLabelSpacing());

        bool open = TreeNode("Monitors", "Monitors (%d)", g.PlatformIO.Monitors.Size);
        SameLine();
        MetricsHelpMarker("Dear ImGui uses monitor data:\n- to query DPI settings on a per monitor basis\n- to position popup/tooltips so they don't straddle monitors.");
        if (open)
        {
            for (int i = 0; i < g.PlatformIO.Monitors.Size; i++)
            {
                const ImGuiPlatformMonitor& mon = g.PlatformIO.Monitors[i];
                BulletText("Monitor #%d: DPI %.0f%%\n MainMin (%.0f,%.0f), MainMax (%.0f,%.0f), MainSize (%.0f,%.0f)\n WorkMin (%.0f,%.0f), WorkMax (%.0f,%.0f), WorkSize (%.0f,%.0f)",
                    i, mon.DpiScale * 100.0f,
                    mon.MainPos.x, mon.MainPos.y, mon.MainPos.x + mon.MainSize.x, mon.MainPos.y + mon.MainSize.y, mon.MainSize.x, mon.MainSize.y,
                    mon.WorkPos.x, mon.WorkPos.y, mon.WorkPos.x + mon.WorkSize.x, mon.WorkPos.y + mon.WorkSize.y, mon.WorkSize.x, mon.WorkSize.y);
            }
            TreePop();
        }

        if (TreeNode("Inferred order (front-to-back)"))
        {
            static ImVector<ImGuiViewportP*> viewports;
            viewports.resize(g.Viewports.Size);
            memcpy(viewports.Data, g.Viewports.Data, g.Viewports.size_in_bytes());
            if (viewports.Size > 1)
                ImQsort(viewports.Data, viewports.Size, sizeof(ImGuiViewport*), ViewportComparerByFrontMostStampCount);
            for (int i = 0; i < viewports.Size; i++)
                BulletText("Viewport #%d, ID: 0x%08X, FrontMostStampCount = %08d, Window: \"%s\"", viewports[i]->Idx, viewports[i]->ID, viewports[i]->LastFrontMostStampCount, viewports[i]->Window ? viewports[i]->Window->Name : "N/A");
            TreePop();
        }

        for (int i = 0; i < g.Viewports.Size; i++)
            DebugNodeViewport(g.Viewports[i]);
        TreePop();
    }

    // Details for Popups
    if (TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))
    {
        for (int i = 0; i < g.OpenPopupStack.Size; i++)
        {
            ImGuiWindow* window = g.OpenPopupStack[i].Window;
            BulletText("PopupID: %08x, Window: '%s'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? " ChildMenu" : "");
        }
        TreePop();
    }

    // Details for TabBars
    if (TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.GetSize()))
    {
        for (int n = 0; n < g.TabBars.GetSize(); n++)
        {
            ImGuiTabBar* tab_bar = g.TabBars.GetByIndex(n);
            PushID(tab_bar);
            DebugNodeTabBar(tab_bar, "TabBar");
            PopID();
        }
        TreePop();
    }

    // Details for Tables
#ifdef IMGUI_HAS_TABLE
    if (TreeNode("Tables", "Tables (%d)", g.Tables.GetSize()))
    {
        for (int n = 0; n < g.Tables.GetSize(); n++)
            DebugNodeTable(g.Tables.GetByIndex(n));
        TreePop();
    }
#endif // #ifdef IMGUI_HAS_TABLE

    // Details for Docking
#ifdef IMGUI_HAS_DOCK
    if (TreeNode("Docking"))
    {
        static bool root_nodes_only = true;
        ImGuiDockContext* dc = &g.DockContext;
        Checkbox("List root nodes", &root_nodes_only);
        Checkbox("Ctrl shows window dock info", &cfg->ShowDockingNodes);
        if (SmallButton("Clear nodes")) { DockContextClearNodes(&g, 0, true); }
        SameLine();
        if (SmallButton("Rebuild all")) { dc->WantFullRebuild = true; }
        for (int n = 0; n < dc->Nodes.Data.Size; n++)
            if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
                if (!root_nodes_only || node->IsRootNode())
                    DebugNodeDockNode(node, "Node");
        TreePop();
    }
#endif // #ifdef IMGUI_HAS_DOCK

    // Settings
    if (TreeNode("Settings"))
    {
        if (SmallButton("Clear"))
            ClearIniSettings();
        SameLine();
        if (SmallButton("Save to memory"))
            SaveIniSettingsToMemory();
        SameLine();
        if (SmallButton("Save to disk"))
            SaveIniSettingsToDisk(g.IO.IniFilename);
        SameLine();
        if (g.IO.IniFilename)
            Text("\"%s\"", g.IO.IniFilename);
        else
            TextUnformatted("<NULL>");
        Text("SettingsDirtyTimer %.2f", g.SettingsDirtyTimer);
        if (TreeNode("SettingsHandlers", "Settings handlers: (%d)", g.SettingsHandlers.Size))
        {
            for (int n = 0; n < g.SettingsHandlers.Size; n++)
                BulletText("%s", g.SettingsHandlers[n].TypeName);
            TreePop();
        }
        if (TreeNode("SettingsWindows", "Settings packed data: Windows: %d bytes", g.SettingsWindows.size()))
        {
            for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
                DebugNodeWindowSettings(settings);
            TreePop();
        }

#ifdef IMGUI_HAS_TABLE
        if (TreeNode("SettingsTables", "Settings packed data: Tables: %d bytes", g.SettingsTables.size()))
        {
            for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
                DebugNodeTableSettings(settings);
            TreePop();
        }
#endif // #ifdef IMGUI_HAS_TABLE

#ifdef IMGUI_HAS_DOCK
        if (TreeNode("SettingsDocking", "Settings packed data: Docking"))
        {
            ImGuiDockContext* dc = &g.DockContext;
            Text("In SettingsWindows:");
            for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
                if (settings->DockId != 0)
                    BulletText("Window '%s' -> DockId %08X", settings->GetName(), settings->DockId);
            Text("In SettingsNodes:");
            for (int n = 0; n < dc->NodesSettings.Size; n++)
            {
                ImGuiDockNodeSettings* settings = &dc->NodesSettings[n];
                const char* selected_tab_name = NULL;
                if (settings->SelectedTabId)
                {
                    if (ImGuiWindow* window = FindWindowByID(settings->SelectedTabId))
                        selected_tab_name = window->Name;
                    else if (ImGuiWindowSettings* window_settings = FindWindowSettings(settings->SelectedTabId))
                        selected_tab_name = window_settings->GetName();
                }
                BulletText("Node %08X, Parent %08X, SelectedTab %08X ('%s')", settings->ID, settings->ParentNodeId, settings->SelectedTabId, selected_tab_name ? selected_tab_name : settings->SelectedTabId ? "N/A" : "");
            }
            TreePop();
        }
#endif // #ifdef IMGUI_HAS_DOCK

        if (TreeNode("SettingsIniData", "Settings unpacked data (.ini): %d bytes", g.SettingsIniData.size()))
        {
            InputTextMultiline("##Ini", (char*)(void*)g.SettingsIniData.c_str(), g.SettingsIniData.Buf.Size, ImVec2(-FLT_MIN, GetTextLineHeight() * 20), ImGuiInputTextFlags_ReadOnly);
            TreePop();
        }
        TreePop();
    }

    // Misc Details
    if (TreeNode("Internal state"))
    {
        const char* input_source_names[] = { "None", "Mouse", "Keyboard", "Gamepad", "Nav", "Clipboard" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT);

        Text("WINDOWING");
        Indent();
        Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
        Text("HoveredWindow->Root: '%s'", g.HoveredWindow ? g.HoveredWindow->RootWindowDockTree->Name : "NULL");
        Text("HoveredWindowUnderMovingWindow: '%s'", g.HoveredWindowUnderMovingWindow ? g.HoveredWindowUnderMovingWindow->Name : "NULL");
        Text("HoveredDockNode: 0x%08X", g.HoveredDockNode ? g.HoveredDockNode->ID : 0);
        Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
        Text("MouseViewport: 0x%08X (UserHovered 0x%08X, LastHovered 0x%08X)", g.MouseViewport->ID, g.IO.MouseHoveredViewport, g.MouseLastHoveredViewport ? g.MouseLastHoveredViewport->ID : 0);
        Unindent();

        Text("ITEMS");
        Indent();
        Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[g.ActiveIdSource]);
        Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
        Text("HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not
        Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
        Unindent();

        Text("NAV,FOCUS");
        Indent();
        Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
        Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
        Text("NavInputSource: %s", input_source_names[g.NavInputSource]);
        Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
        Text("NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId);
        Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);
        Text("NavFocusScopeId = 0x%08X", g.NavFocusScopeId);
        Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
        Unindent();

        TreePop();
    }

    // Overlay: Display windows Rectangles and Begin Order
    if (cfg->ShowWindowsRects || cfg->ShowWindowsBeginOrder)
    {
        for (int n = 0; n < g.Windows.Size; n++)
        {
            ImGuiWindow* window = g.Windows[n];
            if (!window->WasActive)
                continue;
            ImDrawList* draw_list = GetForegroundDrawList(window);
            if (cfg->ShowWindowsRects)
            {
                ImRect r = Funcs::GetWindowRect(window, cfg->ShowWindowsRectsType);
                draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));
            }
            if (cfg->ShowWindowsBeginOrder && !(window->Flags & ImGuiWindowFlags_ChildWindow))
            {
                char buf[32];
                ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);
                float font_size = GetFontSize();
                draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));
                draw_list->AddText(window->Pos, IM_COL32(255, 255, 255, 255), buf);
            }
        }
    }

#ifdef IMGUI_HAS_TABLE
    // Overlay: Display Tables Rectangles
    if (cfg->ShowTablesRects)
    {
        for (int table_n = 0; table_n < g.Tables.GetSize(); table_n++)
        {
            ImGuiTable* table = g.Tables.GetByIndex(table_n);
            if (table->LastFrameActive < g.FrameCount - 1)
                continue;
            ImDrawList* draw_list = GetForegroundDrawList(table->OuterWindow);
            if (cfg->ShowTablesRectsType >= TRT_ColumnsRect)
            {
                for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                {
                    ImRect r = Funcs::GetTableRect(table, cfg->ShowTablesRectsType, column_n);
                    ImU32 col = (table->HoveredColumnBody == column_n) ? IM_COL32(255, 255, 128, 255) : IM_COL32(255, 0, 128, 255);
                    float thickness = (table->HoveredColumnBody == column_n) ? 3.0f : 1.0f;
                    draw_list->AddRect(r.Min, r.Max, col, 0.0f, 0, thickness);
                }
            }
            else
            {
                ImRect r = Funcs::GetTableRect(table, cfg->ShowTablesRectsType, -1);
                draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));
            }
        }
    }
#endif // #ifdef IMGUI_HAS_TABLE

#ifdef IMGUI_HAS_DOCK
    // Overlay: Display Docking info
    if (cfg->ShowDockingNodes && g.IO.KeyCtrl && g.HoveredDockNode)
    {
        char buf[64] = "";
        char* p = buf;
        ImGuiDockNode* node = g.HoveredDockNode;
        ImDrawList* overlay_draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
        p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "DockId: %X%s\n", node->ID, node->IsCentralNode() ? " *CentralNode*" : "");
        p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "WindowClass: %08X\n", node->WindowClass.ClassId);
        p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "Size: (%.0f, %.0f)\n", node->Size.x, node->Size.y);
        p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "SizeRef: (%.0f, %.0f)\n", node->SizeRef.x, node->SizeRef.y);
        int depth = DockNodeGetDepth(node);
        overlay_draw_list->AddRect(node->Pos + ImVec2(3, 3) * (float)depth, node->Pos + node->Size - ImVec2(3, 3) * (float)depth, IM_COL32(200, 100, 100, 255));
        ImVec2 pos = node->Pos + ImVec2(3, 3) * (float)depth;
        overlay_draw_list->AddRectFilled(pos - ImVec2(1, 1), pos + CalcTextSize(buf) + ImVec2(1, 1), IM_COL32(200, 100, 100, 255));
        overlay_draw_list->AddText(NULL, 0.0f, pos, IM_COL32(255, 255, 255, 255), buf);
    }
#endif // #ifdef IMGUI_HAS_DOCK

    End();
}

// [DEBUG] Display contents of Columns
void ImGui::DebugNodeColumns(ImGuiOldColumns* columns)
{
    if (!TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
        return;
    BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->OffMaxX - columns->OffMinX, columns->OffMinX, columns->OffMaxX);
    for (int column_n = 0; column_n < columns->Columns.Size; column_n++)
        BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n, columns->Columns[column_n].OffsetNorm, GetColumnOffsetFromNorm(columns, columns->Columns[column_n].OffsetNorm));
    TreePop();
}

// [DEBUG] Display contents of ImDockNode
void ImGui::DebugNodeDockNode(ImGuiDockNode* node, const char* label)
{
    ImGuiContext& g = *GImGui;
    const bool is_alive = (g.FrameCount - node->LastFrameAlive < 2);    // Submitted with ImGuiDockNodeFlags_KeepAliveOnly
    const bool is_active = (g.FrameCount - node->LastFrameActive < 2);  // Submitted
    if (!is_alive) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    bool open;
    if (node->Windows.Size > 0)
        open = TreeNode((void*)(intptr_t)node->ID, "%s 0x%04X%s: %d windows (vis: '%s')", label, node->ID, node->IsVisible ? "" : " (hidden)", node->Windows.Size, node->VisibleWindow ? node->VisibleWindow->Name : "NULL");
    else
        open = TreeNode((void*)(intptr_t)node->ID, "%s 0x%04X%s: %s split (vis: '%s')", label, node->ID, node->IsVisible ? "" : " (hidden)", (node->SplitAxis == ImGuiAxis_X) ? "horizontal" : (node->SplitAxis == ImGuiAxis_Y) ? "vertical" : "n/a", node->VisibleWindow ? node->VisibleWindow->Name : "NULL");
    if (!is_alive) { PopStyleColor(); }
    if (is_active && IsItemHovered())
        if (ImGuiWindow* window = node->HostWindow ? node->HostWindow : node->VisibleWindow)
            GetForegroundDrawList(window)->AddRect(node->Pos, node->Pos + node->Size, IM_COL32(255, 255, 0, 255));
    if (open)
    {
        IM_ASSERT(node->ChildNodes[0] == NULL || node->ChildNodes[0]->ParentNode == node);
        IM_ASSERT(node->ChildNodes[1] == NULL || node->ChildNodes[1]->ParentNode == node);
        BulletText("Pos (%.0f,%.0f), Size (%.0f, %.0f) Ref (%.0f, %.0f)",
            node->Pos.x, node->Pos.y, node->Size.x, node->Size.y, node->SizeRef.x, node->SizeRef.y);
        DebugNodeWindow(node->HostWindow, "HostWindow");
        DebugNodeWindow(node->VisibleWindow, "VisibleWindow");
        BulletText("SelectedTabID: 0x%08X, LastFocusedNodeID: 0x%08X", node->SelectedTabId, node->LastFocusedNodeId);
        BulletText("Misc:%s%s%s%s%s",
            node->IsDockSpace() ? " IsDockSpace" : "",
            node->IsCentralNode() ? " IsCentralNode" : "",
            is_alive ? " IsAlive" : "", is_active ? " IsActive" : "",
            node->WantLockSizeOnce ? " WantLockSizeOnce" : "");
        if (TreeNode("flags", "LocalFlags: 0x%04X SharedFlags: 0x%04X", node->LocalFlags, node->SharedFlags))
        {
            CheckboxFlags("LocalFlags: NoDocking", &node->LocalFlags, ImGuiDockNodeFlags_NoDocking);
            CheckboxFlags("LocalFlags: NoSplit", &node->LocalFlags, ImGuiDockNodeFlags_NoSplit);
            CheckboxFlags("LocalFlags: NoResize", &node->LocalFlags, ImGuiDockNodeFlags_NoResize);
            CheckboxFlags("LocalFlags: NoResizeX", &node->LocalFlags, ImGuiDockNodeFlags_NoResizeX);
            CheckboxFlags("LocalFlags: NoResizeY", &node->LocalFlags, ImGuiDockNodeFlags_NoResizeY);
            CheckboxFlags("LocalFlags: NoTabBar", &node->LocalFlags, ImGuiDockNodeFlags_NoTabBar);
            CheckboxFlags("LocalFlags: HiddenTabBar", &node->LocalFlags, ImGuiDockNodeFlags_HiddenTabBar);
            CheckboxFlags("LocalFlags: NoWindowMenuButton", &node->LocalFlags, ImGuiDockNodeFlags_NoWindowMenuButton);
            CheckboxFlags("LocalFlags: NoCloseButton", &node->LocalFlags, ImGuiDockNodeFlags_NoCloseButton);
            TreePop();
        }
        if (node->ParentNode)
            DebugNodeDockNode(node->ParentNode, "ParentNode");
        if (node->ChildNodes[0])
            DebugNodeDockNode(node->ChildNodes[0], "Child[0]");
        if (node->ChildNodes[1])
            DebugNodeDockNode(node->ChildNodes[1], "Child[1]");
        if (node->TabBar)
            DebugNodeTabBar(node->TabBar, "TabBar");
        TreePop();
    }
}

// [DEBUG] Display contents of ImDrawList
// Note that both 'window' and 'viewport' may be NULL here. Viewport is generally null of destroyed popups which previously owned a viewport.
void ImGui::DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, const ImDrawList* draw_list, const char* label)
{
    ImGuiContext& g = *GImGui;
    ImGuiMetricsConfig* cfg = &g.DebugMetricsConfig;
    int cmd_count = draw_list->CmdBuffer.Size;
    if (cmd_count > 0 && draw_list->CmdBuffer.back().ElemCount == 0 && draw_list->CmdBuffer.back().UserCallback == NULL)
        cmd_count--;
    bool node_open = TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, cmd_count);
    if (draw_list == GetWindowDrawList())
    {
        SameLine();
        TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
        if (node_open)
            TreePop();
        return;
    }

    ImDrawList* fg_draw_list = viewport ? GetForegroundDrawList(viewport) : NULL; // Render additional visuals into the top-most draw list
    if (window && fg_draw_list && IsItemHovered())
        fg_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
    if (!node_open)
        return;

    if (window && !window->WasActive)
        TextDisabled("Warning: owning Window is inactive. This DrawList is not being rendered!");

    for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.Data; pcmd < draw_list->CmdBuffer.Data + cmd_count; pcmd++)
    {
        if (pcmd->UserCallback)
        {
            BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
            continue;
        }

        char buf[300];
        ImFormatString(buf, IM_ARRAYSIZE(buf), "DrawCmd:%5d tris, Tex 0x%p, ClipRect (%4.0f,%4.0f)-(%4.0f,%4.0f)",
            pcmd->ElemCount / 3, (void*)(intptr_t)pcmd->TextureId,
            pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
        bool pcmd_node_open = TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "%s", buf);
        if (IsItemHovered() && (cfg->ShowDrawCmdMesh || cfg->ShowDrawCmdBoundingBoxes) && fg_draw_list)
            DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, cfg->ShowDrawCmdMesh, cfg->ShowDrawCmdBoundingBoxes);
        if (!pcmd_node_open)
            continue;

        // Calculate approximate coverage area (touched pixel count)
        // This will be in pixels squared as long there's no post-scaling happening to the renderer output.
        const ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
        const ImDrawVert* vtx_buffer = draw_list->VtxBuffer.Data + pcmd->VtxOffset;
        float total_area = 0.0f;
        for (unsigned int idx_n = pcmd->IdxOffset; idx_n < pcmd->IdxOffset + pcmd->ElemCount; )
        {
            ImVec2 triangle[3];
            for (int n = 0; n < 3; n++, idx_n++)
                triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos;
            total_area += ImTriangleArea(triangle[0], triangle[1], triangle[2]);
        }

        // Display vertex information summary. Hover to get all triangles drawn in wire-frame
        ImFormatString(buf, IM_ARRAYSIZE(buf), "Mesh: ElemCount: %d, VtxOffset: +%d, IdxOffset: +%d, Area: ~%0.f px", pcmd->ElemCount, pcmd->VtxOffset, pcmd->IdxOffset, total_area);
        Selectable(buf);
        if (IsItemHovered() && fg_draw_list)
            DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, true, false);

        // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
        ImGuiListClipper clipper;
        clipper.Begin(pcmd->ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
        while (clipper.Step())
            for (int prim = clipper.DisplayStart, idx_i = pcmd->IdxOffset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim++)
            {
                char* buf_p = buf, * buf_end = buf + IM_ARRAYSIZE(buf);
                ImVec2 triangle[3];
                for (int n = 0; n < 3; n++, idx_i++)
                {
                    const ImDrawVert& v = vtx_buffer[idx_buffer ? idx_buffer[idx_i] : idx_i];
                    triangle[n] = v.pos;
                    buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n",
                        (n == 0) ? "Vert:" : "     ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
                }

                Selectable(buf, false);
                if (fg_draw_list && IsItemHovered())
                {
                    ImDrawListFlags backup_flags = fg_draw_list->Flags;
                    fg_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
                    fg_draw_list->AddPolyline(triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_Closed, 1.0f);
                    fg_draw_list->Flags = backup_flags;
                }
            }
        TreePop();
    }
    TreePop();
}

// [DEBUG] Display mesh/aabb of a ImDrawCmd
void ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* out_draw_list, const ImDrawList* draw_list, const ImDrawCmd* draw_cmd, bool show_mesh, bool show_aabb)
{
    IM_ASSERT(show_mesh || show_aabb);
    ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
    ImDrawVert* vtx_buffer = draw_list->VtxBuffer.Data + draw_cmd->VtxOffset;

    // Draw wire-frame version of all triangles
    ImRect clip_rect = draw_cmd->ClipRect;
    ImRect vtxs_rect(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
    ImDrawListFlags backup_flags = out_draw_list->Flags;
    out_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
    for (unsigned int idx_n = draw_cmd->IdxOffset; idx_n < draw_cmd->IdxOffset + draw_cmd->ElemCount; )
    {
        ImVec2 triangle[3];
        for (int n = 0; n < 3; n++, idx_n++)
            vtxs_rect.Add((triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos));
        if (show_mesh)
            out_draw_list->AddPolyline(triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_Closed, 1.0f); // In yellow: mesh triangles
    }
    // Draw bounding boxes
    if (show_aabb)
    {
        out_draw_list->AddRect(ImFloor(clip_rect.Min), ImFloor(clip_rect.Max), IM_COL32(255, 0, 255, 255)); // In pink: clipping rectangle submitted to GPU
        out_draw_list->AddRect(ImFloor(vtxs_rect.Min), ImFloor(vtxs_rect.Max), IM_COL32(0, 255, 255, 255)); // In cyan: bounding box of triangles
    }
    out_draw_list->Flags = backup_flags;
}

// [DEBUG] Display contents of ImGuiStorage
void ImGui::DebugNodeStorage(ImGuiStorage* storage, const char* label)
{
    if (!TreeNode(label, "%s: %d entries, %d bytes", label, storage->Data.Size, storage->Data.size_in_bytes()))
        return;
    for (int n = 0; n < storage->Data.Size; n++)
    {
        const ImGuiStorage::ImGuiStoragePair& p = storage->Data[n];
        BulletText("Key 0x%08X Value { i: %d }", p.key, p.val_i); // Important: we currently don't store a type, real value may not be integer.
    }
    TreePop();
}

// [DEBUG] Display contents of ImGuiTabBar
void ImGui::DebugNodeTabBar(ImGuiTabBar* tab_bar, const char* label)
{
    // Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
    char buf[256];
    char* p = buf;
    const char* buf_end = buf + IM_ARRAYSIZE(buf);
    const bool is_active = (tab_bar->PrevFrameVisible >= GetFrameCount() - 2);
    p += ImFormatString(p, buf_end - p, "%s 0x%08X (%d tabs)%s", label, tab_bar->ID, tab_bar->Tabs.Size, is_active ? "" : " *Inactive*");
    p += ImFormatString(p, buf_end - p, "  { ");
    for (int tab_n = 0; tab_n < ImMin(tab_bar->Tabs.Size, 3); tab_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
        p += ImFormatString(p, buf_end - p, "%s'%s'",
            tab_n > 0 ? ", " : "", (tab->Window || tab->NameOffset != -1) ? tab_bar->GetTabName(tab) : "???");
    }
    p += ImFormatString(p, buf_end - p, (tab_bar->Tabs.Size > 3) ? " ... }" : " } ");
    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    bool open = TreeNode(label, "%s", buf);
    if (!is_active) { PopStyleColor(); }
    if (is_active && IsItemHovered())
    {
        ImDrawList* draw_list = GetForegroundDrawList();
        draw_list->AddRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max, IM_COL32(255, 255, 0, 255));
        draw_list->AddLine(ImVec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Min.y), ImVec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Max.y), IM_COL32(0, 255, 0, 255));
        draw_list->AddLine(ImVec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Min.y), ImVec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Max.y), IM_COL32(0, 255, 0, 255));
    }
    if (open)
    {
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
        {
            const ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
            PushID(tab);
            if (SmallButton("<")) { TabBarQueueReorder(tab_bar, tab, -1); } SameLine(0, 2);
            if (SmallButton(">")) { TabBarQueueReorder(tab_bar, tab, +1); } SameLine();
            Text("%02d%c Tab 0x%08X '%s' Offset: %.1f, Width: %.1f/%.1f",
                tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID, (tab->Window || tab->NameOffset != -1) ? tab_bar->GetTabName(tab) : "???", tab->Offset, tab->Width, tab->ContentWidth);
            PopID();
        }
        TreePop();
    }
}

void ImGui::DebugNodeViewport(ImGuiViewportP* viewport)
{
    SetNextItemOpen(true, ImGuiCond_Once);
    if (TreeNode((void*)(intptr_t)viewport->ID, "Viewport #%d, ID: 0x%08X, Parent: 0x%08X, Window: \"%s\"", viewport->Idx, viewport->ID, viewport->ParentViewportId, viewport->Window ? viewport->Window->Name : "N/A"))
    {
        ImGuiWindowFlags flags = viewport->Flags;
        BulletText("Main Pos: (%.0f,%.0f), Size: (%.0f,%.0f)\nWorkArea Offset Left: %.0f Top: %.0f, Right: %.0f, Bottom: %.0f\nMonitor: %d, DpiScale: %.0f%%",
            viewport->Pos.x, viewport->Pos.y, viewport->Size.x, viewport->Size.y,
            viewport->WorkOffsetMin.x, viewport->WorkOffsetMin.y, viewport->WorkOffsetMax.x, viewport->WorkOffsetMax.y,
            viewport->PlatformMonitor, viewport->DpiScale * 100.0f);
        if (viewport->Idx > 0) { SameLine(); if (SmallButton("Reset Pos")) { viewport->Pos = ImVec2(200, 200); viewport->UpdateWorkRect(); if (viewport->Window) viewport->Window->Pos = viewport->Pos; } }
        BulletText("Flags: 0x%04X =%s%s%s%s%s%s%s%s%s%s%s%s", viewport->Flags,
            //(flags & ImGuiViewportFlags_IsPlatformWindow) ? " IsPlatformWindow" : "", // Omitting because it is the standard
            (flags & ImGuiViewportFlags_IsPlatformMonitor) ? " IsPlatformMonitor" : "",
            (flags & ImGuiViewportFlags_OwnedByApp) ? " OwnedByApp" : "",
            (flags & ImGuiViewportFlags_NoDecoration) ? " NoDecoration" : "",
            (flags & ImGuiViewportFlags_NoTaskBarIcon) ? " NoTaskBarIcon" : "",
            (flags & ImGuiViewportFlags_NoFocusOnAppearing) ? " NoFocusOnAppearing" : "",
            (flags & ImGuiViewportFlags_NoFocusOnClick) ? " NoFocusOnClick" : "",
            (flags & ImGuiViewportFlags_NoInputs) ? " NoInputs" : "",
            (flags & ImGuiViewportFlags_NoRendererClear) ? " NoRendererClear" : "",
            (flags & ImGuiViewportFlags_TopMost) ? " TopMost" : "",
            (flags & ImGuiViewportFlags_Minimized) ? " Minimized" : "",
            (flags & ImGuiViewportFlags_NoAutoMerge) ? " NoAutoMerge" : "",
            (flags & ImGuiViewportFlags_CanHostOtherWindows) ? " CanHostOtherWindows" : "");
        for (int layer_i = 0; layer_i < IM_ARRAYSIZE(viewport->DrawDataBuilder.Layers); layer_i++)
            for (int draw_list_i = 0; draw_list_i < viewport->DrawDataBuilder.Layers[layer_i].Size; draw_list_i++)
                DebugNodeDrawList(NULL, viewport, viewport->DrawDataBuilder.Layers[layer_i][draw_list_i], "DrawList");
        TreePop();
    }
}

void ImGui::DebugNodeWindow(ImGuiWindow* window, const char* label)
{
    if (window == NULL)
    {
        BulletText("%s: NULL", label);
        return;
    }

    ImGuiContext& g = *GImGui;
    const bool is_active = window->WasActive;
    ImGuiTreeNodeFlags tree_node_flags = (window == g.NavWindow) ? ImGuiTreeNodeFlags_Selected : ImGuiTreeNodeFlags_None;
    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    const bool open = TreeNodeEx(label, tree_node_flags, "%s '%s'%s", label, window->Name, is_active ? "" : " *Inactive*");
    if (!is_active) { PopStyleColor(); }
    if (IsItemHovered() && is_active)
        GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
    if (!open)
        return;

    if (window->MemoryCompacted)
        TextDisabled("Note: some memory buffers have been compacted/freed.");

    ImGuiWindowFlags flags = window->Flags;
    DebugNodeDrawList(window, window->Viewport, window->DrawList, "DrawList");
    BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), ContentSize (%.1f,%.1f) Ideal (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->ContentSize.x, window->ContentSize.y, window->ContentSizeIdeal.x, window->ContentSizeIdeal.y);
    BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
        (flags & ImGuiWindowFlags_ChildWindow)  ? "Child " : "",      (flags & ImGuiWindowFlags_Tooltip)     ? "Tooltip "   : "",  (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",
        (flags & ImGuiWindowFlags_Modal)        ? "Modal " : "",      (flags & ImGuiWindowFlags_ChildMenu)   ? "ChildMenu " : "",  (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
        (flags & ImGuiWindowFlags_NoMouseInputs)? "NoMouseInputs":"", (flags & ImGuiWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
    BulletText("WindowClassId: 0x%08X", window->WindowClass.ClassId);
    BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f) Scrollbar:%s%s", window->Scroll.x, window->ScrollMax.x, window->Scroll.y, window->ScrollMax.y, window->ScrollbarX ? "X" : "", window->ScrollbarY ? "Y" : "");
    BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
    BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesCanSkipItems, window->HiddenFramesCannotSkipItems, window->SkipItems);
    for (int layer = 0; layer < ImGuiNavLayer_COUNT; layer++)
    {
        ImRect r = window->NavRectRel[layer];
        if (r.Min.x >= r.Max.y && r.Min.y >= r.Max.y)
        {
            BulletText("NavLastIds[%d]: 0x%08X", layer, window->NavLastIds[layer]);
            continue;
        }
        BulletText("NavLastIds[%d]: 0x%08X at +(%.1f,%.1f)(%.1f,%.1f)", layer, window->NavLastIds[layer], r.Min.x, r.Min.y, r.Max.x, r.Max.y);
        if (IsItemHovered())
            GetForegroundDrawList(window)->AddRect(r.Min + window->Pos, r.Max + window->Pos, IM_COL32(255, 255, 0, 255));
    }
    BulletText("NavLayersActiveMask: %X, NavLastChildNavWindow: %s", window->DC.NavLayersActiveMask, window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");

    BulletText("Viewport: %d%s, ViewportId: 0x%08X, ViewportPos: (%.1f,%.1f)", window->Viewport ? window->Viewport->Idx : -1, window->ViewportOwned ? " (Owned)" : "", window->ViewportId, window->ViewportPos.x, window->ViewportPos.y);
    BulletText("ViewportMonitor: %d", window->Viewport ? window->Viewport->PlatformMonitor : -1);
    BulletText("DockId: 0x%04X, DockOrder: %d, Act: %d, Vis: %d", window->DockId, window->DockOrder, window->DockIsActive, window->DockTabIsVisible);
    if (window->DockNode || window->DockNodeAsHost)
        DebugNodeDockNode(window->DockNodeAsHost ? window->DockNodeAsHost : window->DockNode, window->DockNodeAsHost ? "DockNodeAsHost" : "DockNode");

    if (window->RootWindow != window)       { DebugNodeWindow(window->RootWindow, "RootWindow"); }
    if (window->RootWindowDockTree != window->RootWindow) { DebugNodeWindow(window->RootWindowDockTree, "RootWindowDockTree"); }
    if (window->ParentWindow != NULL)       { DebugNodeWindow(window->ParentWindow, "ParentWindow"); }
    if (window->DC.ChildWindows.Size > 0)   { DebugNodeWindowsList(&window->DC.ChildWindows, "ChildWindows"); }
    if (window->ColumnsStorage.Size > 0 && TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size))
    {
        for (int n = 0; n < window->ColumnsStorage.Size; n++)
            DebugNodeColumns(&window->ColumnsStorage[n]);
        TreePop();
    }
    DebugNodeStorage(&window->StateStorage, "Storage");
    TreePop();
}

void ImGui::DebugNodeWindowSettings(ImGuiWindowSettings* settings)
{
    Text("0x%08X \"%s\" Pos (%d,%d) Size (%d,%d) Collapsed=%d",
        settings->ID, settings->GetName(), settings->Pos.x, settings->Pos.y, settings->Size.x, settings->Size.y, settings->Collapsed);
}

void ImGui::DebugNodeWindowsList(ImVector<ImGuiWindow*>* windows, const char* label)
{
    if (!TreeNode(label, "%s (%d)", label, windows->Size))
        return;
    Text("(In front-to-back order:)");
    for (int i = windows->Size - 1; i >= 0; i--) // Iterate front to back
    {
        PushID((*windows)[i]);
        DebugNodeWindow((*windows)[i], "Window");
        PopID();
    }
    TreePop();
}

#else

void ImGui::ShowMetricsWindow(bool*) {}
void ImGui::DebugNodeColumns(ImGuiOldColumns*) {}
void ImGui::DebugNodeDrawList(ImGuiWindow*, ImGuiViewportP*, const ImDrawList*, const char*) {}
void ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList*, const ImDrawList*, const ImDrawCmd*, bool, bool) {}
void ImGui::DebugNodeStorage(ImGuiStorage*, const char*) {}
void ImGui::DebugNodeTabBar(ImGuiTabBar*, const char*) {}
void ImGui::DebugNodeWindow(ImGuiWindow*, const char*) {}
void ImGui::DebugNodeWindowSettings(ImGuiWindowSettings*) {}
void ImGui::DebugNodeWindowsList(ImVector<ImGuiWindow*>*, const char*) {}
void ImGui::DebugNodeViewport(ImGuiViewportP*) {}

#endif

//-----------------------------------------------------------------------------

// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.
// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.
#ifdef IMGUI_INCLUDE_IMGUI_USER_INL
#include "imgui_user.inl"
#endif

//-----------------------------------------------------------------------------

#endif // #ifndef IMGUI_DISABLE

// Junk Code By Troll Face & Thaisen's Gen
void mcwCjJYMoDHiTcFyhAVRLVxbEyFzgYClv39142630() {     float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi64673647 = -332659282;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi56262691 = -206466897;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi73773153 = -467874464;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi3988834 = -958593453;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi39174215 = -244014773;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi47144581 = -9797669;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi70366984 = -372877549;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi42833896 = -364500515;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi75427625 = -980860594;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi3897251 = -676137364;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi52348804 = -916462240;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi22278868 = -56395194;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi16982966 = -293855636;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi4481060 = -761178493;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi68413029 = -412006290;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi22368843 = -431510848;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi37810934 = -988240459;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi13428630 = -717219103;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi64089533 = -792468637;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi78335117 = -20642943;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi46885448 = -428763390;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi9381510 = -909980487;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi69951902 = -410182335;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi30240303 = 23665899;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi31882498 = -618271267;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi98516200 = -979061490;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi7481764 = -777318920;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi90732296 = -957414109;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi63111109 = -540915720;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi44776849 = -169883694;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi5098476 = -356856542;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi20635855 = -816686582;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi1458999 = -671056659;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi77810180 = -338366920;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi33356330 = -12992534;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi60010603 = -834288650;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi81999095 = -564323699;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi94836767 = -177184525;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi75107599 = -61815470;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi81008708 = -760575152;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi91252343 = -419692992;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi84070323 = -757893651;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi61683715 = -880140348;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi69423368 = -382779659;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi50902395 = -224831634;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi81487208 = -32906855;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi11312159 = -183015663;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi19499779 = -988786761;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi12166658 = -109048278;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi9095677 = -13684356;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi32992560 = -883965335;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi95332161 = -134957992;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi40853506 = -866169039;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi88822720 = -102486527;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi92257181 = -260152708;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi55292137 = -422678795;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi86310789 = -796284562;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi43532850 = -391540364;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi72106336 = -240322186;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi40658015 = -264953283;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi39662817 = -232478750;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79634687 = -415463440;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79722787 = -823584796;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi30650777 = -710976900;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi98798774 = -219280823;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi31712950 = 224342;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi20819870 = -385338536;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi39172786 = -955488717;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi71124729 = -648185960;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi8402426 = -577717640;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi40369747 = -867187150;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi42974166 = -711055935;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi38321030 = -555403633;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi83080825 = 68106514;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi87082774 = -600949951;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi62815124 = -670869739;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi47697795 = 70159860;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi528534 = 72597324;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79337907 = -751502468;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi50395290 = -485364413;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi87204041 = -696045828;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi87981985 = -788532159;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi78565638 = -748365832;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi54015432 = -427231364;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi11784289 = -285918359;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi9766315 = -121898550;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79782348 = -950517544;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi12636278 = -468570132;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi85552998 = 21785788;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi78064193 = -590313739;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi73699814 = 61995911;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi38466246 = -72783336;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi22730432 = -936862339;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi34449585 = -796862188;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi41345891 = -428096402;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi11617656 = 95770448;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi4347537 = -934308856;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi31032939 = -69163449;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi70624594 = -63498837;    float QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi19189446 = -332659282;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi64673647 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi56262691;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi56262691 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi73773153;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi73773153 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi3988834;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi3988834 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi39174215;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi39174215 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi47144581;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi47144581 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi70366984;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi70366984 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi42833896;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi42833896 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi75427625;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi75427625 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi3897251;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi3897251 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi52348804;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi52348804 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi22278868;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi22278868 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi16982966;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi16982966 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi4481060;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi4481060 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi68413029;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi68413029 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi22368843;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi22368843 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi37810934;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi37810934 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi13428630;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi13428630 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi64089533;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi64089533 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi78335117;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi78335117 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi46885448;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi46885448 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi9381510;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi9381510 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi69951902;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi69951902 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi30240303;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi30240303 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi31882498;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi31882498 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi98516200;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi98516200 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi7481764;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi7481764 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi90732296;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi90732296 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi63111109;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi63111109 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi44776849;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi44776849 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi5098476;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi5098476 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi20635855;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi20635855 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi1458999;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi1458999 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi77810180;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi77810180 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi33356330;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi33356330 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi60010603;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi60010603 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi81999095;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi81999095 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi94836767;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi94836767 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi75107599;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi75107599 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi81008708;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi81008708 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi91252343;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi91252343 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi84070323;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi84070323 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi61683715;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi61683715 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi69423368;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi69423368 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi50902395;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi50902395 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi81487208;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi81487208 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi11312159;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi11312159 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi19499779;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi19499779 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi12166658;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi12166658 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi9095677;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi9095677 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi32992560;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi32992560 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi95332161;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi95332161 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi40853506;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi40853506 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi88822720;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi88822720 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi92257181;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi92257181 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi55292137;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi55292137 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi86310789;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi86310789 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi43532850;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi43532850 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi72106336;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi72106336 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi40658015;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi40658015 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi39662817;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi39662817 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79634687;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79634687 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79722787;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79722787 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi30650777;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi30650777 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi98798774;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi98798774 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi31712950;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi31712950 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi20819870;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi20819870 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi39172786;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi39172786 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi71124729;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi71124729 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi8402426;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi8402426 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi40369747;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi40369747 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi42974166;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi42974166 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi38321030;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi38321030 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi83080825;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi83080825 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi87082774;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi87082774 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi62815124;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi62815124 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi47697795;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi47697795 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi528534;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi528534 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79337907;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79337907 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi50395290;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi50395290 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi87204041;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi87204041 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi87981985;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi87981985 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi78565638;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi78565638 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi54015432;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi54015432 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi11784289;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi11784289 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi9766315;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi9766315 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79782348;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi79782348 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi12636278;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi12636278 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi85552998;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi85552998 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi78064193;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi78064193 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi73699814;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi73699814 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi38466246;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi38466246 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi22730432;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi22730432 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi34449585;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi34449585 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi41345891;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi41345891 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi11617656;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi11617656 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi4347537;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi4347537 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi31032939;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi31032939 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi70624594;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi70624594 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi19189446;     QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi19189446 = QsgYPxPjXAYoeapGKnJpmiRfUykEYfPBWnDkZZRCFi64673647;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void HdUulxaDJOnnZUPjupjHVaiPmCknNQkKq99445287() {     float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN54799955 = -391415483;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN39387756 = -581393067;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN69265852 = -604668925;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN77487408 = -44765275;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN52230951 = -185338215;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN27930986 = 97569223;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN65030422 = -10423022;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN95712459 = -948254;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN99239313 = -988753232;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN8152921 = -246011890;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN28500623 = -324882397;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN57028376 = -635983329;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN55329098 = -606091496;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN42899913 = -759339377;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN66487400 = -897127233;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN46548584 = -131890718;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN81773114 = -149585700;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34784342 = -60068395;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN25003925 = -158879073;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN45659365 = -668521252;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34807850 = -133188482;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN7463093 = -143077123;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN3190321 = -816642256;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN38161400 = -424358477;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN78767686 = -161782211;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN17307165 = -854935225;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN29449099 = -536847914;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN13902672 = 82695833;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN24320107 = -203114768;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN92565928 = -44286086;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN8561879 = -683523086;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN20002769 = -217511002;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN10428039 = -971281818;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN1648825 = -329818078;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN68952864 = -763328194;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN13241610 = -37318060;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN82232664 = -80139603;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN19194051 = -43243768;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85640616 = -869277516;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN25520850 = -665282925;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN4952017 = -125554268;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN38714787 = -572386864;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN21500557 = -255565944;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85310 = -246862848;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN42866813 = -337341590;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN1926202 = -516530761;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN91735449 = -831498162;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN9886238 = 84556985;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN40085312 = -544987624;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN38376082 = -470680694;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN62358083 = -158347380;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN39105269 = -99384825;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN90305960 = -578022034;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN41729782 = -226041809;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN64637437 = -388752979;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN47336863 = -148338360;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN36197436 = -764750811;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN31104452 = -80310449;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN98719722 = -882983064;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34923786 = -330402990;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN98481886 = -365582864;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN51127751 = 6881145;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN71392352 = -797833487;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN6673385 = -844467146;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN99591041 = -562488805;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN8497855 = -7371396;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN46600337 = -664701511;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN53680273 = -176273419;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN73947049 = -996011183;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN53245791 = -759809173;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN64315920 = 48248885;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN62579063 = -6341932;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN49143725 = -190790880;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN99483074 = -493596149;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN40707349 = -442966985;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN96093063 = -560801618;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85962535 = -887511180;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN3105012 = -469779408;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN95294587 = 12983113;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN76841484 = -645251451;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN25571716 = 76562937;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN19562861 = -521404900;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN73817360 = -372316544;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85944024 = -732434075;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN30207846 = -885938706;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN69456610 = -484138261;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN29696808 = -639488969;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN68698257 = -645240010;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN37011388 = -941065099;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN21616002 = -514989835;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN77044173 = -272567250;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN51128213 = -999829154;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN20474328 = -160260705;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN50716831 = -438874526;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN27038963 = -199700061;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN53824265 = -32435413;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN67322434 = -774553378;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN14827173 = -411098798;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN494268 = -684374044;    float eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34368958 = -391415483;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN54799955 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN39387756;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN39387756 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN69265852;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN69265852 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN77487408;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN77487408 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN52230951;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN52230951 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN27930986;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN27930986 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN65030422;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN65030422 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN95712459;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN95712459 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN99239313;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN99239313 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN8152921;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN8152921 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN28500623;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN28500623 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN57028376;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN57028376 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN55329098;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN55329098 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN42899913;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN42899913 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN66487400;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN66487400 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN46548584;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN46548584 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN81773114;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN81773114 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34784342;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34784342 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN25003925;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN25003925 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN45659365;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN45659365 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34807850;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34807850 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN7463093;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN7463093 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN3190321;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN3190321 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN38161400;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN38161400 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN78767686;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN78767686 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN17307165;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN17307165 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN29449099;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN29449099 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN13902672;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN13902672 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN24320107;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN24320107 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN92565928;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN92565928 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN8561879;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN8561879 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN20002769;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN20002769 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN10428039;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN10428039 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN1648825;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN1648825 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN68952864;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN68952864 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN13241610;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN13241610 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN82232664;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN82232664 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN19194051;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN19194051 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85640616;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85640616 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN25520850;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN25520850 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN4952017;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN4952017 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN38714787;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN38714787 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN21500557;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN21500557 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85310;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85310 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN42866813;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN42866813 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN1926202;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN1926202 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN91735449;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN91735449 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN9886238;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN9886238 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN40085312;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN40085312 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN38376082;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN38376082 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN62358083;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN62358083 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN39105269;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN39105269 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN90305960;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN90305960 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN41729782;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN41729782 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN64637437;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN64637437 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN47336863;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN47336863 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN36197436;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN36197436 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN31104452;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN31104452 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN98719722;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN98719722 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34923786;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34923786 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN98481886;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN98481886 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN51127751;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN51127751 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN71392352;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN71392352 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN6673385;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN6673385 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN99591041;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN99591041 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN8497855;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN8497855 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN46600337;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN46600337 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN53680273;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN53680273 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN73947049;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN73947049 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN53245791;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN53245791 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN64315920;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN64315920 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN62579063;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN62579063 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN49143725;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN49143725 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN99483074;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN99483074 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN40707349;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN40707349 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN96093063;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN96093063 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85962535;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85962535 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN3105012;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN3105012 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN95294587;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN95294587 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN76841484;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN76841484 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN25571716;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN25571716 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN19562861;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN19562861 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN73817360;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN73817360 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85944024;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN85944024 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN30207846;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN30207846 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN69456610;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN69456610 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN29696808;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN29696808 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN68698257;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN68698257 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN37011388;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN37011388 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN21616002;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN21616002 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN77044173;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN77044173 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN51128213;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN51128213 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN20474328;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN20474328 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN50716831;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN50716831 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN27038963;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN27038963 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN53824265;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN53824265 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN67322434;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN67322434 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN14827173;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN14827173 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN494268;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN494268 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34368958;     eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN34368958 = eivuEKptfxiiGETgFEgNPOhvEIjMnptecwumTpqetN54799955;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void uvtUWzLVihyoISkNuYXDDuhhxwTFlwrtP95628447() {     float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK14396052 = -620171860;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK40893606 = -391548452;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK6267240 = -678809848;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK73363167 = -917376152;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK63524177 = -85845242;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK25608106 = -860690451;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62388905 = -440140607;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK46537743 = -355159629;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK13052757 = -421425731;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91177435 = -187270743;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK53795554 = -726424837;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91699577 = -731004579;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK26083661 = -512270015;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK1273753 = -663497724;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK63795206 = -589653754;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK43302839 = 62736391;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK17734218 = -77801980;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK99452672 = -429404500;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK5446128 = -297998703;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK25576474 = -230929905;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK15268969 = 33790694;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK75952690 = -35479001;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK95382145 = -580937335;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK2891640 = 11303287;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK54745691 = -717919801;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK11722072 = -989552696;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK42789169 = -986327911;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK79013840 = -538685758;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK74104449 = 7292617;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK31039396 = -91269328;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK33476197 = -228742414;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62768029 = -634728999;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK59510078 = -951228691;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK84173267 = -931702009;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK73890225 = -411538180;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91831506 = -348974642;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK72864342 = -372918238;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK17554389 = 12303842;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK4658560 = -587984033;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK98346504 = -939163873;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK63169830 = -594215864;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK8793968 = -577328283;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62379799 = 10989227;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK74324814 = -670777587;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK43855128 = -883659659;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK66719330 = -759474920;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK97224171 = -723353830;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK56582631 = -248196243;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK79474959 = -828925244;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK53543474 = -791933154;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK12844334 = 55544396;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK45690422 = -70628080;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK65721475 = -817970487;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK15004306 = -486210764;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK80359478 = -352687066;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK38443362 = -484692860;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK45511460 = -810611117;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK3375601 = -590113135;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK18617476 = -99456351;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK51802105 = -96292547;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK82818937 = -874362540;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK83375064 = -901454850;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK72433293 = -262452247;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK82013361 = -230156403;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK57701239 = -958528330;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91027525 = 8304162;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK32189500 = -779775888;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK41910394 = -580568006;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK27383527 = -151959545;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK71963700 = -140679112;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK70438496 = -564345372;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK179830 = 9894177;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK94794113 = -841420468;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK7099624 = -358834831;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62406644 = -636714042;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK6475001 = -388881024;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK13572892 = 53531772;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK21057331 = -910159749;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK59036511 = -105037055;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK88026360 = -958444882;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK14497901 = -166198867;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK86206537 = -638131668;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK99538880 = -709760514;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK20560975 = -200774229;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK18195062 = -46813724;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK87785775 = -58114334;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK97046553 = -816758512;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK44505772 = -365017927;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK3813789 = -479014943;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK35446864 = -926845321;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK46320046 = -538363526;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK69488741 = -782805103;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK98936912 = -888239807;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK52856455 = -391691487;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK15527567 = 35198666;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK79794765 = -692761014;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK36360675 = -214876036;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK80366437 = -758854370;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK16623576 = -712249257;    float KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK52827603 = -620171860;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK14396052 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK40893606;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK40893606 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK6267240;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK6267240 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK73363167;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK73363167 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK63524177;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK63524177 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK25608106;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK25608106 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62388905;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62388905 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK46537743;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK46537743 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK13052757;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK13052757 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91177435;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91177435 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK53795554;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK53795554 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91699577;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91699577 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK26083661;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK26083661 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK1273753;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK1273753 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK63795206;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK63795206 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK43302839;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK43302839 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK17734218;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK17734218 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK99452672;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK99452672 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK5446128;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK5446128 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK25576474;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK25576474 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK15268969;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK15268969 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK75952690;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK75952690 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK95382145;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK95382145 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK2891640;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK2891640 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK54745691;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK54745691 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK11722072;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK11722072 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK42789169;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK42789169 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK79013840;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK79013840 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK74104449;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK74104449 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK31039396;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK31039396 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK33476197;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK33476197 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62768029;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62768029 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK59510078;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK59510078 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK84173267;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK84173267 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK73890225;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK73890225 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91831506;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91831506 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK72864342;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK72864342 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK17554389;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK17554389 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK4658560;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK4658560 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK98346504;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK98346504 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK63169830;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK63169830 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK8793968;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK8793968 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62379799;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62379799 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK74324814;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK74324814 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK43855128;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK43855128 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK66719330;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK66719330 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK97224171;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK97224171 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK56582631;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK56582631 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK79474959;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK79474959 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK53543474;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK53543474 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK12844334;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK12844334 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK45690422;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK45690422 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK65721475;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK65721475 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK15004306;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK15004306 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK80359478;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK80359478 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK38443362;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK38443362 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK45511460;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK45511460 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK3375601;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK3375601 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK18617476;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK18617476 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK51802105;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK51802105 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK82818937;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK82818937 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK83375064;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK83375064 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK72433293;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK72433293 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK82013361;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK82013361 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK57701239;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK57701239 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91027525;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK91027525 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK32189500;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK32189500 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK41910394;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK41910394 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK27383527;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK27383527 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK71963700;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK71963700 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK70438496;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK70438496 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK179830;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK179830 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK94794113;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK94794113 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK7099624;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK7099624 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62406644;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK62406644 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK6475001;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK6475001 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK13572892;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK13572892 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK21057331;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK21057331 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK59036511;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK59036511 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK88026360;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK88026360 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK14497901;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK14497901 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK86206537;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK86206537 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK99538880;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK99538880 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK20560975;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK20560975 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK18195062;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK18195062 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK87785775;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK87785775 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK97046553;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK97046553 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK44505772;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK44505772 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK3813789;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK3813789 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK35446864;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK35446864 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK46320046;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK46320046 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK69488741;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK69488741 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK98936912;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK98936912 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK52856455;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK52856455 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK15527567;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK15527567 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK79794765;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK79794765 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK36360675;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK36360675 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK80366437;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK80366437 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK16623576;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK16623576 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK52827603;     KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK52827603 = KgDsmezsoOBaNXFJKplXvAAOLWZgFkmpEZymhUHuYK14396052;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void CfvsCZDZpVXuAkjubdfNnsvPnJzBVKRSm8173636() {     float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj33864223 = 66696928;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj93917469 = -937426448;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23104232 = -330438463;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj92010315 = -733950415;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj63970693 = -712117658;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj51200180 = -751175219;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj7220784 = -883446837;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj11787977 = -448967595;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj73739554 = -49617110;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj69106159 = -192856789;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj8018819 = -59415137;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95194190 = -730307283;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj16455321 = -936627291;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj9689793 = -105783450;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24321668 = -887737546;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj9518488 = -400455543;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23696331 = -249576662;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23515425 = -180159218;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5081007 = -675203464;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj6187776 = -948466361;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj27725041 = -572421632;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj90934773 = -547282214;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj63555151 = -878511953;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj20613308 = -725240705;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj65949180 = 87780089;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj16489534 = -675347914;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj26717300 = -651478843;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj29805515 = -702419037;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj15849407 = -6618529;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj15746250 = -182708022;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj63280282 = -94068506;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj2347340 = -99078017;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj70986181 = -406436457;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj42929774 = -136305215;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj13820562 = -474240986;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj27897443 = -652543251;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj41247793 = -899794313;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj59036862 = -64904974;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj71971884 = 47601142;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj19628240 = -935694970;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj4651887 = -4002160;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj20653101 = -816224508;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj33513040 = 63187429;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj57710353 = -19850248;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23883540 = -60782622;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj21180458 = -196806341;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj79214051 = -637047152;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj56738461 = -431483557;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj20610550 = -842864483;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj94441816 = -552945499;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj87279903 = -350820535;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj62139282 = -447980940;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj35546622 = -494079448;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj87934333 = -480804401;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj80448595 = -127245701;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj42929449 = -386020859;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj30362318 = 41085505;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj2490924 = -605197758;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj26061136 = -721730505;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj47481160 = 63230256;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24482881 = 303623;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj77415268 = -81027801;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95938569 = -342349067;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj57993304 = -866909088;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5825877 = 1211717;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5671479 = -960337120;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24208010 = -223870827;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj73525546 = -700322076;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95869230 = -631542465;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj96424224 = -135194295;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj68270695 = -500661231;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj64659468 = -84671689;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj51543540 = -127760361;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj85452766 = -739508495;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj1535890 = -844464202;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj7071940 = -756197124;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj57421734 = -510469643;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5844799 = -758661706;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj96729768 = -564458084;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj44768722 = -715413571;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj37275482 = 61699237;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj69978838 = -119995286;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj9194965 = -859554554;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj21407590 = -453673030;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj28466347 = -831887488;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj1141001 = -646087567;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj66800718 = -604998569;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj83051847 = -925632057;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj62481178 = 90940486;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj70891113 = 11779872;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj97535125 = -593628756;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj38756869 = -194596555;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj32975727 = -343174469;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24490725 = 84370886;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95145359 = -835998594;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj27236619 = -922974359;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24714531 = -373875442;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj75519735 = -69903483;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj51884476 = 78938035;    float zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj18212061 = 66696928;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj33864223 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj93917469;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj93917469 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23104232;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23104232 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj92010315;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj92010315 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj63970693;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj63970693 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj51200180;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj51200180 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj7220784;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj7220784 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj11787977;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj11787977 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj73739554;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj73739554 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj69106159;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj69106159 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj8018819;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj8018819 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95194190;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95194190 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj16455321;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj16455321 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj9689793;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj9689793 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24321668;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24321668 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj9518488;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj9518488 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23696331;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23696331 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23515425;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23515425 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5081007;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5081007 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj6187776;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj6187776 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj27725041;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj27725041 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj90934773;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj90934773 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj63555151;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj63555151 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj20613308;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj20613308 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj65949180;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj65949180 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj16489534;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj16489534 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj26717300;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj26717300 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj29805515;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj29805515 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj15849407;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj15849407 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj15746250;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj15746250 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj63280282;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj63280282 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj2347340;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj2347340 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj70986181;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj70986181 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj42929774;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj42929774 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj13820562;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj13820562 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj27897443;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj27897443 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj41247793;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj41247793 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj59036862;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj59036862 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj71971884;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj71971884 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj19628240;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj19628240 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj4651887;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj4651887 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj20653101;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj20653101 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj33513040;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj33513040 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj57710353;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj57710353 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23883540;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj23883540 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj21180458;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj21180458 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj79214051;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj79214051 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj56738461;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj56738461 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj20610550;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj20610550 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj94441816;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj94441816 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj87279903;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj87279903 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj62139282;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj62139282 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj35546622;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj35546622 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj87934333;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj87934333 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj80448595;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj80448595 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj42929449;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj42929449 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj30362318;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj30362318 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj2490924;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj2490924 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj26061136;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj26061136 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj47481160;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj47481160 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24482881;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24482881 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj77415268;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj77415268 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95938569;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95938569 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj57993304;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj57993304 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5825877;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5825877 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5671479;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5671479 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24208010;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24208010 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj73525546;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj73525546 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95869230;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95869230 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj96424224;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj96424224 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj68270695;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj68270695 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj64659468;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj64659468 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj51543540;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj51543540 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj85452766;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj85452766 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj1535890;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj1535890 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj7071940;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj7071940 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj57421734;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj57421734 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5844799;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj5844799 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj96729768;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj96729768 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj44768722;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj44768722 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj37275482;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj37275482 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj69978838;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj69978838 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj9194965;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj9194965 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj21407590;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj21407590 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj28466347;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj28466347 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj1141001;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj1141001 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj66800718;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj66800718 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj83051847;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj83051847 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj62481178;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj62481178 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj70891113;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj70891113 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj97535125;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj97535125 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj38756869;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj38756869 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj32975727;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj32975727 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24490725;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24490725 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95145359;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj95145359 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj27236619;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj27236619 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24714531;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj24714531 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj75519735;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj75519735 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj51884476;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj51884476 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj18212061;     zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj18212061 = zIAdjCCdvwVBRKmkwHIUcPKjgEtZBEeDFIBciQsacj33864223;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void uSfboQhEIwAIZZGCycOazsTRaUeVQHbcC68476293() {     float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE23990531 = 7940727;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE77042534 = -212352618;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE18596931 = -467232924;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE65508890 = -920122237;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE77027428 = -653441100;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE31986585 = -643808327;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1884222 = -520992310;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE64666539 = -85415334;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE97551241 = -57509748;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE73361829 = -862731315;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE84170637 = -567835294;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE29943699 = -209895419;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE54801453 = -148863152;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48108646 = -103944334;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE22396039 = -272858488;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE33698230 = -100835413;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE67658511 = -510921903;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE44871137 = -623008510;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE65995397 = -41613900;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE73512024 = -496344671;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE15647443 = -276846724;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE89016355 = -880378849;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE96793569 = -184971874;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE28534405 = -73265081;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE12834368 = -555730855;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE35280498 = -551221649;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48684635 = -411007837;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE52975890 = -762309095;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE77058404 = -768817577;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE63535329 = -57110414;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE66743685 = -420735050;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1714254 = -599902437;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE79955222 = -706661617;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE66768418 = -127756373;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE49417096 = -124576647;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE81128450 = -955572661;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41481362 = -415610217;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE83394145 = 69035783;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE82504901 = -759860903;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE64140382 = -840402743;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE18351560 = -809863435;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE75297564 = -630717722;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE93329881 = -412238166;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE88372293 = -983933436;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE15847957 = -173292578;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41619452 = -680430246;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE59637342 = -185529652;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE47124921 = -458139811;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48529204 = -178803829;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE23722223 = 90058163;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE16645427 = -725202580;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE5912389 = -412407773;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE84999076 = -205932443;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE40841396 = -604359682;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE52828850 = -255845973;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE34974175 = -111680424;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE80248964 = 72619256;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE90062525 = -293967844;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE52674522 = -264391383;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41746930 = -2219451;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE83301949 = -132800491;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48908331 = -758683216;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE87608135 = -316597758;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE34015912 = 99600665;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE6618145 = -341996265;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE82456383 = -967932858;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE49988476 = -503233802;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE88033034 = 78893221;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE98691549 = -979367688;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41267589 = -317285828;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE92216868 = -685225197;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE84264365 = -479957686;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE62366235 = -863147608;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1855016 = -201211157;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE55160464 = -686481236;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE40349879 = -646129003;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE95686474 = -368140683;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE8421276 = -201038438;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE12686449 = -899972504;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE71214916 = -875300609;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE75643156 = -265691998;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1559715 = -952868026;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE4446686 = -483505266;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE53336182 = -758875741;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE46889903 = -331907834;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE60831296 = 91672722;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE16715177 = -293969994;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE39113826 = -2301935;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE13939569 = -871910401;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE14442921 = 87103777;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE879486 = -928191917;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE51418836 = -21642374;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE30719623 = -666572835;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE40757971 = -657641453;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE80838432 = -607602253;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE69443229 = 48819780;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE87689429 = -214119965;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE59313969 = -411838832;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE81754149 = -541937172;    float JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE33391573 = 7940727;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE23990531 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE77042534;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE77042534 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE18596931;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE18596931 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE65508890;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE65508890 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE77027428;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE77027428 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE31986585;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE31986585 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1884222;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1884222 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE64666539;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE64666539 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE97551241;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE97551241 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE73361829;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE73361829 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE84170637;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE84170637 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE29943699;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE29943699 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE54801453;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE54801453 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48108646;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48108646 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE22396039;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE22396039 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE33698230;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE33698230 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE67658511;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE67658511 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE44871137;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE44871137 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE65995397;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE65995397 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE73512024;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE73512024 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE15647443;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE15647443 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE89016355;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE89016355 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE96793569;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE96793569 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE28534405;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE28534405 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE12834368;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE12834368 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE35280498;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE35280498 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48684635;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48684635 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE52975890;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE52975890 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE77058404;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE77058404 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE63535329;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE63535329 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE66743685;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE66743685 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1714254;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1714254 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE79955222;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE79955222 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE66768418;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE66768418 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE49417096;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE49417096 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE81128450;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE81128450 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41481362;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41481362 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE83394145;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE83394145 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE82504901;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE82504901 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE64140382;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE64140382 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE18351560;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE18351560 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE75297564;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE75297564 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE93329881;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE93329881 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE88372293;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE88372293 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE15847957;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE15847957 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41619452;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41619452 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE59637342;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE59637342 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE47124921;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE47124921 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48529204;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48529204 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE23722223;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE23722223 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE16645427;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE16645427 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE5912389;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE5912389 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE84999076;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE84999076 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE40841396;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE40841396 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE52828850;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE52828850 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE34974175;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE34974175 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE80248964;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE80248964 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE90062525;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE90062525 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE52674522;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE52674522 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41746930;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41746930 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE83301949;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE83301949 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48908331;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE48908331 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE87608135;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE87608135 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE34015912;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE34015912 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE6618145;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE6618145 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE82456383;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE82456383 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE49988476;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE49988476 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE88033034;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE88033034 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE98691549;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE98691549 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41267589;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE41267589 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE92216868;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE92216868 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE84264365;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE84264365 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE62366235;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE62366235 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1855016;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1855016 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE55160464;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE55160464 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE40349879;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE40349879 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE95686474;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE95686474 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE8421276;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE8421276 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE12686449;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE12686449 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE71214916;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE71214916 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE75643156;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE75643156 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1559715;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE1559715 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE4446686;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE4446686 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE53336182;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE53336182 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE46889903;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE46889903 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE60831296;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE60831296 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE16715177;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE16715177 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE39113826;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE39113826 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE13939569;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE13939569 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE14442921;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE14442921 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE879486;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE879486 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE51418836;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE51418836 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE30719623;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE30719623 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE40757971;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE40757971 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE80838432;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE80838432 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE69443229;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE69443229 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE87689429;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE87689429 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE59313969;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE59313969 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE81754149;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE81754149 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE33391573;     JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE33391573 = JroZYAnWwBiLgLKAZjsfvGCyNAUlMnAUYGQiRcZbaE23990531;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void oyYiGmreLSPBJqQvtMBvGSlmDOuOWgBzw81021482() {     float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi43458701 = -405190485;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi30066398 = -758230614;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi35433923 = -118861539;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi84156039 = -736696500;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi77473945 = -179713516;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi57578659 = -534293095;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi46716100 = -964298540;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi29916773 = -179223300;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi58238039 = -785701127;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi51290552 = -868317361;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi38393901 = 99174406;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi33438312 = -209198123;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi45173112 = -573220428;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi56524686 = -646230060;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi82922500 = -570942280;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi99913878 = -564027347;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi73620624 = -682696585;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi68933888 = -373763228;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi65630277 = -418818660;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54123326 = -113881127;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi28103515 = -883059050;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi3998439 = -292182062;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64966575 = -482546493;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi46256074 = -809809073;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi24037857 = -850030964;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi40047960 = -237016868;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi32612766 = -76158768;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi3767565 = -926042374;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi18803361 = -782728723;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi48242184 = -148549108;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi96547770 = -286061143;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi41293564 = -64251455;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi91431325 = -161869384;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi25524926 = -432359580;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi89347432 = -187279453;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi17194388 = -159141269;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi9864813 = -942486292;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi24876620 = -8173033;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi49818227 = -124275729;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi85422117 = -836933839;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi59833617 = -219649731;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi87156697 = -869613947;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64463122 = -360039964;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi71757832 = -333006097;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi95876367 = -450415541;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi96080578 = -117761667;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi41627222 = -99222975;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi47280751 = -641427125;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi89664795 = -192743068;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64620565 = -770954182;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi91080995 = -31567511;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi22361249 = -789760632;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54824223 = -982041404;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi13771425 = -598953319;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi52917967 = -30404608;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi39460263 = -13008423;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi65099822 = -175684122;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi89177848 = -309052467;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi60118182 = -886665537;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi37425985 = -942696649;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi24965893 = -358134327;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi42948535 = 61743833;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi11113412 = -396494578;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi9995856 = -537152019;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54742782 = -482256218;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi97100336 = -836574140;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi42006986 = 52671260;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi19648187 = -40860849;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi67177254 = -358950608;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi65728113 = -311801011;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi90049066 = -621541056;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi48744004 = -574523552;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi19115662 = -149487500;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi80208159 = -581884821;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi94289708 = -894231397;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi40946818 = 86554897;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi39535317 = -932142099;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi93208742 = -49540396;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi50379706 = -259393532;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi27957279 = -632269297;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi98420737 = -37793893;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi85332015 = -434731644;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi14102770 = -633299307;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54182796 = 88225459;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi57161188 = -16981597;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi74186521 = -496300511;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi86469341 = -82210051;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi77659901 = -562916065;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi72606958 = -301954972;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi49887170 = -74271030;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi52094565 = -983457148;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi20686964 = -533433825;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64758438 = -121507497;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi12392242 = -181579080;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi60456225 = -378799512;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi16885083 = -181393565;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi76043285 = -373119370;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54467267 = -822887945;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi17015051 = -850749879;    float YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi98776031 = -405190485;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi43458701 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi30066398;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi30066398 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi35433923;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi35433923 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi84156039;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi84156039 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi77473945;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi77473945 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi57578659;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi57578659 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi46716100;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi46716100 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi29916773;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi29916773 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi58238039;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi58238039 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi51290552;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi51290552 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi38393901;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi38393901 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi33438312;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi33438312 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi45173112;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi45173112 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi56524686;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi56524686 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi82922500;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi82922500 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi99913878;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi99913878 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi73620624;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi73620624 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi68933888;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi68933888 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi65630277;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi65630277 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54123326;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54123326 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi28103515;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi28103515 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi3998439;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi3998439 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64966575;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64966575 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi46256074;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi46256074 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi24037857;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi24037857 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi40047960;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi40047960 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi32612766;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi32612766 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi3767565;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi3767565 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi18803361;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi18803361 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi48242184;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi48242184 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi96547770;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi96547770 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi41293564;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi41293564 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi91431325;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi91431325 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi25524926;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi25524926 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi89347432;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi89347432 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi17194388;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi17194388 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi9864813;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi9864813 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi24876620;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi24876620 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi49818227;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi49818227 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi85422117;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi85422117 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi59833617;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi59833617 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi87156697;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi87156697 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64463122;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64463122 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi71757832;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi71757832 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi95876367;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi95876367 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi96080578;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi96080578 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi41627222;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi41627222 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi47280751;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi47280751 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi89664795;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi89664795 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64620565;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64620565 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi91080995;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi91080995 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi22361249;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi22361249 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54824223;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54824223 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi13771425;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi13771425 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi52917967;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi52917967 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi39460263;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi39460263 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi65099822;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi65099822 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi89177848;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi89177848 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi60118182;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi60118182 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi37425985;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi37425985 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi24965893;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi24965893 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi42948535;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi42948535 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi11113412;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi11113412 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi9995856;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi9995856 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54742782;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54742782 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi97100336;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi97100336 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi42006986;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi42006986 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi19648187;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi19648187 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi67177254;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi67177254 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi65728113;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi65728113 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi90049066;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi90049066 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi48744004;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi48744004 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi19115662;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi19115662 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi80208159;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi80208159 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi94289708;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi94289708 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi40946818;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi40946818 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi39535317;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi39535317 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi93208742;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi93208742 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi50379706;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi50379706 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi27957279;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi27957279 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi98420737;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi98420737 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi85332015;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi85332015 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi14102770;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi14102770 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54182796;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54182796 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi57161188;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi57161188 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi74186521;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi74186521 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi86469341;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi86469341 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi77659901;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi77659901 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi72606958;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi72606958 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi49887170;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi49887170 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi52094565;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi52094565 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi20686964;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi20686964 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64758438;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi64758438 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi12392242;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi12392242 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi60456225;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi60456225 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi16885083;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi16885083 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi76043285;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi76043285 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54467267;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi54467267 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi17015051;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi17015051 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi98776031;     YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi98776031 = YkBqhrfNqgAjcBVxOTmFQYWMmesscIfRQFlFOFLUVi43458701;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void LdYqRhTfaLvUPVOmPHoDCkUTRWyopqQxJ77204642() {     float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB3054798 = -633946862;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB31572248 = -568385999;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB72435310 = -193002462;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80031797 = -509307378;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB88767171 = -80220543;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB55255780 = -392552768;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB44074583 = -294016126;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80742056 = -533434675;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB72051482 = -218373626;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB34315067 = -809576214;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB63688832 = -302368034;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68109513 = -304219373;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB15927676 = -479398947;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB14898525 = -550388407;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80230306 = -263468801;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB96668132 = -369400238;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB9581729 = -610912865;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB33602219 = -743099333;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB46072480 = -557938290;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB34040435 = -776289780;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB8564634 = -716079874;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB72488037 = -184583940;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB57158400 = -246841572;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB10986313 = -374147309;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB15862 = -306168554;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB34462867 = -371634339;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45952836 = -525638765;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68878734 = -447423964;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68587704 = -572321338;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB86715650 = -195532350;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB21462089 = -931280471;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB84058824 = -481469452;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB40513364 = -141816256;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB8049368 = 65756489;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB94284793 = -935489438;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB95784283 = -470797851;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB496490 = -135264926;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB23236958 = 47374577;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68836169 = -942982245;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB58247772 = -10814787;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB18051431 = -688311328;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB57235878 = -874555366;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB5342365 = -93484793;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45997338 = -756920836;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB96864683 = -996733609;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB60873707 = -360705826;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB47115944 = 8921358;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB93977144 = -974180353;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB29054443 = -476680687;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB79787957 = 7793357;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB41567246 = -917675735;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB28946402 = -761003887;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB30239737 = -121989858;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB87045947 = -859122274;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68640009 = 5661305;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB30566761 = -349362923;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB74413847 = -221544428;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB61448998 = -818855153;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80015935 = -103138824;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB54304305 = -708586205;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB9302944 = -866914003;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB75195848 = -846592162;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB12154353 = -961113338;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB85335832 = 77158724;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB12852979 = -878295744;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB79630008 = -820898582;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB27596150 = -62403117;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB7878308 = -445155436;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB20613732 = -614898970;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB84446022 = -792670950;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB96171643 = -134135312;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB86344770 = -558287443;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB64766050 = -800117089;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB87824707 = -447123503;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB15989005 = 12021547;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB51328755 = -841524509;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB67145673 = 8900853;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB11161063 = -489920736;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB14121630 = -377413701;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39142155 = -945462728;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB87346922 = -280555697;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB51975692 = -551458413;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39824291 = -970743277;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB88799746 = -480114696;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45148404 = -277856616;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB92515686 = -70276584;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB53819087 = -259479595;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB53467416 = -282693983;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39409359 = -939904816;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB63718032 = -486126516;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB21370437 = -149253424;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39047492 = -316409774;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB43221022 = -849486599;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB14531865 = -134396041;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB48944829 = -143900785;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB42855582 = -841719166;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45081526 = -913442029;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB20006532 = -70643518;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB33144359 = -878625093;    float TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB17234676 = -633946862;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB3054798 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB31572248;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB31572248 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB72435310;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB72435310 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80031797;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80031797 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB88767171;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB88767171 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB55255780;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB55255780 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB44074583;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB44074583 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80742056;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80742056 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB72051482;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB72051482 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB34315067;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB34315067 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB63688832;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB63688832 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68109513;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68109513 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB15927676;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB15927676 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB14898525;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB14898525 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80230306;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80230306 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB96668132;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB96668132 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB9581729;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB9581729 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB33602219;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB33602219 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB46072480;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB46072480 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB34040435;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB34040435 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB8564634;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB8564634 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB72488037;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB72488037 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB57158400;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB57158400 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB10986313;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB10986313 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB15862;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB15862 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB34462867;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB34462867 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45952836;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45952836 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68878734;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68878734 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68587704;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68587704 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB86715650;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB86715650 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB21462089;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB21462089 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB84058824;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB84058824 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB40513364;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB40513364 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB8049368;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB8049368 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB94284793;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB94284793 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB95784283;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB95784283 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB496490;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB496490 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB23236958;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB23236958 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68836169;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68836169 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB58247772;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB58247772 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB18051431;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB18051431 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB57235878;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB57235878 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB5342365;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB5342365 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45997338;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45997338 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB96864683;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB96864683 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB60873707;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB60873707 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB47115944;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB47115944 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB93977144;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB93977144 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB29054443;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB29054443 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB79787957;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB79787957 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB41567246;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB41567246 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB28946402;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB28946402 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB30239737;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB30239737 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB87045947;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB87045947 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68640009;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB68640009 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB30566761;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB30566761 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB74413847;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB74413847 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB61448998;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB61448998 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80015935;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB80015935 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB54304305;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB54304305 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB9302944;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB9302944 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB75195848;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB75195848 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB12154353;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB12154353 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB85335832;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB85335832 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB12852979;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB12852979 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB79630008;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB79630008 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB27596150;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB27596150 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB7878308;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB7878308 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB20613732;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB20613732 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB84446022;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB84446022 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB96171643;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB96171643 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB86344770;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB86344770 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB64766050;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB64766050 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB87824707;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB87824707 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB15989005;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB15989005 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB51328755;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB51328755 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB67145673;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB67145673 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB11161063;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB11161063 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB14121630;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB14121630 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39142155;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39142155 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB87346922;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB87346922 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB51975692;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB51975692 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39824291;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39824291 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB88799746;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB88799746 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45148404;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45148404 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB92515686;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB92515686 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB53819087;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB53819087 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB53467416;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB53467416 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39409359;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39409359 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB63718032;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB63718032 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB21370437;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB21370437 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39047492;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB39047492 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB43221022;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB43221022 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB14531865;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB14531865 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB48944829;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB48944829 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB42855582;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB42855582 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45081526;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB45081526 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB20006532;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB20006532 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB33144359;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB33144359 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB17234676;     TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB17234676 = TgqJHtHCQTfbNOtwDFrefRbIFZuifqkuxLwpYdINhB3054798;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void hjXbVVTNyEnPPpXHayDtcWeaJkaZMYPgS89749831() {     float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm22522969 = 52921926;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm84596111 = -14263995;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89272302 = -944631077;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm98678946 = -325881641;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89213687 = -706492959;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm80847854 = -283037537;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm88906461 = -737322356;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm45992290 = -627242641;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm32738280 = -946565005;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm12243791 = -815162260;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm17912096 = -735358334;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm71604127 = -303522078;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm6299335 = -903756223;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm23314565 = 7325867;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm40756768 = -561552592;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm62883782 = -832592172;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm15543842 = -782687546;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm57664971 = -493854051;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm45707359 = -935143051;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm14651738 = -393826236;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm21020706 = -222292200;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm87470120 = -696387153;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm25331407 = -544416190;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm28707981 = -10691301;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm11219351 = -600468664;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm39230328 = -57429557;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm29880968 = -190789697;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm19670409 = -611157243;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm10332661 = -586232484;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm71422504 = -286971045;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51266173 = -796606564;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm23638135 = 54181530;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51989468 = -697024023;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm66805875 = -238846717;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm34215130 = -998192244;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm31850221 = -774366460;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm68879940 = -662141001;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm64719432 = -29834238;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm36149494 = -307397070;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm79529508 = -7345884;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm59533488 = -98097623;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm69095011 = -13451592;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm76475605 = -41286591;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm29382877 = -105993497;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm76893094 = -173856572;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm15334835 = -898037248;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm29105824 = 95228035;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm94132974 = -57467668;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm70190034 = -490619926;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm20686300 = -853218988;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm16002816 = -224040666;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm45395262 = -38356747;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm64884 = -898098819;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm59975976 = -853715910;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm68729125 = -868897330;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm35052848 = -250690921;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm59264705 = -469847806;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm60564321 = -833939776;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm87459595 = -725412978;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm49983359 = -549063403;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm50966886 = 7752160;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm69236052 = -26165113;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm35659629 = 58989842;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm61315775 = -559593961;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm60977617 = 81444303;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm94273960 = -689539864;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm19614660 = -606498055;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm39493460 = -564909507;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89099435 = 5518111;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm8906547 = -787186133;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm94003841 = -70451171;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm50824409 = -652853309;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm21515477 = -86456982;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm66177851 = -827797167;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm55118249 = -195728614;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51925695 = -108840609;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm10994515 = -555100563;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm95948530 = -338422694;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51814887 = -836834729;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm95884516 = -702431417;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm10124505 = -52657592;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm35747993 = -33322030;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm49480375 = -20537318;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89646361 = -733013497;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm55419689 = 37069621;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm5870912 = -658249818;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm23573252 = -47719652;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm92013491 = -843308113;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm98076749 = -369949387;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm99162281 = -647501324;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm72585516 = -204518654;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm8315620 = -828201226;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm77259836 = -304421261;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm86166134 = -758333668;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm28562622 = 84901956;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm90297435 = 28067490;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm33435382 = 27558565;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm15159830 = -481692631;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm68405259 = -87437800;    float DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm82619133 = 52921926;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm22522969 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm84596111;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm84596111 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89272302;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89272302 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm98678946;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm98678946 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89213687;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89213687 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm80847854;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm80847854 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm88906461;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm88906461 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm45992290;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm45992290 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm32738280;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm32738280 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm12243791;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm12243791 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm17912096;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm17912096 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm71604127;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm71604127 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm6299335;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm6299335 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm23314565;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm23314565 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm40756768;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm40756768 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm62883782;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm62883782 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm15543842;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm15543842 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm57664971;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm57664971 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm45707359;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm45707359 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm14651738;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm14651738 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm21020706;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm21020706 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm87470120;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm87470120 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm25331407;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm25331407 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm28707981;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm28707981 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm11219351;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm11219351 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm39230328;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm39230328 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm29880968;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm29880968 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm19670409;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm19670409 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm10332661;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm10332661 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm71422504;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm71422504 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51266173;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51266173 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm23638135;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm23638135 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51989468;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51989468 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm66805875;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm66805875 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm34215130;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm34215130 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm31850221;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm31850221 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm68879940;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm68879940 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm64719432;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm64719432 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm36149494;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm36149494 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm79529508;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm79529508 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm59533488;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm59533488 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm69095011;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm69095011 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm76475605;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm76475605 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm29382877;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm29382877 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm76893094;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm76893094 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm15334835;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm15334835 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm29105824;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm29105824 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm94132974;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm94132974 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm70190034;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm70190034 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm20686300;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm20686300 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm16002816;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm16002816 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm45395262;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm45395262 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm64884;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm64884 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm59975976;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm59975976 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm68729125;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm68729125 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm35052848;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm35052848 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm59264705;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm59264705 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm60564321;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm60564321 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm87459595;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm87459595 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm49983359;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm49983359 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm50966886;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm50966886 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm69236052;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm69236052 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm35659629;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm35659629 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm61315775;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm61315775 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm60977617;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm60977617 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm94273960;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm94273960 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm19614660;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm19614660 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm39493460;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm39493460 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89099435;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89099435 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm8906547;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm8906547 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm94003841;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm94003841 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm50824409;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm50824409 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm21515477;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm21515477 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm66177851;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm66177851 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm55118249;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm55118249 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51925695;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51925695 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm10994515;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm10994515 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm95948530;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm95948530 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51814887;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm51814887 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm95884516;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm95884516 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm10124505;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm10124505 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm35747993;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm35747993 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm49480375;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm49480375 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89646361;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm89646361 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm55419689;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm55419689 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm5870912;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm5870912 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm23573252;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm23573252 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm92013491;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm92013491 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm98076749;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm98076749 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm99162281;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm99162281 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm72585516;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm72585516 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm8315620;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm8315620 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm77259836;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm77259836 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm86166134;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm86166134 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm28562622;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm28562622 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm90297435;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm90297435 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm33435382;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm33435382 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm15159830;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm15159830 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm68405259;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm68405259 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm82619133;     DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm82619133 = DaBlRtTGLInTzEdmxqoFPzKExSkvuAapHxLPVVJFkm22522969;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void qppRaJnvUKQBAnSMFcSzIJKgicaGcPBOC50052489() {     float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT12649277 = -5834275;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT67721176 = -389190165;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT84765001 = 18574462;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT72177521 = -512053463;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT2270423 = -647816401;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT61634258 = -175670645;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT83569899 = -374867828;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98870853 = -263690380;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT56549967 = -954457643;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT16499461 = -385036785;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT94063914 = -143778491;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT6353635 = -883110213;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT44645467 = -115992084;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT61733419 = 9164982;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT38831139 = 53326465;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT87063524 = -532972042;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT59506022 = 55967212;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT79020683 = -936703344;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT6621751 = -301553487;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT81975985 = 58295454;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT8943109 = 73282708;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT85551702 = 70516211;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT58569825 = -950876111;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT36629079 = -458715677;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT58104539 = -143979608;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT58021293 = 66696708;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT51848302 = 49681309;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT42840784 = -671047301;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT71541658 = -248431532;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT19211585 = -161373436;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT54729576 = -23273107;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT23005049 = -446642890;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT60958509 = -997249183;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT90644519 = -230297875;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT69811664 = -648527905;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT85081227 = 22604130;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT69113509 = -177956906;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT89076715 = -995893482;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT46682511 = -14859116;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT24041650 = 87946343;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT73233161 = -903958899;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT23739475 = -927944805;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT36292447 = -516712186;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT60044817 = 29923315;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT68857512 = -286366528;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT35773828 = -281661153;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT9529114 = -553254465;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT84519433 = -84123921;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98108687 = -926559272;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49966706 = -210215325;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT45368339 = -598422711;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT89168369 = -2783579;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49517338 = -609951814;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT12883039 = -977271192;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT41109381 = -997497602;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT27097575 = 23649513;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT9151352 = -438314055;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT48135923 = -522709861;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT14072983 = -268073856;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT44249130 = -614513110;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT9785956 = -125351954;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT40729115 = -703820528;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT27329195 = 84741151;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT37338383 = -693084207;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT61769884 = -261763678;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT71058866 = -697135602;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT45395126 = -885861031;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT54000947 = -885694209;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT91921755 = -342307113;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT53749912 = -969277666;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT17950015 = -255015137;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT70429306 = 51860694;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT32338172 = -821844228;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT82580100 = -289499830;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT8742825 = -37745648;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT85203633 = 1227512;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49259256 = -412771603;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98525007 = -880799426;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT67771566 = -72349149;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT22330711 = -862318455;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT48492179 = -380048827;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT67328869 = -866194771;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT44732096 = -744488029;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT21574953 = 61783793;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT73843245 = -562950725;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT65561207 = 79510472;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT73487710 = -836691077;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT48075470 = 80022009;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49535139 = -232800274;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT42714089 = -572177419;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT75929876 = -539081815;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT20977587 = -655247045;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT75003733 = -627819627;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT2433382 = -400346007;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT14255694 = -786701704;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT32504046 = -100138371;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT96410279 = -912685957;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98954063 = -823627980;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98274933 = -708313008;    float eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT97798646 = -5834275;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT12649277 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT67721176;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT67721176 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT84765001;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT84765001 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT72177521;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT72177521 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT2270423;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT2270423 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT61634258;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT61634258 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT83569899;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT83569899 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98870853;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98870853 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT56549967;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT56549967 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT16499461;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT16499461 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT94063914;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT94063914 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT6353635;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT6353635 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT44645467;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT44645467 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT61733419;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT61733419 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT38831139;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT38831139 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT87063524;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT87063524 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT59506022;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT59506022 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT79020683;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT79020683 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT6621751;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT6621751 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT81975985;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT81975985 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT8943109;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT8943109 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT85551702;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT85551702 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT58569825;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT58569825 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT36629079;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT36629079 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT58104539;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT58104539 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT58021293;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT58021293 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT51848302;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT51848302 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT42840784;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT42840784 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT71541658;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT71541658 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT19211585;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT19211585 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT54729576;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT54729576 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT23005049;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT23005049 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT60958509;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT60958509 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT90644519;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT90644519 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT69811664;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT69811664 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT85081227;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT85081227 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT69113509;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT69113509 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT89076715;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT89076715 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT46682511;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT46682511 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT24041650;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT24041650 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT73233161;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT73233161 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT23739475;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT23739475 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT36292447;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT36292447 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT60044817;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT60044817 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT68857512;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT68857512 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT35773828;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT35773828 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT9529114;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT9529114 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT84519433;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT84519433 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98108687;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98108687 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49966706;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49966706 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT45368339;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT45368339 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT89168369;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT89168369 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49517338;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49517338 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT12883039;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT12883039 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT41109381;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT41109381 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT27097575;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT27097575 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT9151352;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT9151352 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT48135923;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT48135923 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT14072983;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT14072983 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT44249130;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT44249130 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT9785956;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT9785956 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT40729115;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT40729115 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT27329195;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT27329195 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT37338383;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT37338383 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT61769884;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT61769884 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT71058866;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT71058866 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT45395126;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT45395126 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT54000947;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT54000947 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT91921755;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT91921755 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT53749912;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT53749912 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT17950015;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT17950015 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT70429306;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT70429306 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT32338172;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT32338172 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT82580100;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT82580100 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT8742825;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT8742825 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT85203633;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT85203633 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49259256;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49259256 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98525007;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98525007 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT67771566;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT67771566 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT22330711;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT22330711 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT48492179;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT48492179 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT67328869;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT67328869 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT44732096;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT44732096 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT21574953;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT21574953 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT73843245;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT73843245 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT65561207;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT65561207 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT73487710;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT73487710 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT48075470;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT48075470 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49535139;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT49535139 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT42714089;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT42714089 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT75929876;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT75929876 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT20977587;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT20977587 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT75003733;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT75003733 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT2433382;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT2433382 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT14255694;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT14255694 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT32504046;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT32504046 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT96410279;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT96410279 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98954063;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98954063 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98274933;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT98274933 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT97798646;     eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT97798646 = eYnNYtCfrmBwGLKidyeAJAgfJixjhSEJCzVPfyhiQT12649277;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void ogzYTgZcBxROftEiFXNCbQuWHMABFioRQ46235649() {     float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB72245373 = -234590652;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB69227026 = -199345550;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB21766389 = -55566460;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB68053280 = -284664340;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB13563649 = -548323428;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB59311379 = -33930318;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB80928382 = -804585414;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB49696137 = -617901755;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB70363411 = -387130142;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB99523975 = -326295639;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB19358847 = -545320931;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB41024836 = -978131462;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB15400030 = -22170602;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB20107258 = -994993365;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB36138945 = -739200056;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB83817778 = -338344933;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95467125 = -972249068;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB43689014 = -206039448;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB87063953 = -440673117;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB61893094 = -604113199;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB89404226 = -859738117;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB54041301 = -921885666;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB50761650 = -715171190;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB1359318 = -23053914;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB34082544 = -700117198;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB52436200 = -67920763;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65188373 = -399798688;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB7951953 = -192428891;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB21326002 = -38024147;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB57685051 = -208356678;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB79643894 = -668492435;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65770309 = -863860887;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB10040548 = -977196055;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB73168962 = -832181806;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB74749025 = -296737891;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB63671124 = -289052452;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB59745187 = -470735540;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB87437052 = -940345872;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65700454 = -833565633;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB96867304 = -185934605;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB31450975 = -272620495;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB93818655 = -932886223;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB77171689 = -250157016;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB34284323 = -393991424;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB69845827 = -832684597;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB566957 = -524605312;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB15017837 = -445110132;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB31215828 = -416877149;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB37498336 = -110496892;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65134098 = -531467786;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95854589 = -384530935;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95753522 = 25973165;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB24932853 = -849900267;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB86157561 = -137440147;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB56831422 = -961431689;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB18204073 = -312704986;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB18465377 = -484174361;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB20407072 = 67487453;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB33970736 = -584547143;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB61127449 = -380402666;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB94123006 = -634131630;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB72976429 = -512156523;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB28370136 = -479877609;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB12678361 = -78773464;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB19880081 = -657803204;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB53588537 = -681460044;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB30984289 = 99064592;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB42231068 = -189988796;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB45358233 = -598255474;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB72467821 = -350147605;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB24072592 = -867609394;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB8030073 = 68096803;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB77988560 = -372473816;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB90196648 = -154738512;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB30442120 = -231492704;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95585571 = -926851894;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB76869612 = -571728651;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB16477328 = -221179767;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB31513490 = -190369317;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB33515587 = -75511886;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB37418364 = -622810631;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB33972546 = -982921539;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB70453617 = 18068000;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB56191904 = -506556362;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB61830461 = -823825744;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB83890372 = -594465601;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB40837457 = 86039380;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB23882986 = -739755908;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB16337540 = -870750118;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB56544952 = -984032905;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB45205748 = -804878091;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB39338115 = -438222993;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB53466317 = -255798729;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB4573005 = -353162967;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB2744299 = -551802976;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB58474545 = -760463972;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65448520 = -353008615;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB64493329 = -71383552;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB14404242 = -736188221;    float kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB16257291 = -234590652;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB72245373 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB69227026;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB69227026 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB21766389;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB21766389 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB68053280;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB68053280 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB13563649;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB13563649 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB59311379;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB59311379 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB80928382;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB80928382 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB49696137;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB49696137 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB70363411;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB70363411 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB99523975;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB99523975 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB19358847;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB19358847 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB41024836;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB41024836 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB15400030;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB15400030 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB20107258;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB20107258 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB36138945;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB36138945 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB83817778;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB83817778 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95467125;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95467125 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB43689014;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB43689014 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB87063953;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB87063953 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB61893094;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB61893094 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB89404226;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB89404226 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB54041301;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB54041301 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB50761650;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB50761650 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB1359318;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB1359318 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB34082544;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB34082544 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB52436200;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB52436200 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65188373;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65188373 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB7951953;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB7951953 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB21326002;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB21326002 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB57685051;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB57685051 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB79643894;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB79643894 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65770309;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65770309 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB10040548;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB10040548 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB73168962;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB73168962 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB74749025;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB74749025 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB63671124;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB63671124 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB59745187;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB59745187 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB87437052;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB87437052 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65700454;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65700454 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB96867304;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB96867304 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB31450975;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB31450975 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB93818655;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB93818655 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB77171689;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB77171689 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB34284323;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB34284323 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB69845827;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB69845827 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB566957;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB566957 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB15017837;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB15017837 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB31215828;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB31215828 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB37498336;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB37498336 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65134098;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65134098 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95854589;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95854589 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95753522;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95753522 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB24932853;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB24932853 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB86157561;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB86157561 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB56831422;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB56831422 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB18204073;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB18204073 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB18465377;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB18465377 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB20407072;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB20407072 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB33970736;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB33970736 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB61127449;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB61127449 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB94123006;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB94123006 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB72976429;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB72976429 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB28370136;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB28370136 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB12678361;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB12678361 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB19880081;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB19880081 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB53588537;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB53588537 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB30984289;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB30984289 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB42231068;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB42231068 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB45358233;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB45358233 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB72467821;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB72467821 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB24072592;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB24072592 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB8030073;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB8030073 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB77988560;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB77988560 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB90196648;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB90196648 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB30442120;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB30442120 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95585571;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB95585571 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB76869612;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB76869612 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB16477328;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB16477328 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB31513490;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB31513490 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB33515587;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB33515587 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB37418364;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB37418364 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB33972546;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB33972546 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB70453617;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB70453617 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB56191904;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB56191904 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB61830461;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB61830461 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB83890372;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB83890372 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB40837457;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB40837457 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB23882986;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB23882986 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB16337540;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB16337540 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB56544952;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB56544952 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB45205748;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB45205748 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB39338115;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB39338115 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB53466317;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB53466317 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB4573005;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB4573005 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB2744299;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB2744299 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB58474545;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB58474545 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65448520;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB65448520 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB64493329;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB64493329 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB14404242;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB14404242 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB16257291;     kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB16257291 = kLxqqbcBVNZeApBHnjEUgPXmcQGgXWSIAyuiHrOvkB72245373;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void gEyMLOdeGIwMYNqmItKVaNUDwkGmuTVvl58780838() {     float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD91713543 = -647721864;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD22250890 = -745223547;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD38603381 = -807195075;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD86700428 = -101238603;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD14010166 = -74595844;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD84903453 = 75584914;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD25760261 = -147891644;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD14946371 = -711709721;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD31050208 = -15321521;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD77452698 = -331881685;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD73582110 = -978311231;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD44519450 = -977434167;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5771690 = -446527878;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD28523298 = -437279091;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96665406 = 62716152;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD50033427 = -801536867;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD1429239 = -44023749;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD67751766 = 43205834;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD86698832 = -817877877;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD42504396 = -221649655;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD1860299 = -365950442;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD69023384 = -333688879;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD18934656 = 87254191;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD19080986 = -759597905;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD45286033 = -994417307;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD57203661 = -853715981;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD49116504 = -64949620;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD58743627 = -356162170;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD63070958 = -51935293;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD42391905 = -299795373;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD9447980 = -533818528;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5349620 = -328209905;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD21516651 = -432403822;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD31925469 = -36785013;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD14679361 = -359440697;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD99737061 = -592621060;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD28128638 = -997611615;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD28919527 = 82445313;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD33013779 = -197980458;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD18149041 = -182465702;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD72933031 = -782406791;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5677789 = -71782449;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD48304930 = -197958814;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD17669862 = -843064085;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD49874239 = -9807560;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD55028084 = 38063267;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD97007716 = -358803455;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD31371658 = -600164464;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD78633926 = -124436130;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD6032441 = -292480131;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD70290158 = -790895866;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD12202383 = -351379694;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD94757999 = -526009228;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD59087590 = -132033784;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD56920539 = -735990324;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD22690160 = -214032985;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD3316235 = -732477738;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD19522395 = 52402830;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD41414396 = -106821297;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD56806504 = -220879864;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD35786950 = -859465467;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD67016633 = -791729474;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD51875412 = -559774429;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD88658303 = -715526149;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD68004719 = -798063157;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD68232490 = -550101326;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD23002799 = -445030346;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD73846220 = -309742866;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD13843937 = 22161606;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96928344 = -344662788;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD21904790 = -803925253;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD72509711 = -26469063;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD34737987 = -758813709;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD68549792 = -535412176;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD69571365 = -439242865;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96182510 = -194167994;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD20718454 = -35730066;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD1264795 = -69681724;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD69206747 = -649790346;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD90257949 = -932480575;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD60195945 = -394912527;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD17744847 = -464785157;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD80109701 = -131726040;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD57038518 = -759455162;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD72101746 = -508899507;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD97245596 = -82438835;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD10591621 = -802200678;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD62429060 = -200370039;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD75004930 = -300794689;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD91989201 = -45407712;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96420827 = -860143322;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD8606243 = -950014445;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD87505131 = -810733391;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD76207275 = -977100595;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD82362091 = -323000236;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5916399 = -990677317;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD53802376 = -512008021;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD59646627 = -482432665;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD49665142 = 54999072;    float HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD81641748 = -647721864;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD91713543 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD22250890;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD22250890 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD38603381;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD38603381 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD86700428;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD86700428 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD14010166;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD14010166 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD84903453;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD84903453 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD25760261;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD25760261 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD14946371;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD14946371 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD31050208;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD31050208 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD77452698;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD77452698 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD73582110;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD73582110 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD44519450;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD44519450 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5771690;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5771690 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD28523298;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD28523298 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96665406;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96665406 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD50033427;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD50033427 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD1429239;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD1429239 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD67751766;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD67751766 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD86698832;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD86698832 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD42504396;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD42504396 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD1860299;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD1860299 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD69023384;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD69023384 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD18934656;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD18934656 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD19080986;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD19080986 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD45286033;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD45286033 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD57203661;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD57203661 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD49116504;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD49116504 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD58743627;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD58743627 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD63070958;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD63070958 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD42391905;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD42391905 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD9447980;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD9447980 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5349620;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5349620 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD21516651;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD21516651 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD31925469;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD31925469 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD14679361;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD14679361 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD99737061;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD99737061 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD28128638;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD28128638 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD28919527;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD28919527 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD33013779;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD33013779 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD18149041;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD18149041 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD72933031;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD72933031 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5677789;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5677789 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD48304930;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD48304930 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD17669862;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD17669862 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD49874239;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD49874239 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD55028084;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD55028084 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD97007716;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD97007716 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD31371658;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD31371658 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD78633926;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD78633926 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD6032441;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD6032441 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD70290158;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD70290158 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD12202383;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD12202383 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD94757999;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD94757999 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD59087590;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD59087590 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD56920539;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD56920539 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD22690160;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD22690160 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD3316235;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD3316235 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD19522395;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD19522395 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD41414396;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD41414396 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD56806504;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD56806504 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD35786950;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD35786950 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD67016633;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD67016633 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD51875412;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD51875412 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD88658303;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD88658303 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD68004719;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD68004719 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD68232490;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD68232490 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD23002799;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD23002799 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD73846220;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD73846220 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD13843937;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD13843937 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96928344;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96928344 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD21904790;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD21904790 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD72509711;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD72509711 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD34737987;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD34737987 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD68549792;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD68549792 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD69571365;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD69571365 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96182510;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96182510 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD20718454;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD20718454 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD1264795;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD1264795 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD69206747;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD69206747 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD90257949;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD90257949 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD60195945;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD60195945 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD17744847;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD17744847 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD80109701;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD80109701 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD57038518;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD57038518 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD72101746;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD72101746 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD97245596;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD97245596 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD10591621;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD10591621 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD62429060;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD62429060 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD75004930;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD75004930 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD91989201;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD91989201 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96420827;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD96420827 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD8606243;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD8606243 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD87505131;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD87505131 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD76207275;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD76207275 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD82362091;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD82362091 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5916399;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD5916399 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD53802376;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD53802376 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD59646627;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD59646627 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD49665142;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD49665142 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD81641748;     HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD81641748 = HGfuNVbSbNxwgRWkMyFIfBSjvPbIrjnnBaRHLsvYiD91713543;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void mfTOAayuLbFNFgnqVjMeHyzSJKgqrdVeF19083495() {     float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy81839852 = -706478065;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy5375955 = -20149717;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy34096080 = -943989536;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy60199003 = -287410425;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy27066901 = -15919286;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy65689858 = -917048194;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy20423699 = -885437117;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy67824934 = -348157460;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy54861896 = -23214159;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy81708369 = 98243790;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy49733929 = -386731388;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy79268957 = -457022302;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy44117822 = -758763739;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy66942151 = -435439975;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy94739778 = -422404791;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy74213169 = -501916737;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45391419 = -305368991;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy89107478 = -399643459;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy47613224 = -184288313;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy9828645 = -869527965;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy89782701 = -70375535;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy67104966 = -666785515;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy52173074 = -319205730;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy27002084 = -107622281;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy92171221 = -537928251;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy75994626 = -729589716;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy71083839 = -924478614;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy81914002 = -416052229;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy24279957 = -814134341;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy90180985 = -174197764;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy12911383 = -860485072;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy4716534 = -829034325;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy30485692 = -732628981;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy55764114 = -28236171;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy50275895 = -9776358;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy52968068 = -895650470;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy28362207 = -513427519;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy53276810 = -883613931;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy43546796 = 94557497;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy62661182 = -87173475;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy86632705 = -488268066;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy60322252 = -986275662;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy8121772 = -673384409;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy48331802 = -707147274;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy41838656 = -122317516;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy75467077 = -445560638;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy77431006 = 92714045;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy21758117 = -626820717;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy6552581 = -560375477;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy35312846 = -749476468;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy99655682 = -65277911;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy55975490 = -315806527;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy44210454 = -237862223;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy11994653 = -255589065;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy29300794 = -864590595;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy14734887 = 60307449;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy53202881 = -700943988;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy7093997 = -736367256;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy68027782 = -749482175;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy51072275 = -286329571;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy94606019 = -992569581;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy38509696 = -369384889;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy43544978 = -534023119;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy64680911 = -849016395;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy68796986 = -41271139;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45017395 = -557697064;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy48783265 = -724393321;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy88353708 = -630527569;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy16666256 = -325663618;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy41771710 = -526754321;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45850963 = -988489218;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy92114608 = -421755060;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45560682 = -394200956;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy84952041 = 2885161;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy23195940 = -281259899;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy29460450 = -84099873;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy58983194 = -993401106;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy3841272 = -612058456;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy85163427 = -985304766;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy16704144 = 7632387;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy98563619 = -722303762;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy49325722 = -197657897;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy75361422 = -855676752;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy88967110 = 35342127;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy90525302 = -8919853;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy56935892 = -444678545;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy60506080 = -491172102;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy18491040 = -377039917;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy26463320 = -163645576;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy35541009 = 29916193;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy99765187 = -94706483;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy21268210 = -777060264;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy85249028 = -34131757;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy92474521 = -619112933;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy68055163 = -94603895;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy48123009 = -18883178;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy16777274 = -352252543;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy43440861 = -824368014;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy79534815 = -565876136;    float GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy96821261 = -706478065;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy81839852 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy5375955;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy5375955 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy34096080;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy34096080 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy60199003;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy60199003 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy27066901;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy27066901 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy65689858;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy65689858 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy20423699;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy20423699 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy67824934;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy67824934 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy54861896;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy54861896 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy81708369;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy81708369 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy49733929;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy49733929 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy79268957;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy79268957 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy44117822;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy44117822 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy66942151;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy66942151 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy94739778;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy94739778 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy74213169;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy74213169 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45391419;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45391419 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy89107478;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy89107478 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy47613224;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy47613224 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy9828645;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy9828645 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy89782701;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy89782701 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy67104966;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy67104966 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy52173074;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy52173074 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy27002084;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy27002084 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy92171221;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy92171221 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy75994626;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy75994626 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy71083839;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy71083839 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy81914002;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy81914002 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy24279957;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy24279957 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy90180985;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy90180985 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy12911383;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy12911383 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy4716534;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy4716534 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy30485692;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy30485692 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy55764114;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy55764114 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy50275895;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy50275895 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy52968068;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy52968068 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy28362207;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy28362207 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy53276810;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy53276810 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy43546796;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy43546796 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy62661182;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy62661182 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy86632705;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy86632705 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy60322252;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy60322252 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy8121772;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy8121772 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy48331802;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy48331802 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy41838656;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy41838656 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy75467077;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy75467077 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy77431006;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy77431006 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy21758117;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy21758117 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy6552581;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy6552581 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy35312846;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy35312846 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy99655682;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy99655682 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy55975490;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy55975490 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy44210454;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy44210454 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy11994653;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy11994653 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy29300794;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy29300794 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy14734887;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy14734887 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy53202881;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy53202881 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy7093997;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy7093997 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy68027782;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy68027782 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy51072275;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy51072275 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy94606019;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy94606019 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy38509696;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy38509696 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy43544978;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy43544978 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy64680911;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy64680911 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy68796986;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy68796986 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45017395;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45017395 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy48783265;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy48783265 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy88353708;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy88353708 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy16666256;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy16666256 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy41771710;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy41771710 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45850963;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45850963 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy92114608;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy92114608 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45560682;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy45560682 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy84952041;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy84952041 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy23195940;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy23195940 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy29460450;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy29460450 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy58983194;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy58983194 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy3841272;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy3841272 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy85163427;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy85163427 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy16704144;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy16704144 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy98563619;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy98563619 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy49325722;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy49325722 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy75361422;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy75361422 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy88967110;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy88967110 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy90525302;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy90525302 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy56935892;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy56935892 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy60506080;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy60506080 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy18491040;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy18491040 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy26463320;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy26463320 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy35541009;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy35541009 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy99765187;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy99765187 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy21268210;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy21268210 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy85249028;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy85249028 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy92474521;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy92474521 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy68055163;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy68055163 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy48123009;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy48123009 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy16777274;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy16777274 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy43440861;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy43440861 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy79534815;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy79534815 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy96821261;     GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy96821261 = GuEahtXfdTYpdccXsDRzeHofBFptIDiFaHzljPoppy81839852;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void FHLEbgqtXwQWreAkJQuzideznWZageroR15266656() {     float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA41435949 = -935234442;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA6881805 = -930305102;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA71097468 = 81869541;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA56074762 = -60021303;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA38360127 = 83573687;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA63366978 = -775307867;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA17782182 = -215154703;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA18650218 = -702368835;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA68675339 = -555886658;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA64732884 = -943015064;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA75028860 = -788273828;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA13940159 = -552043551;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA14872385 = -664942257;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA25315990 = -339598322;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA92047583 = -114931312;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70967423 = -307289629;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA81352522 = -233585271;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA53775809 = -768979564;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA28055427 = -323407943;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA89745753 = -431936618;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70243819 = 96603641;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA35594565 = -559187393;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44364899 = -83500809;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA91732322 = -771960518;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA68149226 = 5934159;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70409533 = -864207187;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA84423909 = -273958611;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA47025172 = 62566181;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA74064299 = -603726956;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA28654452 = -221181006;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA37825701 = -405704400;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA47481794 = -146252322;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA79567730 = -712575854;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA38288556 = -630120102;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA55213256 = -757986343;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA31557965 = -107307052;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA18993884 = -806206154;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA51637148 = -828066321;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA62564739 = -724149020;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA35486837 = -361054423;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44850518 = -956929663;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA30401433 = -991217081;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA49001014 = -406829238;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA22571308 = -31062012;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA42826972 = -668635584;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA40260207 = -688504797;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA82919728 = -899141622;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA68454510 = -959573945;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA45942228 = -844313097;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA50480238 = 29271071;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA50141932 = -951386135;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA62560643 = -287049782;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA19625969 = -477810677;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA85269175 = -515758021;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA45022836 = -828524682;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA5841385 = -276047050;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA62516905 = -746804294;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA79365145 = -146169942;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA87925535 = 34044538;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA67950594 = -52219127;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA78943069 = -401349257;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70757010 = -177720885;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44585919 = 1358120;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA40020888 = -234705652;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA26907184 = -437310664;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA27547066 = -542021506;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA34372429 = -839467698;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA76583829 = 65177844;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70102734 = -581611979;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA60489619 = 92375740;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA51973540 = -501083475;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA29715375 = -405518951;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA91211070 = 55169456;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA92568589 = -962353520;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44895235 = -475006956;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA39842387 = 87820721;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA86593550 = -52358155;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA21793592 = 47561203;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA48905351 = -3324934;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA27889020 = -305561044;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA87489804 = -965065566;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA15969399 = -314384666;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA1082944 = -93120723;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA23584061 = -532998027;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA78512519 = -269794872;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA75265057 = -18654618;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA27855826 = -668441646;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA94298555 = -96817834;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA93265720 = -801595420;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA49371872 = -381939293;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA69041059 = -360502759;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA39628738 = -560036213;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA63711612 = -762110859;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA94614144 = -571929894;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA56543768 = -959705167;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA74093508 = -679208779;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA85815514 = -892575202;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA8980126 = -72123587;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA95664123 = -593751349;    float OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA15279906 = -935234442;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA41435949 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA6881805;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA6881805 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA71097468;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA71097468 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA56074762;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA56074762 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA38360127;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA38360127 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA63366978;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA63366978 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA17782182;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA17782182 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA18650218;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA18650218 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA68675339;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA68675339 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA64732884;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA64732884 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA75028860;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA75028860 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA13940159;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA13940159 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA14872385;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA14872385 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA25315990;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA25315990 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA92047583;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA92047583 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70967423;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70967423 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA81352522;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA81352522 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA53775809;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA53775809 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA28055427;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA28055427 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA89745753;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA89745753 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70243819;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70243819 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA35594565;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA35594565 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44364899;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44364899 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA91732322;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA91732322 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA68149226;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA68149226 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70409533;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70409533 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA84423909;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA84423909 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA47025172;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA47025172 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA74064299;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA74064299 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA28654452;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA28654452 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA37825701;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA37825701 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA47481794;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA47481794 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA79567730;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA79567730 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA38288556;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA38288556 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA55213256;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA55213256 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA31557965;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA31557965 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA18993884;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA18993884 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA51637148;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA51637148 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA62564739;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA62564739 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA35486837;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA35486837 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44850518;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44850518 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA30401433;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA30401433 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA49001014;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA49001014 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA22571308;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA22571308 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA42826972;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA42826972 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA40260207;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA40260207 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA82919728;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA82919728 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA68454510;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA68454510 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA45942228;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA45942228 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA50480238;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA50480238 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA50141932;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA50141932 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA62560643;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA62560643 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA19625969;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA19625969 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA85269175;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA85269175 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA45022836;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA45022836 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA5841385;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA5841385 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA62516905;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA62516905 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA79365145;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA79365145 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA87925535;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA87925535 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA67950594;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA67950594 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA78943069;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA78943069 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70757010;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70757010 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44585919;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44585919 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA40020888;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA40020888 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA26907184;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA26907184 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA27547066;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA27547066 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA34372429;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA34372429 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA76583829;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA76583829 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70102734;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA70102734 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA60489619;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA60489619 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA51973540;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA51973540 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA29715375;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA29715375 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA91211070;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA91211070 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA92568589;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA92568589 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44895235;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA44895235 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA39842387;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA39842387 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA86593550;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA86593550 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA21793592;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA21793592 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA48905351;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA48905351 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA27889020;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA27889020 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA87489804;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA87489804 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA15969399;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA15969399 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA1082944;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA1082944 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA23584061;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA23584061 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA78512519;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA78512519 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA75265057;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA75265057 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA27855826;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA27855826 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA94298555;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA94298555 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA93265720;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA93265720 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA49371872;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA49371872 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA69041059;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA69041059 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA39628738;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA39628738 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA63711612;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA63711612 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA94614144;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA94614144 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA56543768;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA56543768 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA74093508;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA74093508 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA85815514;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA85815514 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA8980126;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA8980126 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA95664123;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA95664123 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA15279906;     OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA15279906 = OUgZsbOzkYlyvaLCwFdlBIbdLRFHQMtEbEdKULRofA41435949;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void PRcYYnHNejoxbRXyQAXggmhyWjNiHSfCT11449816() {     float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq1032046 = -63990820;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8387654 = -740460487;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8098856 = 7728618;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq51950520 = -932632180;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq49653353 = -916933340;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq61044099 = -633567541;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq15140664 = -644872289;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq69475502 = 43419789;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq82488783 = 11440843;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq47757399 = -884273917;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq323792 = -89816267;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq48611361 = -647064801;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq85626948 = -571120776;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq83689829 = -243756669;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq89355389 = -907457833;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq67721678 = -112662520;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq17313627 = -161801552;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq18444141 = -38315668;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8497630 = -462527573;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq69662863 = 5654729;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq50704938 = -836417184;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq4084163 = -451589270;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq36556724 = -947795887;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq56462561 = -336298754;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq44127231 = -550203431;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq64824440 = -998824658;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq97763979 = -723438608;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq12136341 = -558815409;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq23848642 = -393319571;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq67127918 = -268164248;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq62740019 = 49076272;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq90247054 = -563470320;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq28649769 = -692522726;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq20812999 = -132004033;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq60150617 = -406196329;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq10147862 = -418963634;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq9625562 = 1015211;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq49997486 = -772518710;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq81582681 = -442855537;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8312492 = -634935371;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq3068332 = -325591260;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq480614 = -996158499;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq89880255 = -140274068;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq96810812 = -454976751;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq43815287 = -114953653;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq5053336 = -931448956;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq88408450 = -790997289;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq15150904 = -192327174;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq85331875 = -28250716;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq65647631 = -291981390;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq628183 = -737494359;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq69145796 = -258293038;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq95041482 = -717759131;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq58543699 = -775926976;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq60744877 = -792458769;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq96947882 = -612401550;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq71830930 = -792664600;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq51636295 = -655972628;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq7823290 = -282428749;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq84828913 = -918108683;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq63280119 = -910128933;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq3004324 = 13943120;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq45626860 = -563260640;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq15360865 = -720394909;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq85017380 = -833350190;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq10076737 = -526345948;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq19961592 = -954542075;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq64813949 = -339116743;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq23539212 = -837560341;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq79207528 = -388494199;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq58096116 = -13677732;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq67316141 = -389282842;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq36861459 = -595460132;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq185139 = -827592202;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq66594531 = -668754012;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq50224324 = -840258685;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq14203907 = -211315203;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq39745912 = -392819137;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq12647275 = -121345102;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq39073896 = -618754476;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq76415989 = -107827370;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq82613075 = -431111435;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq26804465 = -430564693;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq58201011 = -1338182;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq66499735 = -530669890;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq93594223 = -692630691;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq95205571 = -845711190;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq70106070 = -916595751;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq60068121 = -339545264;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq63202734 = -793794779;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq38316931 = -626299035;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq57989267 = -343012162;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq42174196 = -390089962;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq96753768 = -524746854;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq45032372 = -724806439;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq64009 = -239534380;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq54853754 = -332897860;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq74519390 = -419879159;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq11793433 = -621626562;    float GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq33738550 = -63990820;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq1032046 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8387654;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8387654 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8098856;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8098856 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq51950520;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq51950520 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq49653353;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq49653353 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq61044099;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq61044099 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq15140664;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq15140664 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq69475502;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq69475502 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq82488783;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq82488783 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq47757399;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq47757399 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq323792;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq323792 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq48611361;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq48611361 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq85626948;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq85626948 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq83689829;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq83689829 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq89355389;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq89355389 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq67721678;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq67721678 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq17313627;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq17313627 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq18444141;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq18444141 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8497630;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8497630 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq69662863;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq69662863 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq50704938;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq50704938 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq4084163;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq4084163 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq36556724;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq36556724 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq56462561;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq56462561 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq44127231;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq44127231 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq64824440;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq64824440 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq97763979;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq97763979 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq12136341;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq12136341 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq23848642;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq23848642 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq67127918;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq67127918 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq62740019;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq62740019 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq90247054;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq90247054 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq28649769;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq28649769 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq20812999;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq20812999 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq60150617;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq60150617 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq10147862;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq10147862 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq9625562;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq9625562 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq49997486;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq49997486 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq81582681;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq81582681 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8312492;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq8312492 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq3068332;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq3068332 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq480614;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq480614 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq89880255;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq89880255 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq96810812;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq96810812 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq43815287;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq43815287 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq5053336;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq5053336 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq88408450;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq88408450 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq15150904;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq15150904 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq85331875;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq85331875 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq65647631;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq65647631 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq628183;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq628183 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq69145796;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq69145796 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq95041482;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq95041482 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq58543699;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq58543699 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq60744877;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq60744877 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq96947882;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq96947882 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq71830930;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq71830930 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq51636295;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq51636295 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq7823290;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq7823290 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq84828913;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq84828913 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq63280119;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq63280119 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq3004324;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq3004324 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq45626860;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq45626860 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq15360865;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq15360865 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq85017380;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq85017380 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq10076737;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq10076737 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq19961592;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq19961592 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq64813949;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq64813949 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq23539212;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq23539212 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq79207528;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq79207528 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq58096116;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq58096116 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq67316141;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq67316141 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq36861459;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq36861459 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq185139;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq185139 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq66594531;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq66594531 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq50224324;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq50224324 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq14203907;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq14203907 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq39745912;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq39745912 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq12647275;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq12647275 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq39073896;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq39073896 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq76415989;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq76415989 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq82613075;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq82613075 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq26804465;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq26804465 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq58201011;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq58201011 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq66499735;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq66499735 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq93594223;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq93594223 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq95205571;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq95205571 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq70106070;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq70106070 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq60068121;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq60068121 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq63202734;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq63202734 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq38316931;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq38316931 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq57989267;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq57989267 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq42174196;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq42174196 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq96753768;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq96753768 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq45032372;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq45032372 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq64009;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq64009 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq54853754;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq54853754 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq74519390;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq74519390 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq11793433;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq11793433 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq33738550;     GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq33738550 = GHhLGltqRDTYQnXiZxJGVicjeBpZZFLEldVJqnKOdq1032046;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void zLUGNzZzJSozolFZubfsythdZLhsgnlVu23995005() {     float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA20500216 = -477122032;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA61411518 = -186338483;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24935848 = -743899996;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA70597669 = -749206443;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50099870 = -443205756;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA86636173 = -524052309;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA59972542 = 11821481;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA34725735 = -50388177;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA43175581 = -716750536;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA25686122 = -889859963;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA54547055 = -522806567;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA52105974 = -646367506;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA75998607 = -995478052;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA92105869 = -786042395;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA49881851 = -105541624;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA33937327 = -575854454;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA23275740 = -333576233;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA42506892 = -889070386;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA8132509 = -839732333;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50274165 = -711881727;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA63161010 = -342629509;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA19066246 = -963392483;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA4729731 = -145370506;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA74184229 = 27157254;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA55330720 = -844503541;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA69591901 = -684619876;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA81692110 = -388589540;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA62928015 = -722548688;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA65593599 = -407230717;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA51834772 = -359602943;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA92544104 = -916249821;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA29826366 = -27819338;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA40125873 = -147730493;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA79569505 = -436607239;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA80954 = -468899135;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA46213798 = -722532242;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA78009012 = -525860864;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA91479959 = -849727526;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA48896007 = -907270362;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA29594227 = -631466468;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA44550389 = -835377555;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA12339747 = -135054725;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA61013497 = -88075866;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA80196351 = -904049412;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA23843698 = -392076616;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA59514462 = -368780377;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA70398331 = -704690612;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA15306735 = -375614488;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA26467467 = -42189955;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA6545974 = -52993735;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA75063752 = -43859290;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA85594656 = -635645897;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA64866629 = -393868092;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA31473727 = -770520612;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA60833994 = -567017404;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA1433971 = -513729549;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA56681788 = 59032023;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50751618 = -671057251;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA15266949 = -904702903;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA80507968 = -758585881;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA4944063 = -35462770;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA97044527 = -265629831;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA69132136 = -643157460;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA91340808 = -257147594;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA33142018 = -973610143;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24720690 = -394987230;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA11980102 = -398637013;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA96429101 = -458870814;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA92024915 = -217143261;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA3668053 = -383009383;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA55928315 = 50006410;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA31795780 = -483848708;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA93610885 = -981800025;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA78538281 = -108265866;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA5723776 = -876504173;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50821263 = -107574785;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA58052749 = -775316618;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24533379 = -241321095;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50340532 = -580766131;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA95816257 = -375723164;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA99193570 = -979929265;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA66385376 = 87024948;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA36460549 = -580358734;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA59047626 = -254236983;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA76771020 = -215743653;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA6949448 = -180603924;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA64959736 = -633951247;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA8652146 = -377209881;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA18735512 = -869589835;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA98646983 = -955169587;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA89532010 = -681564265;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA27257395 = -854803613;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA76213010 = -945024623;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA68388038 = -48684482;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24650165 = -496003699;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA47505862 = -469747725;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA43207611 = -491897266;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA69672689 = -830928272;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA47054333 = -930439269;    float TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA99123007 = -477122032;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA20500216 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA61411518;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA61411518 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24935848;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24935848 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA70597669;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA70597669 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50099870;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50099870 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA86636173;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA86636173 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA59972542;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA59972542 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA34725735;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA34725735 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA43175581;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA43175581 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA25686122;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA25686122 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA54547055;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA54547055 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA52105974;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA52105974 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA75998607;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA75998607 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA92105869;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA92105869 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA49881851;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA49881851 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA33937327;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA33937327 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA23275740;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA23275740 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA42506892;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA42506892 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA8132509;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA8132509 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50274165;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50274165 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA63161010;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA63161010 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA19066246;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA19066246 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA4729731;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA4729731 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA74184229;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA74184229 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA55330720;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA55330720 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA69591901;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA69591901 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA81692110;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA81692110 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA62928015;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA62928015 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA65593599;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA65593599 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA51834772;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA51834772 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA92544104;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA92544104 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA29826366;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA29826366 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA40125873;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA40125873 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA79569505;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA79569505 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA80954;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA80954 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA46213798;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA46213798 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA78009012;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA78009012 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA91479959;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA91479959 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA48896007;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA48896007 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA29594227;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA29594227 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA44550389;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA44550389 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA12339747;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA12339747 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA61013497;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA61013497 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA80196351;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA80196351 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA23843698;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA23843698 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA59514462;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA59514462 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA70398331;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA70398331 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA15306735;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA15306735 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA26467467;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA26467467 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA6545974;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA6545974 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA75063752;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA75063752 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA85594656;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA85594656 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA64866629;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA64866629 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA31473727;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA31473727 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA60833994;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA60833994 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA1433971;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA1433971 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA56681788;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA56681788 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50751618;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50751618 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA15266949;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA15266949 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA80507968;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA80507968 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA4944063;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA4944063 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA97044527;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA97044527 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA69132136;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA69132136 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA91340808;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA91340808 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA33142018;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA33142018 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24720690;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24720690 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA11980102;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA11980102 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA96429101;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA96429101 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA92024915;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA92024915 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA3668053;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA3668053 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA55928315;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA55928315 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA31795780;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA31795780 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA93610885;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA93610885 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA78538281;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA78538281 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA5723776;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA5723776 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50821263;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50821263 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA58052749;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA58052749 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24533379;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24533379 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50340532;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA50340532 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA95816257;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA95816257 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA99193570;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA99193570 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA66385376;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA66385376 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA36460549;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA36460549 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA59047626;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA59047626 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA76771020;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA76771020 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA6949448;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA6949448 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA64959736;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA64959736 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA8652146;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA8652146 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA18735512;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA18735512 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA98646983;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA98646983 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA89532010;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA89532010 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA27257395;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA27257395 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA76213010;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA76213010 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA68388038;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA68388038 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24650165;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA24650165 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA47505862;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA47505862 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA43207611;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA43207611 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA69672689;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA69672689 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA47054333;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA47054333 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA99123007;     TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA99123007 = TcCjwTtsmxphcXKhhovgdrGdrgBShTWhTFUICqyIlA20500216;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void OybSFxEZDasZWnPPGdhfgmSXNoGgOWOjJ84297661() {     float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10626525 = -535878232;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu44536583 = -561264653;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu20428547 = -880694458;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu44096244 = -935378265;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu63156605 = -384529198;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu67422577 = -416685417;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu54635981 = -725723991;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu87604298 = -786835915;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66987268 = -724643174;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu29941793 = -459734488;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu30698875 = 68773275;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu86855481 = -125955641;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14344740 = -207713913;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu30524723 = -784203279;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu47956223 = -590662567;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu58117069 = -276234324;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu67237920 = -594921474;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu63862604 = -231919679;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu69046900 = -206142769;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu17598413 = -259760037;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu51083413 = -47054602;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu17147828 = -196489119;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu37968148 = -551830427;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu82105327 = -420867122;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu2215909 = -388014485;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu88382866 = -560493611;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu3659446 = -148118534;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu86098390 = -782438746;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu26802597 = -69429765;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu99623852 = -234005334;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu96007506 = -142916364;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu29193280 = -528643757;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu49094914 = -447955652;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu3408151 = -428058397;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu35677488 = -119234796;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu99444805 = 74438348;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu78242581 = -41676768;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu15837243 = -715786770;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu59429024 = -614732407;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu74106369 = -536174241;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu58250062 = -541238831;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66984210 = 50452062;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu20830338 = -563501461;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10858292 = -768132601;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu15808116 = -504586572;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu79953456 = -852404283;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu50821621 = -253173111;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu5693194 = -402270741;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu54386121 = -478129301;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu35826379 = -509990072;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu4429276 = -418241335;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu29367763 = -600072730;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14319084 = -105721086;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu84380789 = -894075894;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu33214249 = -695617676;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu93478696 = -239389114;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu6568435 = 90565773;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu38323220 = -359827336;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu41880336 = -447363781;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu74773739 = -824035588;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu63763132 = -168566884;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu68537590 = -943285246;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu60801701 = -617406151;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu67363416 = -390637841;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu33934286 = -216818124;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu1505596 = -402582968;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu37760568 = -677999989;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10936590 = -779655516;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu94847234 = -564968484;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu48511418 = -565100915;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu79874488 = -134557556;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu51400677 = -879134705;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu4433581 = -617187272;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu94940530 = -669968529;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu59348351 = -718521207;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu84099202 = 2493336;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu96317489 = -632987658;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu27109856 = -783697827;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66297211 = -916280550;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu22262452 = -535610202;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu37561245 = -207320500;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu97966252 = -745847793;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu31712270 = -204309445;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu90976217 = -559439693;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu95194576 = -815764000;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66639743 = -542843635;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14874196 = -322922671;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu64714124 = -553879759;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu70193901 = -732440722;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu42198791 = -879845682;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu92876370 = 83872574;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu39919362 = -681849432;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu73956907 = -168422989;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu84655284 = -790696820;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10343237 = -267607358;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu89712472 = -597953586;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu6182509 = -332141788;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu53466922 = -72863621;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu76924006 = -451314477;    float ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14302521 = -535878232;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10626525 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu44536583;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu44536583 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu20428547;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu20428547 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu44096244;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu44096244 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu63156605;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu63156605 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu67422577;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu67422577 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu54635981;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu54635981 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu87604298;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu87604298 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66987268;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66987268 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu29941793;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu29941793 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu30698875;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu30698875 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu86855481;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu86855481 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14344740;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14344740 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu30524723;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu30524723 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu47956223;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu47956223 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu58117069;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu58117069 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu67237920;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu67237920 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu63862604;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu63862604 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu69046900;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu69046900 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu17598413;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu17598413 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu51083413;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu51083413 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu17147828;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu17147828 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu37968148;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu37968148 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu82105327;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu82105327 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu2215909;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu2215909 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu88382866;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu88382866 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu3659446;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu3659446 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu86098390;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu86098390 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu26802597;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu26802597 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu99623852;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu99623852 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu96007506;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu96007506 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu29193280;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu29193280 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu49094914;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu49094914 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu3408151;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu3408151 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu35677488;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu35677488 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu99444805;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu99444805 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu78242581;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu78242581 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu15837243;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu15837243 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu59429024;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu59429024 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu74106369;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu74106369 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu58250062;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu58250062 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66984210;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66984210 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu20830338;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu20830338 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10858292;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10858292 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu15808116;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu15808116 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu79953456;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu79953456 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu50821621;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu50821621 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu5693194;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu5693194 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu54386121;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu54386121 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu35826379;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu35826379 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu4429276;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu4429276 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu29367763;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu29367763 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14319084;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14319084 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu84380789;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu84380789 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu33214249;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu33214249 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu93478696;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu93478696 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu6568435;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu6568435 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu38323220;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu38323220 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu41880336;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu41880336 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu74773739;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu74773739 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu63763132;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu63763132 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu68537590;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu68537590 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu60801701;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu60801701 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu67363416;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu67363416 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu33934286;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu33934286 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu1505596;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu1505596 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu37760568;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu37760568 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10936590;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10936590 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu94847234;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu94847234 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu48511418;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu48511418 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu79874488;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu79874488 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu51400677;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu51400677 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu4433581;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu4433581 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu94940530;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu94940530 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu59348351;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu59348351 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu84099202;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu84099202 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu96317489;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu96317489 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu27109856;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu27109856 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66297211;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66297211 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu22262452;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu22262452 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu37561245;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu37561245 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu97966252;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu97966252 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu31712270;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu31712270 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu90976217;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu90976217 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu95194576;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu95194576 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66639743;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu66639743 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14874196;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14874196 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu64714124;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu64714124 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu70193901;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu70193901 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu42198791;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu42198791 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu92876370;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu92876370 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu39919362;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu39919362 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu73956907;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu73956907 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu84655284;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu84655284 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10343237;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10343237 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu89712472;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu89712472 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu6182509;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu6182509 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu53466922;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu53466922 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu76924006;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu76924006 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14302521;     ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu14302521 = ckjTovAkUDDGYWgadJrCQkbgEFQrXKhMJPtDgvSigu10626525;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void XZMtogapnbJVchgYTNoBNBpXndtIUODMu32723353() {     long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE99564483 = -19009621;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE15941232 = -542371864;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78774227 = -469669534;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE85120576 = -338391583;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE61839612 = -969985200;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE9905368 = -272796751;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE2162904 = -861202334;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE50801252 = -498407518;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE17675822 = -877614415;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE86639360 = -836704862;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE34065251 = -257339307;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE90271789 = -740691460;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE37124830 = -226013847;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE58895748 = -132486468;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE7716118 = -96151937;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE96907230 = -844419279;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE65198956 = -433567195;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE31237974 = 90838791;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE88209591 = -256056724;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10802576 = -991826836;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE56078201 = -781862659;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE2537928 = -267597574;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE65094561 = -207240203;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE56636137 = -273724975;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42512214 = -594941240;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE68774269 = -505032565;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78960312 = -503220469;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78830859 = -407663557;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE57122899 = -210734478;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE75015093 = -498024879;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE47262507 = -326795241;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE12170937 = 90613647;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE684015 = -682885132;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE20850455 = -243094377;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE44948651 = -179811926;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE60869632 = -237757433;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE37024141 = -245515573;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE31322772 = -871388731;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE35227275 = 9608296;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE23701618 = -901878513;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE44250259 = -713825447;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE94278060 = -378892370;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE73025980 = -869322493;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE37821395 = -677036811;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE4860425 = -115517648;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78768718 = -49055958;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE57876933 = -510239601;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE62158958 = -891655031;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE6992706 = -340066813;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE62611708 = -135258541;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE99985571 = -236332445;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE8628670 = -984242011;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10107290 = -309925506;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE77678279 = 74716796;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE76645152 = -305510126;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE97026555 = -751412047;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE50846670 = -235131661;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE22138090 = -95944560;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42608362 = -743450344;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE93065342 = -364952635;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE30945056 = -769576282;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE23332045 = -353538778;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE93678353 = -187673040;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42660729 = -279589536;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE39376853 = -409909622;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE21894314 = -247952954;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE89587774 = 42193672;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE16274375 = -982919471;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE13947098 = -952674542;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE46846486 = -858394505;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE59883090 = -498903706;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE33876185 = -562178464;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE96010699 = -918769506;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE64507973 = -354178212;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE66552316 = -178001389;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE61800140 = -302970290;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE29511947 = -398275082;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE27273167 = -530203392;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE51775713 = -58207328;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE63743496 = -445885283;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10897337 = -994792964;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE16801354 = -611565439;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE71838153 = 32403255;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE94511190 = 24524062;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE75029521 = -161692435;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE38633838 = -342553230;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE2063647 = -599460848;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE23005736 = -657601929;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE44205303 = -937584251;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE47922095 = -428399880;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10022963 = 97374228;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE14886051 = -49571014;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE88714409 = -27938388;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42161932 = -625439069;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE92756562 = -32302231;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE20918215 = -260286670;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE599708 = -91219330;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE30365252 = -489732957;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE98444541 = -167127190;    long liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE82966110 = -19009621;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE99564483 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE15941232;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE15941232 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78774227;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78774227 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE85120576;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE85120576 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE61839612;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE61839612 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE9905368;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE9905368 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE2162904;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE2162904 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE50801252;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE50801252 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE17675822;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE17675822 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE86639360;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE86639360 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE34065251;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE34065251 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE90271789;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE90271789 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE37124830;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE37124830 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE58895748;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE58895748 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE7716118;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE7716118 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE96907230;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE96907230 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE65198956;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE65198956 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE31237974;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE31237974 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE88209591;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE88209591 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10802576;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10802576 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE56078201;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE56078201 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE2537928;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE2537928 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE65094561;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE65094561 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE56636137;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE56636137 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42512214;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42512214 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE68774269;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE68774269 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78960312;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78960312 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78830859;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78830859 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE57122899;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE57122899 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE75015093;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE75015093 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE47262507;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE47262507 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE12170937;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE12170937 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE684015;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE684015 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE20850455;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE20850455 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE44948651;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE44948651 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE60869632;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE60869632 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE37024141;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE37024141 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE31322772;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE31322772 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE35227275;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE35227275 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE23701618;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE23701618 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE44250259;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE44250259 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE94278060;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE94278060 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE73025980;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE73025980 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE37821395;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE37821395 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE4860425;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE4860425 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78768718;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE78768718 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE57876933;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE57876933 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE62158958;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE62158958 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE6992706;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE6992706 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE62611708;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE62611708 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE99985571;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE99985571 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE8628670;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE8628670 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10107290;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10107290 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE77678279;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE77678279 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE76645152;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE76645152 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE97026555;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE97026555 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE50846670;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE50846670 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE22138090;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE22138090 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42608362;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42608362 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE93065342;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE93065342 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE30945056;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE30945056 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE23332045;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE23332045 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE93678353;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE93678353 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42660729;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42660729 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE39376853;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE39376853 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE21894314;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE21894314 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE89587774;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE89587774 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE16274375;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE16274375 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE13947098;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE13947098 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE46846486;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE46846486 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE59883090;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE59883090 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE33876185;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE33876185 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE96010699;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE96010699 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE64507973;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE64507973 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE66552316;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE66552316 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE61800140;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE61800140 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE29511947;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE29511947 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE27273167;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE27273167 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE51775713;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE51775713 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE63743496;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE63743496 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10897337;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10897337 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE16801354;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE16801354 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE71838153;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE71838153 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE94511190;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE94511190 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE75029521;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE75029521 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE38633838;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE38633838 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE2063647;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE2063647 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE23005736;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE23005736 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE44205303;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE44205303 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE47922095;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE47922095 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10022963;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE10022963 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE14886051;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE14886051 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE88714409;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE88714409 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42161932;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE42161932 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE92756562;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE92756562 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE20918215;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE20918215 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE599708;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE599708 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE30365252;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE30365252 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE98444541;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE98444541 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE82966110;     liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE82966110 = liaHiQgwOsfvvlsizEsskVWkoFLnSVZXwbqyFQlwIE99564483;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void KGvaFnkSJYXSKgbjEtlRpazTRDkAZSwaS93026010() {     long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89690791 = -77765822;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr99066296 = -917298034;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr74266926 = -606463995;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr58619151 = -524563405;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr74896347 = -911308641;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr90691772 = -165429859;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr96826341 = -498747807;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr3679816 = -134855257;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr41487509 = -885507052;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr90895030 = -406579388;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr10217070 = -765759464;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr25021297 = -220279595;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr75470962 = -538249708;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr97314601 = -130647352;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr5790490 = -581272880;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr21086973 = -544799149;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr9161137 = -694912436;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr52593687 = -352010502;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr49123982 = -722467160;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr78126824 = -539705146;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr44000603 = -486287752;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr619510 = -600694210;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98332979 = -613700124;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr64557234 = -721749350;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89397402 = -138452184;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr87565234 = -380906300;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr927647 = -262749463;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr2001235 = -467553615;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr18331897 = -972933526;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr22804173 = -372427271;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr50725910 = -653461785;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr11537851 = -410210773;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr9653056 = -983110292;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr44689100 = -234545535;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr80545185 = -930147587;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr14100639 = -540786843;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr37257709 = -861331478;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr55680055 = -737447975;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr45760292 = -797853749;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr68213759 = -806586286;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr57949933 = -419686723;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr48922524 = -193385583;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr32842822 = -244748088;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr68483336 = -541120000;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr96824842 = -228027604;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr99207711 = -532679863;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr38300223 = -58722101;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr52545417 = -918311284;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr34911360 = -776006159;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr91892113 = -592254878;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr29351095 = -610714490;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr52401776 = -948668844;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr59559745 = -21778501;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr30585341 = -48838485;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr49025408 = -434110398;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89071282 = -477071613;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr733317 = -203597910;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr9709692 = -884714645;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr69221749 = -286111222;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr87331113 = -430402342;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89764125 = -902680396;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr94825107 = 68805808;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr85347919 = -161921731;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr18683336 = -413079782;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr40169121 = -753117603;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98679219 = -255548692;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr15368241 = -237169304;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr30781863 = -203704173;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr16769417 = -200499766;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr91689850 = 59513962;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr83829263 = -683467672;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr53481082 = -957464462;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr6833396 = -554156753;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr80910222 = -915880874;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr20176892 = -20018424;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr95078079 = -192902170;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr67776688 = -255946122;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr29849644 = 27419875;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr67732392 = -393721747;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr90189690 = -605772322;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr49265011 = -222184199;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr48382230 = -344438179;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr67089874 = -691547456;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr26439783 = -280678648;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr93453077 = -761712781;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98324133 = -704792941;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr51978106 = -288432272;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr79067714 = -834271807;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr95663692 = -800435137;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr91473903 = -353075975;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr13367322 = -237188933;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr27548018 = -976616833;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr86458306 = -351336754;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr58429178 = -267451408;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr78449634 = -903905890;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr63124825 = -388492531;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr63574605 = 68536148;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr14159486 = -831668306;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr28314216 = -788002397;    long qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98145622 = -77765822;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89690791 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr99066296;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr99066296 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr74266926;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr74266926 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr58619151;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr58619151 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr74896347;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr74896347 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr90691772;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr90691772 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr96826341;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr96826341 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr3679816;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr3679816 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr41487509;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr41487509 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr90895030;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr90895030 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr10217070;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr10217070 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr25021297;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr25021297 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr75470962;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr75470962 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr97314601;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr97314601 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr5790490;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr5790490 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr21086973;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr21086973 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr9161137;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr9161137 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr52593687;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr52593687 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr49123982;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr49123982 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr78126824;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr78126824 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr44000603;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr44000603 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr619510;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr619510 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98332979;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98332979 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr64557234;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr64557234 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89397402;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89397402 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr87565234;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr87565234 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr927647;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr927647 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr2001235;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr2001235 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr18331897;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr18331897 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr22804173;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr22804173 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr50725910;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr50725910 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr11537851;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr11537851 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr9653056;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr9653056 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr44689100;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr44689100 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr80545185;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr80545185 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr14100639;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr14100639 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr37257709;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr37257709 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr55680055;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr55680055 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr45760292;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr45760292 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr68213759;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr68213759 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr57949933;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr57949933 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr48922524;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr48922524 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr32842822;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr32842822 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr68483336;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr68483336 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr96824842;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr96824842 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr99207711;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr99207711 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr38300223;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr38300223 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr52545417;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr52545417 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr34911360;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr34911360 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr91892113;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr91892113 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr29351095;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr29351095 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr52401776;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr52401776 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr59559745;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr59559745 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr30585341;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr30585341 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr49025408;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr49025408 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89071282;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89071282 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr733317;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr733317 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr9709692;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr9709692 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr69221749;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr69221749 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr87331113;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr87331113 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89764125;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89764125 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr94825107;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr94825107 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr85347919;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr85347919 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr18683336;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr18683336 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr40169121;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr40169121 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98679219;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98679219 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr15368241;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr15368241 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr30781863;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr30781863 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr16769417;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr16769417 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr91689850;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr91689850 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr83829263;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr83829263 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr53481082;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr53481082 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr6833396;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr6833396 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr80910222;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr80910222 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr20176892;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr20176892 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr95078079;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr95078079 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr67776688;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr67776688 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr29849644;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr29849644 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr67732392;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr67732392 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr90189690;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr90189690 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr49265011;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr49265011 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr48382230;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr48382230 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr67089874;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr67089874 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr26439783;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr26439783 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr93453077;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr93453077 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98324133;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98324133 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr51978106;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr51978106 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr79067714;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr79067714 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr95663692;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr95663692 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr91473903;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr91473903 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr13367322;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr13367322 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr27548018;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr27548018 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr86458306;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr86458306 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr58429178;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr58429178 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr78449634;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr78449634 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr63124825;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr63124825 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr63574605;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr63574605 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr14159486;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr14159486 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr28314216;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr28314216 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98145622;     qyQqctZxmJusUHoHyQXCHSjHbJCCjsr98145622 = qyQqctZxmJusUHoHyQXCHSjHbJCCjsr89690791;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void HiMZVOIWnZdPjPtiiEtGmr5571200() {     long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi9158962 = -490897034;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi52090160 = -363176030;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi91103918 = -258092610;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi77266300 = -341137668;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi75342864 = -437581057;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi16283847 = -55914627;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi41658220 = -942054037;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi68930049 = -228663223;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi2174307 = -513698431;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi68823754 = -412165434;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi64440333 = -98749764;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi28515910 = -219582300;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi65842621 = -962606984;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi5730642 = -672933078;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi66316951 = -879356671;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi87302621 = 92008917;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi15123251 = -866687117;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76656438 = -102765220;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi48758861 = 328080;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi58738126 = -157241602;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi56456675 = 7499923;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi15601593 = -12497423;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi66505985 = -911274743;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi82278903 = -358293342;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi600892 = -432752294;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi92332695 = -66701519;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi84855778 = 72099606;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi52792909 = -631286894;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi60076853 = -986844672;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi7511027 = -463865965;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi80529995 = -518787878;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi51117161 = -974559791;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi21129159 = -438318058;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3445607 = -539148741;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi20475522 = -992850393;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi50166576 = -844355451;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi5641160 = -288207552;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi97162529 = -814656790;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi13073617 = -162268574;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi89495495 = -803117382;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi99431989 = -929473019;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi60781657 = -432281809;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3976063 = -192549886;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi51868875 = -990192661;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76853253 = -505150567;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi53668839 = 29988716;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi20290103 = 27584576;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi52701247 = -1598598;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76046950 = -789945398;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi32790456 = -353267223;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3786665 = 82920579;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi68850636 = -226021704;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi29384891 = -797887462;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3515370 = -43432122;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi49114524 = -208669033;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi93557369 = -378399611;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi85584174 = -451901288;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi8825016 = -899799268;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76665408 = -908385375;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi83010168 = -270879539;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi31428069 = -28014233;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi88865311 = -210767143;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi8853196 = -241818551;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi94663279 = 50167533;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi88293758 = -893377556;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi13323172 = -124189974;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi7386751 = -781264242;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi62397015 = -323458244;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi85255120 = -680082686;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi16150375 = 64998779;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi81661461 = -619783531;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi17960721 = 47969672;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi63582822 = -940496646;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi59263366 = -196554539;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi59306136 = -227768584;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi95675018 = -560218269;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi11625530 = -819947538;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi14637111 = -921082082;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi5425650 = -853142776;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi46932052 = -362741010;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi72042592 = 5713905;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi32154531 = -926301797;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76745958 = -841341497;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi27286397 = -533577449;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3724363 = -446786545;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi11679359 = -192766175;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi21732270 = -76672329;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi17613790 = -294885937;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi54331082 = -230479709;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi26918152 = -514450782;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi64582401 = -292454164;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi96816144 = -388408285;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi20497121 = -906271415;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi30063449 = -891389036;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi58067427 = -675103150;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi10566679 = -618705876;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi51928462 = -90463258;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi9312784 = -142717419;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi63575116 = 3184895;    long nXmPebYqlclQVoeIQwZYMZWrlqjJWwi63530081 = -490897034;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi9158962 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi52090160;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi52090160 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi91103918;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi91103918 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi77266300;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi77266300 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi75342864;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi75342864 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi16283847;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi16283847 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi41658220;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi41658220 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi68930049;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi68930049 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi2174307;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi2174307 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi68823754;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi68823754 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi64440333;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi64440333 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi28515910;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi28515910 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi65842621;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi65842621 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi5730642;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi5730642 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi66316951;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi66316951 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi87302621;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi87302621 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi15123251;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi15123251 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76656438;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76656438 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi48758861;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi48758861 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi58738126;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi58738126 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi56456675;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi56456675 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi15601593;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi15601593 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi66505985;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi66505985 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi82278903;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi82278903 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi600892;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi600892 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi92332695;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi92332695 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi84855778;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi84855778 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi52792909;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi52792909 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi60076853;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi60076853 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi7511027;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi7511027 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi80529995;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi80529995 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi51117161;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi51117161 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi21129159;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi21129159 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3445607;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3445607 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi20475522;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi20475522 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi50166576;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi50166576 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi5641160;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi5641160 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi97162529;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi97162529 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi13073617;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi13073617 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi89495495;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi89495495 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi99431989;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi99431989 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi60781657;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi60781657 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3976063;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3976063 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi51868875;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi51868875 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76853253;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76853253 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi53668839;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi53668839 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi20290103;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi20290103 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi52701247;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi52701247 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76046950;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76046950 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi32790456;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi32790456 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3786665;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3786665 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi68850636;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi68850636 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi29384891;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi29384891 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3515370;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3515370 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi49114524;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi49114524 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi93557369;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi93557369 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi85584174;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi85584174 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi8825016;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi8825016 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76665408;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76665408 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi83010168;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi83010168 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi31428069;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi31428069 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi88865311;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi88865311 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi8853196;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi8853196 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi94663279;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi94663279 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi88293758;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi88293758 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi13323172;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi13323172 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi7386751;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi7386751 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi62397015;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi62397015 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi85255120;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi85255120 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi16150375;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi16150375 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi81661461;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi81661461 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi17960721;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi17960721 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi63582822;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi63582822 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi59263366;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi59263366 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi59306136;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi59306136 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi95675018;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi95675018 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi11625530;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi11625530 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi14637111;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi14637111 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi5425650;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi5425650 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi46932052;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi46932052 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi72042592;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi72042592 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi32154531;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi32154531 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76745958;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi76745958 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi27286397;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi27286397 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3724363;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi3724363 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi11679359;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi11679359 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi21732270;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi21732270 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi17613790;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi17613790 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi54331082;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi54331082 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi26918152;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi26918152 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi64582401;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi64582401 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi96816144;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi96816144 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi20497121;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi20497121 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi30063449;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi30063449 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi58067427;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi58067427 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi10566679;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi10566679 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi51928462;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi51928462 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi9312784;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi9312784 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi63575116;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi63575116 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi63530081;     nXmPebYqlclQVoeIQwZYMZWrlqjJWwi63530081 = nXmPebYqlclQVoeIQwZYMZWrlqjJWwi9158962;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void VXgcRlKypIhYAPZYnPcIXN65873857() {     long TviZHYElGDWAvaCzNcuYpYlmBvMfccw99285270 = -549653235;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw35215225 = -738102200;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw86596617 = -394887071;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw50764875 = -527309490;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw88399599 = -378904499;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw97070251 = 51452265;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw36321659 = -579599510;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw21808612 = -965110961;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw25985994 = -521591069;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw73079424 = 17960041;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw40592152 = -607169922;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw63265418 = -799170435;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw4188754 = -174842845;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw44149496 = -671093963;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw64391323 = -264477614;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw11482364 = -708370953;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw59085431 = -28032359;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw98012150 = -545614512;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw9673253 = -466082356;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw26062374 = -805119912;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw44379078 = -796925170;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw13683175 = -345594058;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw99744403 = -217734664;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw90200000 = -806317718;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw47486079 = 23736762;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw11123661 = 57424747;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw6823113 = -787429388;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw75963284 = -691176953;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw21285851 = -649043720;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw55300107 = -338268356;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw83993398 = -845454422;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw50484075 = -375384211;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw30098200 = -738543218;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw27284252 = -530599899;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw56072056 = -643186054;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw3397583 = -47384861;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw5874729 = -904023457;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw21519813 = -680716034;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw23606634 = -969730620;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw34007637 = -707825155;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw13131663 = -635334294;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw15426121 = -246775022;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw63792904 = -667975481;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw82530815 = -854275850;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw68817670 = -617660523;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw74107832 = -453635190;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw713394 = -620897924;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw43087706 = -28254851;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw3965605 = -125884744;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw62070862 = -810263561;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw33152188 = -291461466;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw12623744 = -190448537;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw78837346 = -509740457;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw56422432 = -166987403;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw21494780 = -337269304;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw85602096 = -104059177;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw35470821 = -420367537;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw96396616 = -588569354;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw3278796 = -451046253;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw77275938 = -336329246;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw90247138 = -161118347;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw60358374 = -888422558;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw522761 = -216067242;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw70685887 = -83322713;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw89086026 = -136585538;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw90108077 = -131785712;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw33167218 = 39372782;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw76904502 = -644242946;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw88077440 = 72092091;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw60993740 = -117092753;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw5607635 = -804347496;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw37565618 = -347316325;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw74405517 = -575883892;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw75665615 = -758257201;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw12930711 = -69785618;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw28952958 = -450150148;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw49890271 = -677618578;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw17213588 = -363458815;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw21382330 = -88657196;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw73378246 = -522628048;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw10410268 = -321677330;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw63735407 = -659174537;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw71997679 = -465292209;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw59214989 = -838780160;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw22147919 = 53193109;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw71369654 = -555005886;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw71646729 = -865643754;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw73675768 = -471555815;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw5789472 = -93330595;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw70469959 = -439126878;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw67926761 = -627017325;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw9478112 = -215454103;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw18241017 = -129669781;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw46330695 = -533401374;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw43760499 = -446706809;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw52773289 = -746911737;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw14903360 = 69292219;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw93107017 = -484652768;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw93444789 = -617690312;    long TviZHYElGDWAvaCzNcuYpYlmBvMfccw78709593 = -549653235;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw99285270 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw35215225;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw35215225 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw86596617;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw86596617 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw50764875;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw50764875 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw88399599;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw88399599 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw97070251;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw97070251 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw36321659;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw36321659 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw21808612;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw21808612 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw25985994;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw25985994 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw73079424;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw73079424 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw40592152;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw40592152 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw63265418;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw63265418 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw4188754;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw4188754 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw44149496;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw44149496 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw64391323;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw64391323 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw11482364;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw11482364 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw59085431;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw59085431 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw98012150;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw98012150 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw9673253;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw9673253 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw26062374;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw26062374 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw44379078;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw44379078 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw13683175;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw13683175 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw99744403;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw99744403 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw90200000;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw90200000 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw47486079;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw47486079 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw11123661;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw11123661 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw6823113;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw6823113 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw75963284;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw75963284 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw21285851;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw21285851 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw55300107;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw55300107 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw83993398;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw83993398 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw50484075;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw50484075 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw30098200;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw30098200 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw27284252;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw27284252 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw56072056;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw56072056 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw3397583;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw3397583 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw5874729;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw5874729 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw21519813;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw21519813 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw23606634;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw23606634 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw34007637;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw34007637 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw13131663;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw13131663 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw15426121;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw15426121 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw63792904;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw63792904 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw82530815;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw82530815 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw68817670;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw68817670 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw74107832;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw74107832 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw713394;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw713394 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw43087706;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw43087706 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw3965605;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw3965605 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw62070862;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw62070862 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw33152188;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw33152188 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw12623744;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw12623744 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw78837346;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw78837346 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw56422432;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw56422432 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw21494780;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw21494780 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw85602096;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw85602096 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw35470821;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw35470821 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw96396616;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw96396616 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw3278796;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw3278796 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw77275938;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw77275938 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw90247138;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw90247138 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw60358374;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw60358374 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw522761;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw522761 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw70685887;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw70685887 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw89086026;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw89086026 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw90108077;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw90108077 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw33167218;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw33167218 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw76904502;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw76904502 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw88077440;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw88077440 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw60993740;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw60993740 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw5607635;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw5607635 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw37565618;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw37565618 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw74405517;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw74405517 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw75665615;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw75665615 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw12930711;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw12930711 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw28952958;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw28952958 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw49890271;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw49890271 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw17213588;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw17213588 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw21382330;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw21382330 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw73378246;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw73378246 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw10410268;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw10410268 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw63735407;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw63735407 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw71997679;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw71997679 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw59214989;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw59214989 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw22147919;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw22147919 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw71369654;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw71369654 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw71646729;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw71646729 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw73675768;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw73675768 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw5789472;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw5789472 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw70469959;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw70469959 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw67926761;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw67926761 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw9478112;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw9478112 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw18241017;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw18241017 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw46330695;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw46330695 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw43760499;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw43760499 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw52773289;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw52773289 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw14903360;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw14903360 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw93107017;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw93107017 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw93444789;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw93444789 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw78709593;     TviZHYElGDWAvaCzNcuYpYlmBvMfccw78709593 = TviZHYElGDWAvaCzNcuYpYlmBvMfccw99285270;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void fQJkjACOOrWOHJQTESTyPb78419046() {     long jsJGoPyHvPed18753441 = -962784446;    long jsJGoPyHvPed88239088 = -183980197;    long jsJGoPyHvPed3433610 = -46515686;    long jsJGoPyHvPed69412023 = -343883753;    long jsJGoPyHvPed88846115 = 94823085;    long jsJGoPyHvPed22662326 = -939032503;    long jsJGoPyHvPed81153537 = 77094261;    long jsJGoPyHvPed87058845 = 41081073;    long jsJGoPyHvPed86672791 = -149782448;    long jsJGoPyHvPed51008147 = 12373995;    long jsJGoPyHvPed94815415 = 59839778;    long jsJGoPyHvPed66760031 = -798473140;    long jsJGoPyHvPed94560413 = -599200121;    long jsJGoPyHvPed52565536 = -113379688;    long jsJGoPyHvPed24917784 = -562561405;    long jsJGoPyHvPed77698012 = -71562887;    long jsJGoPyHvPed65047544 = -199807040;    long jsJGoPyHvPed22074902 = -296369230;    long jsJGoPyHvPed9308132 = -843287117;    long jsJGoPyHvPed6673676 = -422656368;    long jsJGoPyHvPed56835150 = -303137495;    long jsJGoPyHvPed28665258 = -857397271;    long jsJGoPyHvPed67917410 = -515309282;    long jsJGoPyHvPed7921669 = -442861710;    long jsJGoPyHvPed58689568 = -270563347;    long jsJGoPyHvPed15891122 = -728370472;    long jsJGoPyHvPed90751243 = -452580320;    long jsJGoPyHvPed26754959 = -854910232;    long jsJGoPyHvPed63030808 = -662954866;    long jsJGoPyHvPed40006961 = -429707051;    long jsJGoPyHvPed13797483 = -710780515;    long jsJGoPyHvPed90063385 = -939733229;    long jsJGoPyHvPed41574304 = -193750985;    long jsJGoPyHvPed86040758 = -835203105;    long jsJGoPyHvPed96002391 = -705888860;    long jsJGoPyHvPed39463520 = -350953470;    long jsJGoPyHvPed74258179 = -330899532;    long jsJGoPyHvPed63002287 = -757924850;    long jsJGoPyHvPed90919958 = -334145445;    long jsJGoPyHvPed55289373 = -704356252;    long jsJGoPyHvPed54613720 = -45120590;    long jsJGoPyHvPed27285254 = -485671248;    long jsJGoPyHvPed34926145 = -615777279;    long jsJGoPyHvPed65916354 = -203348510;    long jsJGoPyHvPed48846082 = -894783486;    long jsJGoPyHvPed28568960 = -990966611;    long jsJGoPyHvPed82703273 = -534591247;    long jsJGoPyHvPed43243536 = -211542166;    long jsJGoPyHvPed45101196 = -139823983;    long jsJGoPyHvPed2969205 = -571275906;    long jsJGoPyHvPed7587757 = -697826397;    long jsJGoPyHvPed29072604 = -567801396;    long jsJGoPyHvPed48662492 = -185849418;    long jsJGoPyHvPed29352461 = -161581040;    long jsJGoPyHvPed21583896 = -111827939;    long jsJGoPyHvPed90088183 = -5387176;    long jsJGoPyHvPed20321679 = -668670915;    long jsJGoPyHvPed95511940 = -603653977;    long jsJGoPyHvPed10722456 = 26679593;    long jsJGoPyHvPed72954993 = -176806444;    long jsJGoPyHvPed31911082 = -386452184;    long jsJGoPyHvPed54398578 = -67995508;    long jsJGoPyHvPed24028038 = -295964062;    long jsJGoPyHvPed46665830 = -720075398;    long jsJGoPyHvPed37210664 = -276845491;    long jsJGoPyHvPed4752031 = -426994;    long jsJGoPyHvPed25185728 = -504722156;    long jsJGoPyHvPed8519655 = -763997016;    long jsJGoPyHvPed56563144 = -407490829;    long jsJGoPyHvPed85454264 = -111607936;    long jsJGoPyHvPed3439833 = -740663355;    long jsJGoPyHvPed2045258 = -441882191;    long jsJGoPyHvPed31154944 = -962223785;    long jsJGoPyHvPed54018758 = -38930865;    long jsJGoPyHvPed52059956 = -277535779;    long jsJGoPyHvPed29549897 = -817466248;    long jsJGoPyHvPed93739112 = -141619993;    long jsJGoPyHvPed2001056 = -211960772;    long jsJGoPyHvPed59075587 = -548078224;    long jsJGoPyHvPed30120609 = -279596737;    long jsJGoPyHvPed33187849 = -93779225;    long jsJGoPyHvPed47507708 = -141038155;    long jsJGoPyHvPed81653763 = -615086249;    long jsJGoPyHvPed60061604 = 8321039;    long jsJGoPyHvPed32419204 = -731880654;    long jsJGoPyHvPed84724879 = -42979119;    long jsJGoPyHvPed41400893 = -653883811;    long jsJGoPyHvPed12221843 = 67830055;    long jsJGoPyHvPed64456862 = -623375166;    long jsJGoPyHvPed5914209 = -600501685;    long jsJGoPyHvPed19141841 = -682282555;    long jsJGoPyHvPed78746239 = -727245555;    long jsJGoPyHvPed52279832 = -684604443;    long jsJGoPyHvPed17964965 = -57339002;    long jsJGoPyHvPed23378292 = -217904069;    long jsJGoPyHvPed215143 = -977125082;    long jsJGoPyHvPed3257216 = -89707186;    long jsJGoPyHvPed88260315 = -895701881;    long jsJGoPyHvPed28705691 = -926503020;    long jsJGoPyHvPed44094052 = -962784446;     jsJGoPyHvPed18753441 = jsJGoPyHvPed88239088;     jsJGoPyHvPed88239088 = jsJGoPyHvPed3433610;     jsJGoPyHvPed3433610 = jsJGoPyHvPed69412023;     jsJGoPyHvPed69412023 = jsJGoPyHvPed88846115;     jsJGoPyHvPed88846115 = jsJGoPyHvPed22662326;     jsJGoPyHvPed22662326 = jsJGoPyHvPed81153537;     jsJGoPyHvPed81153537 = jsJGoPyHvPed87058845;     jsJGoPyHvPed87058845 = jsJGoPyHvPed86672791;     jsJGoPyHvPed86672791 = jsJGoPyHvPed51008147;     jsJGoPyHvPed51008147 = jsJGoPyHvPed94815415;     jsJGoPyHvPed94815415 = jsJGoPyHvPed66760031;     jsJGoPyHvPed66760031 = jsJGoPyHvPed94560413;     jsJGoPyHvPed94560413 = jsJGoPyHvPed52565536;     jsJGoPyHvPed52565536 = jsJGoPyHvPed24917784;     jsJGoPyHvPed24917784 = jsJGoPyHvPed77698012;     jsJGoPyHvPed77698012 = jsJGoPyHvPed65047544;     jsJGoPyHvPed65047544 = jsJGoPyHvPed22074902;     jsJGoPyHvPed22074902 = jsJGoPyHvPed9308132;     jsJGoPyHvPed9308132 = jsJGoPyHvPed6673676;     jsJGoPyHvPed6673676 = jsJGoPyHvPed56835150;     jsJGoPyHvPed56835150 = jsJGoPyHvPed28665258;     jsJGoPyHvPed28665258 = jsJGoPyHvPed67917410;     jsJGoPyHvPed67917410 = jsJGoPyHvPed7921669;     jsJGoPyHvPed7921669 = jsJGoPyHvPed58689568;     jsJGoPyHvPed58689568 = jsJGoPyHvPed15891122;     jsJGoPyHvPed15891122 = jsJGoPyHvPed90751243;     jsJGoPyHvPed90751243 = jsJGoPyHvPed26754959;     jsJGoPyHvPed26754959 = jsJGoPyHvPed63030808;     jsJGoPyHvPed63030808 = jsJGoPyHvPed40006961;     jsJGoPyHvPed40006961 = jsJGoPyHvPed13797483;     jsJGoPyHvPed13797483 = jsJGoPyHvPed90063385;     jsJGoPyHvPed90063385 = jsJGoPyHvPed41574304;     jsJGoPyHvPed41574304 = jsJGoPyHvPed86040758;     jsJGoPyHvPed86040758 = jsJGoPyHvPed96002391;     jsJGoPyHvPed96002391 = jsJGoPyHvPed39463520;     jsJGoPyHvPed39463520 = jsJGoPyHvPed74258179;     jsJGoPyHvPed74258179 = jsJGoPyHvPed63002287;     jsJGoPyHvPed63002287 = jsJGoPyHvPed90919958;     jsJGoPyHvPed90919958 = jsJGoPyHvPed55289373;     jsJGoPyHvPed55289373 = jsJGoPyHvPed54613720;     jsJGoPyHvPed54613720 = jsJGoPyHvPed27285254;     jsJGoPyHvPed27285254 = jsJGoPyHvPed34926145;     jsJGoPyHvPed34926145 = jsJGoPyHvPed65916354;     jsJGoPyHvPed65916354 = jsJGoPyHvPed48846082;     jsJGoPyHvPed48846082 = jsJGoPyHvPed28568960;     jsJGoPyHvPed28568960 = jsJGoPyHvPed82703273;     jsJGoPyHvPed82703273 = jsJGoPyHvPed43243536;     jsJGoPyHvPed43243536 = jsJGoPyHvPed45101196;     jsJGoPyHvPed45101196 = jsJGoPyHvPed2969205;     jsJGoPyHvPed2969205 = jsJGoPyHvPed7587757;     jsJGoPyHvPed7587757 = jsJGoPyHvPed29072604;     jsJGoPyHvPed29072604 = jsJGoPyHvPed48662492;     jsJGoPyHvPed48662492 = jsJGoPyHvPed29352461;     jsJGoPyHvPed29352461 = jsJGoPyHvPed21583896;     jsJGoPyHvPed21583896 = jsJGoPyHvPed90088183;     jsJGoPyHvPed90088183 = jsJGoPyHvPed20321679;     jsJGoPyHvPed20321679 = jsJGoPyHvPed95511940;     jsJGoPyHvPed95511940 = jsJGoPyHvPed10722456;     jsJGoPyHvPed10722456 = jsJGoPyHvPed72954993;     jsJGoPyHvPed72954993 = jsJGoPyHvPed31911082;     jsJGoPyHvPed31911082 = jsJGoPyHvPed54398578;     jsJGoPyHvPed54398578 = jsJGoPyHvPed24028038;     jsJGoPyHvPed24028038 = jsJGoPyHvPed46665830;     jsJGoPyHvPed46665830 = jsJGoPyHvPed37210664;     jsJGoPyHvPed37210664 = jsJGoPyHvPed4752031;     jsJGoPyHvPed4752031 = jsJGoPyHvPed25185728;     jsJGoPyHvPed25185728 = jsJGoPyHvPed8519655;     jsJGoPyHvPed8519655 = jsJGoPyHvPed56563144;     jsJGoPyHvPed56563144 = jsJGoPyHvPed85454264;     jsJGoPyHvPed85454264 = jsJGoPyHvPed3439833;     jsJGoPyHvPed3439833 = jsJGoPyHvPed2045258;     jsJGoPyHvPed2045258 = jsJGoPyHvPed31154944;     jsJGoPyHvPed31154944 = jsJGoPyHvPed54018758;     jsJGoPyHvPed54018758 = jsJGoPyHvPed52059956;     jsJGoPyHvPed52059956 = jsJGoPyHvPed29549897;     jsJGoPyHvPed29549897 = jsJGoPyHvPed93739112;     jsJGoPyHvPed93739112 = jsJGoPyHvPed2001056;     jsJGoPyHvPed2001056 = jsJGoPyHvPed59075587;     jsJGoPyHvPed59075587 = jsJGoPyHvPed30120609;     jsJGoPyHvPed30120609 = jsJGoPyHvPed33187849;     jsJGoPyHvPed33187849 = jsJGoPyHvPed47507708;     jsJGoPyHvPed47507708 = jsJGoPyHvPed81653763;     jsJGoPyHvPed81653763 = jsJGoPyHvPed60061604;     jsJGoPyHvPed60061604 = jsJGoPyHvPed32419204;     jsJGoPyHvPed32419204 = jsJGoPyHvPed84724879;     jsJGoPyHvPed84724879 = jsJGoPyHvPed41400893;     jsJGoPyHvPed41400893 = jsJGoPyHvPed12221843;     jsJGoPyHvPed12221843 = jsJGoPyHvPed64456862;     jsJGoPyHvPed64456862 = jsJGoPyHvPed5914209;     jsJGoPyHvPed5914209 = jsJGoPyHvPed19141841;     jsJGoPyHvPed19141841 = jsJGoPyHvPed78746239;     jsJGoPyHvPed78746239 = jsJGoPyHvPed52279832;     jsJGoPyHvPed52279832 = jsJGoPyHvPed17964965;     jsJGoPyHvPed17964965 = jsJGoPyHvPed23378292;     jsJGoPyHvPed23378292 = jsJGoPyHvPed215143;     jsJGoPyHvPed215143 = jsJGoPyHvPed3257216;     jsJGoPyHvPed3257216 = jsJGoPyHvPed88260315;     jsJGoPyHvPed88260315 = jsJGoPyHvPed28705691;     jsJGoPyHvPed28705691 = jsJGoPyHvPed44094052;     jsJGoPyHvPed44094052 = jsJGoPyHvPed18753441;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void MMeEHBhAaneEpk74602206() {     long GhRCYJqplBwb78349537 = -91540824;    long GhRCYJqplBwb89744938 = 5864418;    long GhRCYJqplBwb40434997 = -120656609;    long GhRCYJqplBwb65287782 = -116494631;    long GhRCYJqplBwb139342 = -905683942;    long GhRCYJqplBwb20339446 = -797292176;    long GhRCYJqplBwb78512019 = -352623325;    long GhRCYJqplBwb37884129 = -313130303;    long GhRCYJqplBwb486235 = -682454947;    long GhRCYJqplBwb34032662 = 71115142;    long GhRCYJqplBwb20110347 = -341702661;    long GhRCYJqplBwb1431233 = -893494389;    long GhRCYJqplBwb65314976 = -505378640;    long GhRCYJqplBwb10939375 = -17538036;    long GhRCYJqplBwb22225590 = -255087927;    long GhRCYJqplBwb74452266 = -976935778;    long GhRCYJqplBwb1008648 = -128023321;    long GhRCYJqplBwb86743233 = -665705335;    long GhRCYJqplBwb89750334 = -982406747;    long GhRCYJqplBwb86590785 = 14934979;    long GhRCYJqplBwb37296268 = -136158320;    long GhRCYJqplBwb97154856 = -749799149;    long GhRCYJqplBwb60109235 = -279604361;    long GhRCYJqplBwb72651908 = -7199946;    long GhRCYJqplBwb34667573 = -826700937;    long GhRCYJqplBwb10306029 = -862987943;    long GhRCYJqplBwb4091315 = -902060317;    long GhRCYJqplBwb91866127 = -376291822;    long GhRCYJqplBwb12815151 = -452547481;    long GhRCYJqplBwb78480427 = -476690293;    long GhRCYJqplBwb38711801 = -255999842;    long GhRCYJqplBwb32828646 = -256951226;    long GhRCYJqplBwb90656342 = -173697857;    long GhRCYJqplBwb68565201 = -337087037;    long GhRCYJqplBwb939753 = -354098846;    long GhRCYJqplBwb18053417 = -662610052;    long GhRCYJqplBwb64889857 = -623678166;    long GhRCYJqplBwb61362624 = -702377239;    long GhRCYJqplBwb9937902 = -52851962;    long GhRCYJqplBwb28115028 = -978237200;    long GhRCYJqplBwb12831534 = -513782186;    long GhRCYJqplBwb97364434 = -490612666;    long GhRCYJqplBwb75805387 = -349222108;    long GhRCYJqplBwb40155860 = -627263249;    long GhRCYJqplBwb49834397 = -341101554;    long GhRCYJqplBwb93362088 = -133910770;    long GhRCYJqplBwb88191995 = -426446914;    long GhRCYJqplBwb89939930 = -544295394;    long GhRCYJqplBwb84490843 = -423761603;    long GhRCYJqplBwb18136597 = -892528367;    long GhRCYJqplBwb58074007 = -483934621;    long GhRCYJqplBwb35657757 = -539044651;    long GhRCYJqplBwb24078007 = -425797872;    long GhRCYJqplBwb2626984 = -421749995;    long GhRCYJqplBwb37305938 = -75762027;    long GhRCYJqplBwb81194681 = -341741675;    long GhRCYJqplBwb29635704 = -714531221;    long GhRCYJqplBwb67783089 = -13456663;    long GhRCYJqplBwb30620209 = -289793694;    long GhRCYJqplBwb89833312 = 57304000;    long GhRCYJqplBwb16248132 = -895231860;    long GhRCYJqplBwb86645892 = -976331504;    long GhRCYJqplBwb25068979 = -860582822;    long GhRCYJqplBwb22005807 = -105764655;    long GhRCYJqplBwb95320860 = -672885016;    long GhRCYJqplBwb87281701 = 15248564;    long GhRCYJqplBwb10774891 = -619796533;    long GhRCYJqplBwb96749775 = -68291604;    long GhRCYJqplBwb9999622 = -663439190;    long GhRCYJqplBwb4172174 = -592477876;    long GhRCYJqplBwb9562410 = -253257612;    long GhRCYJqplBwb39646023 = -425646082;    long GhRCYJqplBwb76805332 = -512853373;    long GhRCYJqplBwb61635307 = 95830453;    long GhRCYJqplBwb73759251 = -471282835;    long GhRCYJqplBwb39931834 = -645545654;    long GhRCYJqplBwb21349469 = -300577041;    long GhRCYJqplBwb19953376 = -652341113;    long GhRCYJqplBwb22817511 = -666098392;    long GhRCYJqplBwb41305485 = -592790168;    long GhRCYJqplBwb22114034 = -336541029;    long GhRCYJqplBwb14151385 = -257764923;    long GhRCYJqplBwb7375285 = -952530220;    long GhRCYJqplBwb94678554 = -560019115;    long GhRCYJqplBwb20406421 = -992755673;    long GhRCYJqplBwb3054045 = -716955192;    long GhRCYJqplBwb8750640 = -831153355;    long GhRCYJqplBwb88029358 = -751947863;    long GhRCYJqplBwb31259263 = -161325010;    long GhRCYJqplBwb19745072 = 87642829;    long GhRCYJqplBwb88417713 = -948078831;    long GhRCYJqplBwb97106767 = -510221504;    long GhRCYJqplBwb30742416 = -312583545;    long GhRCYJqplBwb20104589 = -10155962;    long GhRCYJqplBwb11866896 = 16994659;    long GhRCYJqplBwb26185642 = -537450683;    long GhRCYJqplBwb72295456 = -630029845;    long GhRCYJqplBwb53799580 = -143457454;    long GhRCYJqplBwb44834999 = -954378233;    long GhRCYJqplBwb62552696 = -91540824;     GhRCYJqplBwb78349537 = GhRCYJqplBwb89744938;     GhRCYJqplBwb89744938 = GhRCYJqplBwb40434997;     GhRCYJqplBwb40434997 = GhRCYJqplBwb65287782;     GhRCYJqplBwb65287782 = GhRCYJqplBwb139342;     GhRCYJqplBwb139342 = GhRCYJqplBwb20339446;     GhRCYJqplBwb20339446 = GhRCYJqplBwb78512019;     GhRCYJqplBwb78512019 = GhRCYJqplBwb37884129;     GhRCYJqplBwb37884129 = GhRCYJqplBwb486235;     GhRCYJqplBwb486235 = GhRCYJqplBwb34032662;     GhRCYJqplBwb34032662 = GhRCYJqplBwb20110347;     GhRCYJqplBwb20110347 = GhRCYJqplBwb1431233;     GhRCYJqplBwb1431233 = GhRCYJqplBwb65314976;     GhRCYJqplBwb65314976 = GhRCYJqplBwb10939375;     GhRCYJqplBwb10939375 = GhRCYJqplBwb22225590;     GhRCYJqplBwb22225590 = GhRCYJqplBwb74452266;     GhRCYJqplBwb74452266 = GhRCYJqplBwb1008648;     GhRCYJqplBwb1008648 = GhRCYJqplBwb86743233;     GhRCYJqplBwb86743233 = GhRCYJqplBwb89750334;     GhRCYJqplBwb89750334 = GhRCYJqplBwb86590785;     GhRCYJqplBwb86590785 = GhRCYJqplBwb37296268;     GhRCYJqplBwb37296268 = GhRCYJqplBwb97154856;     GhRCYJqplBwb97154856 = GhRCYJqplBwb60109235;     GhRCYJqplBwb60109235 = GhRCYJqplBwb72651908;     GhRCYJqplBwb72651908 = GhRCYJqplBwb34667573;     GhRCYJqplBwb34667573 = GhRCYJqplBwb10306029;     GhRCYJqplBwb10306029 = GhRCYJqplBwb4091315;     GhRCYJqplBwb4091315 = GhRCYJqplBwb91866127;     GhRCYJqplBwb91866127 = GhRCYJqplBwb12815151;     GhRCYJqplBwb12815151 = GhRCYJqplBwb78480427;     GhRCYJqplBwb78480427 = GhRCYJqplBwb38711801;     GhRCYJqplBwb38711801 = GhRCYJqplBwb32828646;     GhRCYJqplBwb32828646 = GhRCYJqplBwb90656342;     GhRCYJqplBwb90656342 = GhRCYJqplBwb68565201;     GhRCYJqplBwb68565201 = GhRCYJqplBwb939753;     GhRCYJqplBwb939753 = GhRCYJqplBwb18053417;     GhRCYJqplBwb18053417 = GhRCYJqplBwb64889857;     GhRCYJqplBwb64889857 = GhRCYJqplBwb61362624;     GhRCYJqplBwb61362624 = GhRCYJqplBwb9937902;     GhRCYJqplBwb9937902 = GhRCYJqplBwb28115028;     GhRCYJqplBwb28115028 = GhRCYJqplBwb12831534;     GhRCYJqplBwb12831534 = GhRCYJqplBwb97364434;     GhRCYJqplBwb97364434 = GhRCYJqplBwb75805387;     GhRCYJqplBwb75805387 = GhRCYJqplBwb40155860;     GhRCYJqplBwb40155860 = GhRCYJqplBwb49834397;     GhRCYJqplBwb49834397 = GhRCYJqplBwb93362088;     GhRCYJqplBwb93362088 = GhRCYJqplBwb88191995;     GhRCYJqplBwb88191995 = GhRCYJqplBwb89939930;     GhRCYJqplBwb89939930 = GhRCYJqplBwb84490843;     GhRCYJqplBwb84490843 = GhRCYJqplBwb18136597;     GhRCYJqplBwb18136597 = GhRCYJqplBwb58074007;     GhRCYJqplBwb58074007 = GhRCYJqplBwb35657757;     GhRCYJqplBwb35657757 = GhRCYJqplBwb24078007;     GhRCYJqplBwb24078007 = GhRCYJqplBwb2626984;     GhRCYJqplBwb2626984 = GhRCYJqplBwb37305938;     GhRCYJqplBwb37305938 = GhRCYJqplBwb81194681;     GhRCYJqplBwb81194681 = GhRCYJqplBwb29635704;     GhRCYJqplBwb29635704 = GhRCYJqplBwb67783089;     GhRCYJqplBwb67783089 = GhRCYJqplBwb30620209;     GhRCYJqplBwb30620209 = GhRCYJqplBwb89833312;     GhRCYJqplBwb89833312 = GhRCYJqplBwb16248132;     GhRCYJqplBwb16248132 = GhRCYJqplBwb86645892;     GhRCYJqplBwb86645892 = GhRCYJqplBwb25068979;     GhRCYJqplBwb25068979 = GhRCYJqplBwb22005807;     GhRCYJqplBwb22005807 = GhRCYJqplBwb95320860;     GhRCYJqplBwb95320860 = GhRCYJqplBwb87281701;     GhRCYJqplBwb87281701 = GhRCYJqplBwb10774891;     GhRCYJqplBwb10774891 = GhRCYJqplBwb96749775;     GhRCYJqplBwb96749775 = GhRCYJqplBwb9999622;     GhRCYJqplBwb9999622 = GhRCYJqplBwb4172174;     GhRCYJqplBwb4172174 = GhRCYJqplBwb9562410;     GhRCYJqplBwb9562410 = GhRCYJqplBwb39646023;     GhRCYJqplBwb39646023 = GhRCYJqplBwb76805332;     GhRCYJqplBwb76805332 = GhRCYJqplBwb61635307;     GhRCYJqplBwb61635307 = GhRCYJqplBwb73759251;     GhRCYJqplBwb73759251 = GhRCYJqplBwb39931834;     GhRCYJqplBwb39931834 = GhRCYJqplBwb21349469;     GhRCYJqplBwb21349469 = GhRCYJqplBwb19953376;     GhRCYJqplBwb19953376 = GhRCYJqplBwb22817511;     GhRCYJqplBwb22817511 = GhRCYJqplBwb41305485;     GhRCYJqplBwb41305485 = GhRCYJqplBwb22114034;     GhRCYJqplBwb22114034 = GhRCYJqplBwb14151385;     GhRCYJqplBwb14151385 = GhRCYJqplBwb7375285;     GhRCYJqplBwb7375285 = GhRCYJqplBwb94678554;     GhRCYJqplBwb94678554 = GhRCYJqplBwb20406421;     GhRCYJqplBwb20406421 = GhRCYJqplBwb3054045;     GhRCYJqplBwb3054045 = GhRCYJqplBwb8750640;     GhRCYJqplBwb8750640 = GhRCYJqplBwb88029358;     GhRCYJqplBwb88029358 = GhRCYJqplBwb31259263;     GhRCYJqplBwb31259263 = GhRCYJqplBwb19745072;     GhRCYJqplBwb19745072 = GhRCYJqplBwb88417713;     GhRCYJqplBwb88417713 = GhRCYJqplBwb97106767;     GhRCYJqplBwb97106767 = GhRCYJqplBwb30742416;     GhRCYJqplBwb30742416 = GhRCYJqplBwb20104589;     GhRCYJqplBwb20104589 = GhRCYJqplBwb11866896;     GhRCYJqplBwb11866896 = GhRCYJqplBwb26185642;     GhRCYJqplBwb26185642 = GhRCYJqplBwb72295456;     GhRCYJqplBwb72295456 = GhRCYJqplBwb53799580;     GhRCYJqplBwb53799580 = GhRCYJqplBwb44834999;     GhRCYJqplBwb44834999 = GhRCYJqplBwb62552696;     GhRCYJqplBwb62552696 = GhRCYJqplBwb78349537;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void fziXATRBybOoWg34904864() {     long FJqANxwdoGah68475846 = -150297025;    long FJqANxwdoGah72870003 = -369061752;    long FJqANxwdoGah35927696 = -257451070;    long FJqANxwdoGah38786357 = -302666453;    long FJqANxwdoGah13196078 = -847007384;    long FJqANxwdoGah1125851 = -689925284;    long FJqANxwdoGah73175458 = 9831202;    long FJqANxwdoGah90762692 = 50421959;    long FJqANxwdoGah24297922 = -690347585;    long FJqANxwdoGah38288333 = -598759384;    long FJqANxwdoGah96262166 = -850122819;    long FJqANxwdoGah36180741 = -373082524;    long FJqANxwdoGah3661109 = -817614500;    long FJqANxwdoGah49358228 = -15698920;    long FJqANxwdoGah20299962 = -740208869;    long FJqANxwdoGah98632008 = -677315648;    long FJqANxwdoGah44970828 = -389368562;    long FJqANxwdoGah8098946 = -8554627;    long FJqANxwdoGah50664726 = -348817183;    long FJqANxwdoGah53915033 = -632943331;    long FJqANxwdoGah25218671 = -940583412;    long FJqANxwdoGah95236438 = 17104215;    long FJqANxwdoGah93347652 = -686064282;    long FJqANxwdoGah80573005 = -455224322;    long FJqANxwdoGah81552761 = -370211881;    long FJqANxwdoGah29096994 = -738861677;    long FJqANxwdoGah26058649 = -661589311;    long FJqANxwdoGah15036503 = -436181880;    long FJqANxwdoGah74024148 = -114746529;    long FJqANxwdoGah26269508 = -351092684;    long FJqANxwdoGah42175204 = -582666386;    long FJqANxwdoGah32195560 = -757775646;    long FJqANxwdoGah99625383 = -473923017;    long FJqANxwdoGah92403845 = -328538195;    long FJqANxwdoGah36536287 = -4434506;    long FJqANxwdoGah71284423 = -965639462;    long FJqANxwdoGah65123426 = -139494071;    long FJqANxwdoGah85719907 = -568436483;    long FJqANxwdoGah20470919 = -860314007;    long FJqANxwdoGah72627169 = -882944973;    long FJqANxwdoGah26531207 = -219643462;    long FJqANxwdoGah52008897 = -305105879;    long FJqANxwdoGah35622229 = -824647704;    long FJqANxwdoGah70817800 = -491346438;    long FJqANxwdoGah41798815 = -453611510;    long FJqANxwdoGah13801083 = -617534675;    long FJqANxwdoGah68615286 = 25070586;    long FJqANxwdoGah80326389 = -570951647;    long FJqANxwdoGah12409498 = -859700949;    long FJqANxwdoGah47417002 = -249524704;    long FJqANxwdoGah87439530 = -858316666;    long FJqANxwdoGah79430864 = -503471484;    long FJqANxwdoGah73530462 = -137650866;    long FJqANxwdoGah55534046 = -545305277;    long FJqANxwdoGah9686193 = -204362298;    long FJqANxwdoGah73239408 = -67401241;    long FJqANxwdoGah79522350 = -682997470;    long FJqANxwdoGah55354691 = -802226748;    long FJqANxwdoGah57233595 = -932454572;    long FJqANxwdoGah84099083 = -8145707;    long FJqANxwdoGah75067201 = 71664026;    long FJqANxwdoGah58138955 = -553986919;    long FJqANxwdoGah16738544 = -834831513;    long FJqANxwdoGah98028414 = -239254901;    long FJqANxwdoGah96113128 = 83907002;    long FJqANxwdoGah64066606 = 7652826;    long FJqANxwdoGah36555357 = -899159508;    long FJqANxwdoGah11257264 = -389076306;    long FJqANxwdoGah12821941 = 88735586;    long FJqANxwdoGah49015538 = -774569408;    long FJqANxwdoGah33508583 = -437821578;    long FJqANxwdoGah59250920 = -820932079;    long FJqANxwdoGah87628027 = -148240620;    long FJqANxwdoGah78037556 = -465872210;    long FJqANxwdoGah27383827 = -313299869;    long FJqANxwdoGah73209773 = -535477533;    long FJqANxwdoGah59614210 = -158248081;    long FJqANxwdoGah22529853 = -94717845;    long FJqANxwdoGah38774191 = 98387188;    long FJqANxwdoGah67751679 = -752677206;    long FJqANxwdoGah60481708 = -663932264;    long FJqANxwdoGah45732260 = 9362336;    long FJqANxwdoGah2627006 = -576480931;    long FJqANxwdoGah26607147 = -865221826;    long FJqANxwdoGah38829977 = -492776019;    long FJqANxwdoGah62744340 = 20805097;    long FJqANxwdoGah58665098 = -520124780;    long FJqANxwdoGah44091338 = -928617741;    long FJqANxwdoGah82717652 = -24175897;    long FJqANxwdoGah63296879 = -937033266;    long FJqANxwdoGah91762072 = -182641992;    long FJqANxwdoGah9768736 = -337267323;    long FJqANxwdoGah28486312 = -635981911;    long FJqANxwdoGah36371835 = -752168301;    long FJqANxwdoGah97559968 = -854609000;    long FJqANxwdoGah68392252 = -665656544;    long FJqANxwdoGah35270354 = -470274367;    long FJqANxwdoGah37593814 = -485392803;    long FJqANxwdoGah74704672 = -475253440;    long FJqANxwdoGah77732208 = -150297025;     FJqANxwdoGah68475846 = FJqANxwdoGah72870003;     FJqANxwdoGah72870003 = FJqANxwdoGah35927696;     FJqANxwdoGah35927696 = FJqANxwdoGah38786357;     FJqANxwdoGah38786357 = FJqANxwdoGah13196078;     FJqANxwdoGah13196078 = FJqANxwdoGah1125851;     FJqANxwdoGah1125851 = FJqANxwdoGah73175458;     FJqANxwdoGah73175458 = FJqANxwdoGah90762692;     FJqANxwdoGah90762692 = FJqANxwdoGah24297922;     FJqANxwdoGah24297922 = FJqANxwdoGah38288333;     FJqANxwdoGah38288333 = FJqANxwdoGah96262166;     FJqANxwdoGah96262166 = FJqANxwdoGah36180741;     FJqANxwdoGah36180741 = FJqANxwdoGah3661109;     FJqANxwdoGah3661109 = FJqANxwdoGah49358228;     FJqANxwdoGah49358228 = FJqANxwdoGah20299962;     FJqANxwdoGah20299962 = FJqANxwdoGah98632008;     FJqANxwdoGah98632008 = FJqANxwdoGah44970828;     FJqANxwdoGah44970828 = FJqANxwdoGah8098946;     FJqANxwdoGah8098946 = FJqANxwdoGah50664726;     FJqANxwdoGah50664726 = FJqANxwdoGah53915033;     FJqANxwdoGah53915033 = FJqANxwdoGah25218671;     FJqANxwdoGah25218671 = FJqANxwdoGah95236438;     FJqANxwdoGah95236438 = FJqANxwdoGah93347652;     FJqANxwdoGah93347652 = FJqANxwdoGah80573005;     FJqANxwdoGah80573005 = FJqANxwdoGah81552761;     FJqANxwdoGah81552761 = FJqANxwdoGah29096994;     FJqANxwdoGah29096994 = FJqANxwdoGah26058649;     FJqANxwdoGah26058649 = FJqANxwdoGah15036503;     FJqANxwdoGah15036503 = FJqANxwdoGah74024148;     FJqANxwdoGah74024148 = FJqANxwdoGah26269508;     FJqANxwdoGah26269508 = FJqANxwdoGah42175204;     FJqANxwdoGah42175204 = FJqANxwdoGah32195560;     FJqANxwdoGah32195560 = FJqANxwdoGah99625383;     FJqANxwdoGah99625383 = FJqANxwdoGah92403845;     FJqANxwdoGah92403845 = FJqANxwdoGah36536287;     FJqANxwdoGah36536287 = FJqANxwdoGah71284423;     FJqANxwdoGah71284423 = FJqANxwdoGah65123426;     FJqANxwdoGah65123426 = FJqANxwdoGah85719907;     FJqANxwdoGah85719907 = FJqANxwdoGah20470919;     FJqANxwdoGah20470919 = FJqANxwdoGah72627169;     FJqANxwdoGah72627169 = FJqANxwdoGah26531207;     FJqANxwdoGah26531207 = FJqANxwdoGah52008897;     FJqANxwdoGah52008897 = FJqANxwdoGah35622229;     FJqANxwdoGah35622229 = FJqANxwdoGah70817800;     FJqANxwdoGah70817800 = FJqANxwdoGah41798815;     FJqANxwdoGah41798815 = FJqANxwdoGah13801083;     FJqANxwdoGah13801083 = FJqANxwdoGah68615286;     FJqANxwdoGah68615286 = FJqANxwdoGah80326389;     FJqANxwdoGah80326389 = FJqANxwdoGah12409498;     FJqANxwdoGah12409498 = FJqANxwdoGah47417002;     FJqANxwdoGah47417002 = FJqANxwdoGah87439530;     FJqANxwdoGah87439530 = FJqANxwdoGah79430864;     FJqANxwdoGah79430864 = FJqANxwdoGah73530462;     FJqANxwdoGah73530462 = FJqANxwdoGah55534046;     FJqANxwdoGah55534046 = FJqANxwdoGah9686193;     FJqANxwdoGah9686193 = FJqANxwdoGah73239408;     FJqANxwdoGah73239408 = FJqANxwdoGah79522350;     FJqANxwdoGah79522350 = FJqANxwdoGah55354691;     FJqANxwdoGah55354691 = FJqANxwdoGah57233595;     FJqANxwdoGah57233595 = FJqANxwdoGah84099083;     FJqANxwdoGah84099083 = FJqANxwdoGah75067201;     FJqANxwdoGah75067201 = FJqANxwdoGah58138955;     FJqANxwdoGah58138955 = FJqANxwdoGah16738544;     FJqANxwdoGah16738544 = FJqANxwdoGah98028414;     FJqANxwdoGah98028414 = FJqANxwdoGah96113128;     FJqANxwdoGah96113128 = FJqANxwdoGah64066606;     FJqANxwdoGah64066606 = FJqANxwdoGah36555357;     FJqANxwdoGah36555357 = FJqANxwdoGah11257264;     FJqANxwdoGah11257264 = FJqANxwdoGah12821941;     FJqANxwdoGah12821941 = FJqANxwdoGah49015538;     FJqANxwdoGah49015538 = FJqANxwdoGah33508583;     FJqANxwdoGah33508583 = FJqANxwdoGah59250920;     FJqANxwdoGah59250920 = FJqANxwdoGah87628027;     FJqANxwdoGah87628027 = FJqANxwdoGah78037556;     FJqANxwdoGah78037556 = FJqANxwdoGah27383827;     FJqANxwdoGah27383827 = FJqANxwdoGah73209773;     FJqANxwdoGah73209773 = FJqANxwdoGah59614210;     FJqANxwdoGah59614210 = FJqANxwdoGah22529853;     FJqANxwdoGah22529853 = FJqANxwdoGah38774191;     FJqANxwdoGah38774191 = FJqANxwdoGah67751679;     FJqANxwdoGah67751679 = FJqANxwdoGah60481708;     FJqANxwdoGah60481708 = FJqANxwdoGah45732260;     FJqANxwdoGah45732260 = FJqANxwdoGah2627006;     FJqANxwdoGah2627006 = FJqANxwdoGah26607147;     FJqANxwdoGah26607147 = FJqANxwdoGah38829977;     FJqANxwdoGah38829977 = FJqANxwdoGah62744340;     FJqANxwdoGah62744340 = FJqANxwdoGah58665098;     FJqANxwdoGah58665098 = FJqANxwdoGah44091338;     FJqANxwdoGah44091338 = FJqANxwdoGah82717652;     FJqANxwdoGah82717652 = FJqANxwdoGah63296879;     FJqANxwdoGah63296879 = FJqANxwdoGah91762072;     FJqANxwdoGah91762072 = FJqANxwdoGah9768736;     FJqANxwdoGah9768736 = FJqANxwdoGah28486312;     FJqANxwdoGah28486312 = FJqANxwdoGah36371835;     FJqANxwdoGah36371835 = FJqANxwdoGah97559968;     FJqANxwdoGah97559968 = FJqANxwdoGah68392252;     FJqANxwdoGah68392252 = FJqANxwdoGah35270354;     FJqANxwdoGah35270354 = FJqANxwdoGah37593814;     FJqANxwdoGah37593814 = FJqANxwdoGah74704672;     FJqANxwdoGah74704672 = FJqANxwdoGah77732208;     FJqANxwdoGah77732208 = FJqANxwdoGah68475846;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void KfijLMAWDMhoZD47450052() {     long EpFphZjTpmny87944016 = -563428237;    long EpFphZjTpmny25893867 = -914939748;    long EpFphZjTpmny52764688 = 90920315;    long EpFphZjTpmny57433505 = -119240716;    long EpFphZjTpmny13642594 = -373279800;    long EpFphZjTpmny26717925 = -580410053;    long EpFphZjTpmny18007337 = -433475028;    long EpFphZjTpmny56012926 = -43386007;    long EpFphZjTpmny84984719 = -318538964;    long EpFphZjTpmny16217056 = -604345430;    long EpFphZjTpmny50485430 = -183113119;    long EpFphZjTpmny39675354 = -372385229;    long EpFphZjTpmny94032768 = -141971777;    long EpFphZjTpmny57774268 = -557984646;    long EpFphZjTpmny80826422 = 61707339;    long EpFphZjTpmny64847658 = -40507582;    long EpFphZjTpmny50932941 = -561143243;    long EpFphZjTpmny32161697 = -859309345;    long EpFphZjTpmny50299605 = -726021943;    long EpFphZjTpmny34526335 = -250479787;    long EpFphZjTpmny37674743 = -446795738;    long EpFphZjTpmny10218522 = -494698998;    long EpFphZjTpmny61520659 = -983638901;    long EpFphZjTpmny98294673 = -91768314;    long EpFphZjTpmny92756250 = -664511990;    long EpFphZjTpmny33864455 = -424656896;    long EpFphZjTpmny9986781 = -326740242;    long EpFphZjTpmny65828178 = -599915159;    long EpFphZjTpmny15769106 = -128657675;    long EpFphZjTpmny10976362 = -442531379;    long EpFphZjTpmny71979289 = -447992479;    long EpFphZjTpmny71774870 = -222124664;    long EpFphZjTpmny11101487 = 70869217;    long EpFphZjTpmny51160352 = -633141401;    long EpFphZjTpmny76466623 = -67137312;    long EpFphZjTpmny7350361 = -169208070;    long EpFphZjTpmny33506877 = -666370146;    long EpFphZjTpmny27202382 = -645645299;    long EpFphZjTpmny87784243 = -224728833;    long EpFphZjTpmny93908905 = -879476070;    long EpFphZjTpmny68013264 = -729429757;    long EpFphZjTpmny63868030 = -544002105;    long EpFphZjTpmny6755470 = -772449501;    long EpFphZjTpmny54203339 = -940419099;    long EpFphZjTpmny21827226 = -730734473;    long EpFphZjTpmny68262209 = -54866096;    long EpFphZjTpmny50605166 = -988622737;    long EpFphZjTpmny80482219 = -754238962;    long EpFphZjTpmny53545088 = -873640188;    long EpFphZjTpmny88315344 = -10537049;    long EpFphZjTpmny61875100 = -164681597;    long EpFphZjTpmny95879724 = -880824344;    long EpFphZjTpmny43355608 = -913759827;    long EpFphZjTpmny28464075 = -539898913;    long EpFphZjTpmny9775310 = 21079067;    long EpFphZjTpmny77725495 = 31270761;    long EpFphZjTpmny64373208 = -931300848;    long EpFphZjTpmny54470014 = -817311372;    long EpFphZjTpmny64677255 = -454728726;    long EpFphZjTpmny79778138 = -948622905;    long EpFphZjTpmny16731145 = -153669811;    long EpFphZjTpmny52179158 = -833559870;    long EpFphZjTpmny40243820 = -914728333;    long EpFphZjTpmny74008358 = -876007586;    long EpFphZjTpmny44237766 = -56352951;    long EpFphZjTpmny78710559 = -960988456;    long EpFphZjTpmny28573867 = -343254446;    long EpFphZjTpmny42872416 = -508830376;    long EpFphZjTpmny81307645 = -390847334;    long EpFphZjTpmny73476062 = -769084591;    long EpFphZjTpmny31340781 = -374137437;    long EpFphZjTpmny23730560 = -915497945;    long EpFphZjTpmny44377454 = -534580513;    long EpFphZjTpmny56390700 = -846545874;    long EpFphZjTpmny66513071 = -521050030;    long EpFphZjTpmny73806712 = -902793633;    long EpFphZjTpmny3463052 = -722249497;    long EpFphZjTpmny7317320 = 56780198;    long EpFphZjTpmny76467448 = -361033841;    long EpFphZjTpmny24494041 = -509645895;    long EpFphZjTpmny83259289 = -436034160;    long EpFphZjTpmny29504561 = -572501281;    long EpFphZjTpmny12283090 = -726274972;    long EpFphZjTpmny27453761 = -18120627;    long EpFphZjTpmny49101262 = -177849782;    long EpFphZjTpmny76099565 = -567168136;    long EpFphZjTpmny28419263 = -308364837;    long EpFphZjTpmny82637412 = -389231871;    long EpFphZjTpmny41385043 = -554220468;    long EpFphZjTpmny98741128 = 1591927;    long EpFphZjTpmny42977152 = -237907223;    long EpFphZjTpmny79036862 = -849058774;    long EpFphZjTpmny62525127 = -90916573;    long EpFphZjTpmny8006105 = -276105928;    long EpFphZjTpmny77177761 = -625806260;    long EpFphZjTpmny15834106 = -895869888;    long EpFphZjTpmny23624210 = -629273773;    long EpFphZjTpmny32747112 = -896441916;    long EpFphZjTpmny9965573 = -784066148;    long EpFphZjTpmny43116666 = -563428237;     EpFphZjTpmny87944016 = EpFphZjTpmny25893867;     EpFphZjTpmny25893867 = EpFphZjTpmny52764688;     EpFphZjTpmny52764688 = EpFphZjTpmny57433505;     EpFphZjTpmny57433505 = EpFphZjTpmny13642594;     EpFphZjTpmny13642594 = EpFphZjTpmny26717925;     EpFphZjTpmny26717925 = EpFphZjTpmny18007337;     EpFphZjTpmny18007337 = EpFphZjTpmny56012926;     EpFphZjTpmny56012926 = EpFphZjTpmny84984719;     EpFphZjTpmny84984719 = EpFphZjTpmny16217056;     EpFphZjTpmny16217056 = EpFphZjTpmny50485430;     EpFphZjTpmny50485430 = EpFphZjTpmny39675354;     EpFphZjTpmny39675354 = EpFphZjTpmny94032768;     EpFphZjTpmny94032768 = EpFphZjTpmny57774268;     EpFphZjTpmny57774268 = EpFphZjTpmny80826422;     EpFphZjTpmny80826422 = EpFphZjTpmny64847658;     EpFphZjTpmny64847658 = EpFphZjTpmny50932941;     EpFphZjTpmny50932941 = EpFphZjTpmny32161697;     EpFphZjTpmny32161697 = EpFphZjTpmny50299605;     EpFphZjTpmny50299605 = EpFphZjTpmny34526335;     EpFphZjTpmny34526335 = EpFphZjTpmny37674743;     EpFphZjTpmny37674743 = EpFphZjTpmny10218522;     EpFphZjTpmny10218522 = EpFphZjTpmny61520659;     EpFphZjTpmny61520659 = EpFphZjTpmny98294673;     EpFphZjTpmny98294673 = EpFphZjTpmny92756250;     EpFphZjTpmny92756250 = EpFphZjTpmny33864455;     EpFphZjTpmny33864455 = EpFphZjTpmny9986781;     EpFphZjTpmny9986781 = EpFphZjTpmny65828178;     EpFphZjTpmny65828178 = EpFphZjTpmny15769106;     EpFphZjTpmny15769106 = EpFphZjTpmny10976362;     EpFphZjTpmny10976362 = EpFphZjTpmny71979289;     EpFphZjTpmny71979289 = EpFphZjTpmny71774870;     EpFphZjTpmny71774870 = EpFphZjTpmny11101487;     EpFphZjTpmny11101487 = EpFphZjTpmny51160352;     EpFphZjTpmny51160352 = EpFphZjTpmny76466623;     EpFphZjTpmny76466623 = EpFphZjTpmny7350361;     EpFphZjTpmny7350361 = EpFphZjTpmny33506877;     EpFphZjTpmny33506877 = EpFphZjTpmny27202382;     EpFphZjTpmny27202382 = EpFphZjTpmny87784243;     EpFphZjTpmny87784243 = EpFphZjTpmny93908905;     EpFphZjTpmny93908905 = EpFphZjTpmny68013264;     EpFphZjTpmny68013264 = EpFphZjTpmny63868030;     EpFphZjTpmny63868030 = EpFphZjTpmny6755470;     EpFphZjTpmny6755470 = EpFphZjTpmny54203339;     EpFphZjTpmny54203339 = EpFphZjTpmny21827226;     EpFphZjTpmny21827226 = EpFphZjTpmny68262209;     EpFphZjTpmny68262209 = EpFphZjTpmny50605166;     EpFphZjTpmny50605166 = EpFphZjTpmny80482219;     EpFphZjTpmny80482219 = EpFphZjTpmny53545088;     EpFphZjTpmny53545088 = EpFphZjTpmny88315344;     EpFphZjTpmny88315344 = EpFphZjTpmny61875100;     EpFphZjTpmny61875100 = EpFphZjTpmny95879724;     EpFphZjTpmny95879724 = EpFphZjTpmny43355608;     EpFphZjTpmny43355608 = EpFphZjTpmny28464075;     EpFphZjTpmny28464075 = EpFphZjTpmny9775310;     EpFphZjTpmny9775310 = EpFphZjTpmny77725495;     EpFphZjTpmny77725495 = EpFphZjTpmny64373208;     EpFphZjTpmny64373208 = EpFphZjTpmny54470014;     EpFphZjTpmny54470014 = EpFphZjTpmny64677255;     EpFphZjTpmny64677255 = EpFphZjTpmny79778138;     EpFphZjTpmny79778138 = EpFphZjTpmny16731145;     EpFphZjTpmny16731145 = EpFphZjTpmny52179158;     EpFphZjTpmny52179158 = EpFphZjTpmny40243820;     EpFphZjTpmny40243820 = EpFphZjTpmny74008358;     EpFphZjTpmny74008358 = EpFphZjTpmny44237766;     EpFphZjTpmny44237766 = EpFphZjTpmny78710559;     EpFphZjTpmny78710559 = EpFphZjTpmny28573867;     EpFphZjTpmny28573867 = EpFphZjTpmny42872416;     EpFphZjTpmny42872416 = EpFphZjTpmny81307645;     EpFphZjTpmny81307645 = EpFphZjTpmny73476062;     EpFphZjTpmny73476062 = EpFphZjTpmny31340781;     EpFphZjTpmny31340781 = EpFphZjTpmny23730560;     EpFphZjTpmny23730560 = EpFphZjTpmny44377454;     EpFphZjTpmny44377454 = EpFphZjTpmny56390700;     EpFphZjTpmny56390700 = EpFphZjTpmny66513071;     EpFphZjTpmny66513071 = EpFphZjTpmny73806712;     EpFphZjTpmny73806712 = EpFphZjTpmny3463052;     EpFphZjTpmny3463052 = EpFphZjTpmny7317320;     EpFphZjTpmny7317320 = EpFphZjTpmny76467448;     EpFphZjTpmny76467448 = EpFphZjTpmny24494041;     EpFphZjTpmny24494041 = EpFphZjTpmny83259289;     EpFphZjTpmny83259289 = EpFphZjTpmny29504561;     EpFphZjTpmny29504561 = EpFphZjTpmny12283090;     EpFphZjTpmny12283090 = EpFphZjTpmny27453761;     EpFphZjTpmny27453761 = EpFphZjTpmny49101262;     EpFphZjTpmny49101262 = EpFphZjTpmny76099565;     EpFphZjTpmny76099565 = EpFphZjTpmny28419263;     EpFphZjTpmny28419263 = EpFphZjTpmny82637412;     EpFphZjTpmny82637412 = EpFphZjTpmny41385043;     EpFphZjTpmny41385043 = EpFphZjTpmny98741128;     EpFphZjTpmny98741128 = EpFphZjTpmny42977152;     EpFphZjTpmny42977152 = EpFphZjTpmny79036862;     EpFphZjTpmny79036862 = EpFphZjTpmny62525127;     EpFphZjTpmny62525127 = EpFphZjTpmny8006105;     EpFphZjTpmny8006105 = EpFphZjTpmny77177761;     EpFphZjTpmny77177761 = EpFphZjTpmny15834106;     EpFphZjTpmny15834106 = EpFphZjTpmny23624210;     EpFphZjTpmny23624210 = EpFphZjTpmny32747112;     EpFphZjTpmny32747112 = EpFphZjTpmny9965573;     EpFphZjTpmny9965573 = EpFphZjTpmny43116666;     EpFphZjTpmny43116666 = EpFphZjTpmny87944016;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void EjTrQQSpueQDfj7752710() {     long GZKcKdxJHjHB78070325 = -622184437;    long GZKcKdxJHjHB9018932 = -189865918;    long GZKcKdxJHjHB48257387 = -45874146;    long GZKcKdxJHjHB30932081 = -305412538;    long GZKcKdxJHjHB26699330 = -314603242;    long GZKcKdxJHjHB7504330 = -473043161;    long GZKcKdxJHjHB12670775 = -71020501;    long GZKcKdxJHjHB8891490 = -779833746;    long GZKcKdxJHjHB8796407 = -326431602;    long GZKcKdxJHjHB20472726 = -174219955;    long GZKcKdxJHjHB26637249 = -691533276;    long GZKcKdxJHjHB74424861 = -951973364;    long GZKcKdxJHjHB32378901 = -454207637;    long GZKcKdxJHjHB96193122 = -556145530;    long GZKcKdxJHjHB78900794 = -423413604;    long GZKcKdxJHjHB89027399 = -840887452;    long GZKcKdxJHjHB94895121 = -822488485;    long GZKcKdxJHjHB53517410 = -202158637;    long GZKcKdxJHjHB11213996 = -92432379;    long GZKcKdxJHjHB1850584 = -898358097;    long GZKcKdxJHjHB25597145 = -151220830;    long GZKcKdxJHjHB8300104 = -827795633;    long GZKcKdxJHjHB94759077 = -290098822;    long GZKcKdxJHjHB6215772 = -539792689;    long GZKcKdxJHjHB39641439 = -208022934;    long GZKcKdxJHjHB52655420 = -300530631;    long GZKcKdxJHjHB31954115 = -86269236;    long GZKcKdxJHjHB88998553 = -659805217;    long GZKcKdxJHjHB76978103 = -890856723;    long GZKcKdxJHjHB58765441 = -316933770;    long GZKcKdxJHjHB75442692 = -774659023;    long GZKcKdxJHjHB71141784 = -722949083;    long GZKcKdxJHjHB20070528 = -229355943;    long GZKcKdxJHjHB74998997 = -624592559;    long GZKcKdxJHjHB12063158 = -817472973;    long GZKcKdxJHjHB60581367 = -472237480;    long GZKcKdxJHjHB33740446 = -182186050;    long GZKcKdxJHjHB51559665 = -511704543;    long GZKcKdxJHjHB98317260 = 67809122;    long GZKcKdxJHjHB38421047 = -784183843;    long GZKcKdxJHjHB81712937 = -435291033;    long GZKcKdxJHjHB18512494 = -358495318;    long GZKcKdxJHjHB66572311 = -147875097;    long GZKcKdxJHjHB84865280 = -804502287;    long GZKcKdxJHjHB13791643 = -843244429;    long GZKcKdxJHjHB88701203 = -538490002;    long GZKcKdxJHjHB31028457 = -537105236;    long GZKcKdxJHjHB70868678 = -780895215;    long GZKcKdxJHjHB81463742 = -209579534;    long GZKcKdxJHjHB17595751 = -467533386;    long GZKcKdxJHjHB91240623 = -539063642;    long GZKcKdxJHjHB39652832 = -845251177;    long GZKcKdxJHjHB92808063 = -625612822;    long GZKcKdxJHjHB81371136 = -663454195;    long GZKcKdxJHjHB82155564 = -107521205;    long GZKcKdxJHjHB69770222 = -794388805;    long GZKcKdxJHjHB14259855 = -899767097;    long GZKcKdxJHjHB42041616 = -506081457;    long GZKcKdxJHjHB91290641 = 2610396;    long GZKcKdxJHjHB74043909 = 85927388;    long GZKcKdxJHjHB75550214 = -286773925;    long GZKcKdxJHjHB23672222 = -411215284;    long GZKcKdxJHjHB31913386 = -888977023;    long GZKcKdxJHjHB50030965 = 90502168;    long GZKcKdxJHjHB45030034 = -399560933;    long GZKcKdxJHjHB55495464 = -968584194;    long GZKcKdxJHjHB54354334 = -622617422;    long GZKcKdxJHjHB57379903 = -829615079;    long GZKcKdxJHjHB84129964 = -738672557;    long GZKcKdxJHjHB18319428 = -951176124;    long GZKcKdxJHjHB55286954 = -558701402;    long GZKcKdxJHjHB43335456 = -210783943;    long GZKcKdxJHjHB55200150 = -169967760;    long GZKcKdxJHjHB72792949 = -308248537;    long GZKcKdxJHjHB20137646 = -363067064;    long GZKcKdxJHjHB7084652 = -792725512;    long GZKcKdxJHjHB41727793 = -579920537;    long GZKcKdxJHjHB9893797 = -485596535;    long GZKcKdxJHjHB92424128 = -696548260;    long GZKcKdxJHjHB50940235 = -669532933;    long GZKcKdxJHjHB21626964 = -763425395;    long GZKcKdxJHjHB61085437 = -305374022;    long GZKcKdxJHjHB7534811 = -350225684;    long GZKcKdxJHjHB59382353 = -323323337;    long GZKcKdxJHjHB67524818 = -777870129;    long GZKcKdxJHjHB35789861 = -929407847;    long GZKcKdxJHjHB78333721 = 2663738;    long GZKcKdxJHjHB38699391 = -565901749;    long GZKcKdxJHjHB92843432 = -417071355;    long GZKcKdxJHjHB42292936 = 76915831;    long GZKcKdxJHjHB46321512 = -572470384;    long GZKcKdxJHjHB91698829 = -676104593;    long GZKcKdxJHjHB60269023 = -414314939;    long GZKcKdxJHjHB24273351 = 81881733;    long GZKcKdxJHjHB62870833 = -397409919;    long GZKcKdxJHjHB58040716 = 75924251;    long GZKcKdxJHjHB86599108 = -469518295;    long GZKcKdxJHjHB16541346 = -138377265;    long GZKcKdxJHjHB39835246 = -304941355;    long GZKcKdxJHjHB58296179 = -622184437;     GZKcKdxJHjHB78070325 = GZKcKdxJHjHB9018932;     GZKcKdxJHjHB9018932 = GZKcKdxJHjHB48257387;     GZKcKdxJHjHB48257387 = GZKcKdxJHjHB30932081;     GZKcKdxJHjHB30932081 = GZKcKdxJHjHB26699330;     GZKcKdxJHjHB26699330 = GZKcKdxJHjHB7504330;     GZKcKdxJHjHB7504330 = GZKcKdxJHjHB12670775;     GZKcKdxJHjHB12670775 = GZKcKdxJHjHB8891490;     GZKcKdxJHjHB8891490 = GZKcKdxJHjHB8796407;     GZKcKdxJHjHB8796407 = GZKcKdxJHjHB20472726;     GZKcKdxJHjHB20472726 = GZKcKdxJHjHB26637249;     GZKcKdxJHjHB26637249 = GZKcKdxJHjHB74424861;     GZKcKdxJHjHB74424861 = GZKcKdxJHjHB32378901;     GZKcKdxJHjHB32378901 = GZKcKdxJHjHB96193122;     GZKcKdxJHjHB96193122 = GZKcKdxJHjHB78900794;     GZKcKdxJHjHB78900794 = GZKcKdxJHjHB89027399;     GZKcKdxJHjHB89027399 = GZKcKdxJHjHB94895121;     GZKcKdxJHjHB94895121 = GZKcKdxJHjHB53517410;     GZKcKdxJHjHB53517410 = GZKcKdxJHjHB11213996;     GZKcKdxJHjHB11213996 = GZKcKdxJHjHB1850584;     GZKcKdxJHjHB1850584 = GZKcKdxJHjHB25597145;     GZKcKdxJHjHB25597145 = GZKcKdxJHjHB8300104;     GZKcKdxJHjHB8300104 = GZKcKdxJHjHB94759077;     GZKcKdxJHjHB94759077 = GZKcKdxJHjHB6215772;     GZKcKdxJHjHB6215772 = GZKcKdxJHjHB39641439;     GZKcKdxJHjHB39641439 = GZKcKdxJHjHB52655420;     GZKcKdxJHjHB52655420 = GZKcKdxJHjHB31954115;     GZKcKdxJHjHB31954115 = GZKcKdxJHjHB88998553;     GZKcKdxJHjHB88998553 = GZKcKdxJHjHB76978103;     GZKcKdxJHjHB76978103 = GZKcKdxJHjHB58765441;     GZKcKdxJHjHB58765441 = GZKcKdxJHjHB75442692;     GZKcKdxJHjHB75442692 = GZKcKdxJHjHB71141784;     GZKcKdxJHjHB71141784 = GZKcKdxJHjHB20070528;     GZKcKdxJHjHB20070528 = GZKcKdxJHjHB74998997;     GZKcKdxJHjHB74998997 = GZKcKdxJHjHB12063158;     GZKcKdxJHjHB12063158 = GZKcKdxJHjHB60581367;     GZKcKdxJHjHB60581367 = GZKcKdxJHjHB33740446;     GZKcKdxJHjHB33740446 = GZKcKdxJHjHB51559665;     GZKcKdxJHjHB51559665 = GZKcKdxJHjHB98317260;     GZKcKdxJHjHB98317260 = GZKcKdxJHjHB38421047;     GZKcKdxJHjHB38421047 = GZKcKdxJHjHB81712937;     GZKcKdxJHjHB81712937 = GZKcKdxJHjHB18512494;     GZKcKdxJHjHB18512494 = GZKcKdxJHjHB66572311;     GZKcKdxJHjHB66572311 = GZKcKdxJHjHB84865280;     GZKcKdxJHjHB84865280 = GZKcKdxJHjHB13791643;     GZKcKdxJHjHB13791643 = GZKcKdxJHjHB88701203;     GZKcKdxJHjHB88701203 = GZKcKdxJHjHB31028457;     GZKcKdxJHjHB31028457 = GZKcKdxJHjHB70868678;     GZKcKdxJHjHB70868678 = GZKcKdxJHjHB81463742;     GZKcKdxJHjHB81463742 = GZKcKdxJHjHB17595751;     GZKcKdxJHjHB17595751 = GZKcKdxJHjHB91240623;     GZKcKdxJHjHB91240623 = GZKcKdxJHjHB39652832;     GZKcKdxJHjHB39652832 = GZKcKdxJHjHB92808063;     GZKcKdxJHjHB92808063 = GZKcKdxJHjHB81371136;     GZKcKdxJHjHB81371136 = GZKcKdxJHjHB82155564;     GZKcKdxJHjHB82155564 = GZKcKdxJHjHB69770222;     GZKcKdxJHjHB69770222 = GZKcKdxJHjHB14259855;     GZKcKdxJHjHB14259855 = GZKcKdxJHjHB42041616;     GZKcKdxJHjHB42041616 = GZKcKdxJHjHB91290641;     GZKcKdxJHjHB91290641 = GZKcKdxJHjHB74043909;     GZKcKdxJHjHB74043909 = GZKcKdxJHjHB75550214;     GZKcKdxJHjHB75550214 = GZKcKdxJHjHB23672222;     GZKcKdxJHjHB23672222 = GZKcKdxJHjHB31913386;     GZKcKdxJHjHB31913386 = GZKcKdxJHjHB50030965;     GZKcKdxJHjHB50030965 = GZKcKdxJHjHB45030034;     GZKcKdxJHjHB45030034 = GZKcKdxJHjHB55495464;     GZKcKdxJHjHB55495464 = GZKcKdxJHjHB54354334;     GZKcKdxJHjHB54354334 = GZKcKdxJHjHB57379903;     GZKcKdxJHjHB57379903 = GZKcKdxJHjHB84129964;     GZKcKdxJHjHB84129964 = GZKcKdxJHjHB18319428;     GZKcKdxJHjHB18319428 = GZKcKdxJHjHB55286954;     GZKcKdxJHjHB55286954 = GZKcKdxJHjHB43335456;     GZKcKdxJHjHB43335456 = GZKcKdxJHjHB55200150;     GZKcKdxJHjHB55200150 = GZKcKdxJHjHB72792949;     GZKcKdxJHjHB72792949 = GZKcKdxJHjHB20137646;     GZKcKdxJHjHB20137646 = GZKcKdxJHjHB7084652;     GZKcKdxJHjHB7084652 = GZKcKdxJHjHB41727793;     GZKcKdxJHjHB41727793 = GZKcKdxJHjHB9893797;     GZKcKdxJHjHB9893797 = GZKcKdxJHjHB92424128;     GZKcKdxJHjHB92424128 = GZKcKdxJHjHB50940235;     GZKcKdxJHjHB50940235 = GZKcKdxJHjHB21626964;     GZKcKdxJHjHB21626964 = GZKcKdxJHjHB61085437;     GZKcKdxJHjHB61085437 = GZKcKdxJHjHB7534811;     GZKcKdxJHjHB7534811 = GZKcKdxJHjHB59382353;     GZKcKdxJHjHB59382353 = GZKcKdxJHjHB67524818;     GZKcKdxJHjHB67524818 = GZKcKdxJHjHB35789861;     GZKcKdxJHjHB35789861 = GZKcKdxJHjHB78333721;     GZKcKdxJHjHB78333721 = GZKcKdxJHjHB38699391;     GZKcKdxJHjHB38699391 = GZKcKdxJHjHB92843432;     GZKcKdxJHjHB92843432 = GZKcKdxJHjHB42292936;     GZKcKdxJHjHB42292936 = GZKcKdxJHjHB46321512;     GZKcKdxJHjHB46321512 = GZKcKdxJHjHB91698829;     GZKcKdxJHjHB91698829 = GZKcKdxJHjHB60269023;     GZKcKdxJHjHB60269023 = GZKcKdxJHjHB24273351;     GZKcKdxJHjHB24273351 = GZKcKdxJHjHB62870833;     GZKcKdxJHjHB62870833 = GZKcKdxJHjHB58040716;     GZKcKdxJHjHB58040716 = GZKcKdxJHjHB86599108;     GZKcKdxJHjHB86599108 = GZKcKdxJHjHB16541346;     GZKcKdxJHjHB16541346 = GZKcKdxJHjHB39835246;     GZKcKdxJHjHB39835246 = GZKcKdxJHjHB58296179;     GZKcKdxJHjHB58296179 = GZKcKdxJHjHB78070325;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void wgYBWOflhVbuMW3935870() {     long EbxXeVEcYdfw37666422 = -850940815;    long EbxXeVEcYdfw10524782 = -21303;    long EbxXeVEcYdfw85258774 = -120015068;    long EbxXeVEcYdfw26807839 = -78023415;    long EbxXeVEcYdfw37992556 = -215110269;    long EbxXeVEcYdfw5181450 = -331302834;    long EbxXeVEcYdfw10029258 = -500738087;    long EbxXeVEcYdfw59716773 = -34045121;    long EbxXeVEcYdfw22609851 = -859104101;    long EbxXeVEcYdfw3497241 = -115478809;    long EbxXeVEcYdfw51932180 = 6924284;    long EbxXeVEcYdfw9096064 = 53005386;    long EbxXeVEcYdfw3133464 = -360386155;    long EbxXeVEcYdfw54566961 = -460303877;    long EbxXeVEcYdfw76208600 = -115940125;    long EbxXeVEcYdfw85781654 = -646260343;    long EbxXeVEcYdfw30856225 = -750704765;    long EbxXeVEcYdfw18185741 = -571494742;    long EbxXeVEcYdfw91656199 = -231552009;    long EbxXeVEcYdfw81767692 = -460766750;    long EbxXeVEcYdfw6058264 = 15758346;    long EbxXeVEcYdfw76789701 = -720197511;    long EbxXeVEcYdfw86950902 = -54393901;    long EbxXeVEcYdfw70946010 = -104130926;    long EbxXeVEcYdfw15619444 = -764160524;    long EbxXeVEcYdfw47070327 = -435148102;    long EbxXeVEcYdfw45294186 = -535749234;    long EbxXeVEcYdfw54109722 = -181186807;    long EbxXeVEcYdfw26762447 = -680449338;    long EbxXeVEcYdfw97238908 = -363917012;    long EbxXeVEcYdfw357011 = -319878351;    long EbxXeVEcYdfw13907045 = -40167081;    long EbxXeVEcYdfw69152566 = -209302816;    long EbxXeVEcYdfw57523439 = -126476490;    long EbxXeVEcYdfw17000519 = -465682959;    long EbxXeVEcYdfw39171264 = -783894062;    long EbxXeVEcYdfw24372123 = -474964684;    long EbxXeVEcYdfw49920003 = -456156932;    long EbxXeVEcYdfw17335203 = -750897395;    long EbxXeVEcYdfw11246702 = 41935209;    long EbxXeVEcYdfw39930751 = -903952630;    long EbxXeVEcYdfw88591674 = -363436737;    long EbxXeVEcYdfw7451553 = -981319926;    long EbxXeVEcYdfw59104785 = -128417026;    long EbxXeVEcYdfw14779959 = -289562498;    long EbxXeVEcYdfw53494332 = -781434161;    long EbxXeVEcYdfw36517179 = -428960904;    long EbxXeVEcYdfw17565072 = -13648443;    long EbxXeVEcYdfw20853390 = -493517154;    long EbxXeVEcYdfw32763143 = -788785847;    long EbxXeVEcYdfw41726874 = -325171866;    long EbxXeVEcYdfw46237985 = -816494432;    long EbxXeVEcYdfw68223577 = -865561276;    long EbxXeVEcYdfw54645660 = -923623150;    long EbxXeVEcYdfw97877606 = -71455292;    long EbxXeVEcYdfw60876720 = -30743305;    long EbxXeVEcYdfw23573880 = -945627403;    long EbxXeVEcYdfw14312765 = 84115857;    long EbxXeVEcYdfw11188396 = -313862891;    long EbxXeVEcYdfw90922228 = -779962168;    long EbxXeVEcYdfw59887264 = -795553601;    long EbxXeVEcYdfw55919535 = -219551280;    long EbxXeVEcYdfw32954327 = -353595783;    long EbxXeVEcYdfw25370943 = -395187089;    long EbxXeVEcYdfw3140231 = -795600458;    long EbxXeVEcYdfw38025135 = -952908636;    long EbxXeVEcYdfw39943497 = -737691799;    long EbxXeVEcYdfw45610024 = -133909666;    long EbxXeVEcYdfw37566442 = -994620919;    long EbxXeVEcYdfw37037337 = -332046063;    long EbxXeVEcYdfw61409531 = -71295659;    long EbxXeVEcYdfw80936222 = -194547833;    long EbxXeVEcYdfw850538 = -820597348;    long EbxXeVEcYdfw80409497 = -173487218;    long EbxXeVEcYdfw41836942 = -556814121;    long EbxXeVEcYdfw17466589 = -620804918;    long EbxXeVEcYdfw69338149 = -738877585;    long EbxXeVEcYdfw27846117 = -925976875;    long EbxXeVEcYdfw56166051 = -814568429;    long EbxXeVEcYdfw62125111 = -982726364;    long EbxXeVEcYdfw10553149 = 93812801;    long EbxXeVEcYdfw27729114 = -422100791;    long EbxXeVEcYdfw33256332 = -687669654;    long EbxXeVEcYdfw93999303 = -891663492;    long EbxXeVEcYdfw55512034 = 61254853;    long EbxXeVEcYdfw54119026 = -503383919;    long EbxXeVEcYdfw45683468 = -174605805;    long EbxXeVEcYdfw14506907 = -285679666;    long EbxXeVEcYdfw59645833 = 44978801;    long EbxXeVEcYdfw56123799 = -334939655;    long EbxXeVEcYdfw15597385 = -838266660;    long EbxXeVEcYdfw10059359 = -459080542;    long EbxXeVEcYdfw38731607 = -42294041;    long EbxXeVEcYdfw26412975 = -970935227;    long EbxXeVEcYdfw51359437 = -162511191;    long EbxXeVEcYdfw84011215 = -584401350;    long EbxXeVEcYdfw55637348 = 90159046;    long EbxXeVEcYdfw82080610 = -486132837;    long EbxXeVEcYdfw55964555 = -332816568;    long EbxXeVEcYdfw76754823 = -850940815;     EbxXeVEcYdfw37666422 = EbxXeVEcYdfw10524782;     EbxXeVEcYdfw10524782 = EbxXeVEcYdfw85258774;     EbxXeVEcYdfw85258774 = EbxXeVEcYdfw26807839;     EbxXeVEcYdfw26807839 = EbxXeVEcYdfw37992556;     EbxXeVEcYdfw37992556 = EbxXeVEcYdfw5181450;     EbxXeVEcYdfw5181450 = EbxXeVEcYdfw10029258;     EbxXeVEcYdfw10029258 = EbxXeVEcYdfw59716773;     EbxXeVEcYdfw59716773 = EbxXeVEcYdfw22609851;     EbxXeVEcYdfw22609851 = EbxXeVEcYdfw3497241;     EbxXeVEcYdfw3497241 = EbxXeVEcYdfw51932180;     EbxXeVEcYdfw51932180 = EbxXeVEcYdfw9096064;     EbxXeVEcYdfw9096064 = EbxXeVEcYdfw3133464;     EbxXeVEcYdfw3133464 = EbxXeVEcYdfw54566961;     EbxXeVEcYdfw54566961 = EbxXeVEcYdfw76208600;     EbxXeVEcYdfw76208600 = EbxXeVEcYdfw85781654;     EbxXeVEcYdfw85781654 = EbxXeVEcYdfw30856225;     EbxXeVEcYdfw30856225 = EbxXeVEcYdfw18185741;     EbxXeVEcYdfw18185741 = EbxXeVEcYdfw91656199;     EbxXeVEcYdfw91656199 = EbxXeVEcYdfw81767692;     EbxXeVEcYdfw81767692 = EbxXeVEcYdfw6058264;     EbxXeVEcYdfw6058264 = EbxXeVEcYdfw76789701;     EbxXeVEcYdfw76789701 = EbxXeVEcYdfw86950902;     EbxXeVEcYdfw86950902 = EbxXeVEcYdfw70946010;     EbxXeVEcYdfw70946010 = EbxXeVEcYdfw15619444;     EbxXeVEcYdfw15619444 = EbxXeVEcYdfw47070327;     EbxXeVEcYdfw47070327 = EbxXeVEcYdfw45294186;     EbxXeVEcYdfw45294186 = EbxXeVEcYdfw54109722;     EbxXeVEcYdfw54109722 = EbxXeVEcYdfw26762447;     EbxXeVEcYdfw26762447 = EbxXeVEcYdfw97238908;     EbxXeVEcYdfw97238908 = EbxXeVEcYdfw357011;     EbxXeVEcYdfw357011 = EbxXeVEcYdfw13907045;     EbxXeVEcYdfw13907045 = EbxXeVEcYdfw69152566;     EbxXeVEcYdfw69152566 = EbxXeVEcYdfw57523439;     EbxXeVEcYdfw57523439 = EbxXeVEcYdfw17000519;     EbxXeVEcYdfw17000519 = EbxXeVEcYdfw39171264;     EbxXeVEcYdfw39171264 = EbxXeVEcYdfw24372123;     EbxXeVEcYdfw24372123 = EbxXeVEcYdfw49920003;     EbxXeVEcYdfw49920003 = EbxXeVEcYdfw17335203;     EbxXeVEcYdfw17335203 = EbxXeVEcYdfw11246702;     EbxXeVEcYdfw11246702 = EbxXeVEcYdfw39930751;     EbxXeVEcYdfw39930751 = EbxXeVEcYdfw88591674;     EbxXeVEcYdfw88591674 = EbxXeVEcYdfw7451553;     EbxXeVEcYdfw7451553 = EbxXeVEcYdfw59104785;     EbxXeVEcYdfw59104785 = EbxXeVEcYdfw14779959;     EbxXeVEcYdfw14779959 = EbxXeVEcYdfw53494332;     EbxXeVEcYdfw53494332 = EbxXeVEcYdfw36517179;     EbxXeVEcYdfw36517179 = EbxXeVEcYdfw17565072;     EbxXeVEcYdfw17565072 = EbxXeVEcYdfw20853390;     EbxXeVEcYdfw20853390 = EbxXeVEcYdfw32763143;     EbxXeVEcYdfw32763143 = EbxXeVEcYdfw41726874;     EbxXeVEcYdfw41726874 = EbxXeVEcYdfw46237985;     EbxXeVEcYdfw46237985 = EbxXeVEcYdfw68223577;     EbxXeVEcYdfw68223577 = EbxXeVEcYdfw54645660;     EbxXeVEcYdfw54645660 = EbxXeVEcYdfw97877606;     EbxXeVEcYdfw97877606 = EbxXeVEcYdfw60876720;     EbxXeVEcYdfw60876720 = EbxXeVEcYdfw23573880;     EbxXeVEcYdfw23573880 = EbxXeVEcYdfw14312765;     EbxXeVEcYdfw14312765 = EbxXeVEcYdfw11188396;     EbxXeVEcYdfw11188396 = EbxXeVEcYdfw90922228;     EbxXeVEcYdfw90922228 = EbxXeVEcYdfw59887264;     EbxXeVEcYdfw59887264 = EbxXeVEcYdfw55919535;     EbxXeVEcYdfw55919535 = EbxXeVEcYdfw32954327;     EbxXeVEcYdfw32954327 = EbxXeVEcYdfw25370943;     EbxXeVEcYdfw25370943 = EbxXeVEcYdfw3140231;     EbxXeVEcYdfw3140231 = EbxXeVEcYdfw38025135;     EbxXeVEcYdfw38025135 = EbxXeVEcYdfw39943497;     EbxXeVEcYdfw39943497 = EbxXeVEcYdfw45610024;     EbxXeVEcYdfw45610024 = EbxXeVEcYdfw37566442;     EbxXeVEcYdfw37566442 = EbxXeVEcYdfw37037337;     EbxXeVEcYdfw37037337 = EbxXeVEcYdfw61409531;     EbxXeVEcYdfw61409531 = EbxXeVEcYdfw80936222;     EbxXeVEcYdfw80936222 = EbxXeVEcYdfw850538;     EbxXeVEcYdfw850538 = EbxXeVEcYdfw80409497;     EbxXeVEcYdfw80409497 = EbxXeVEcYdfw41836942;     EbxXeVEcYdfw41836942 = EbxXeVEcYdfw17466589;     EbxXeVEcYdfw17466589 = EbxXeVEcYdfw69338149;     EbxXeVEcYdfw69338149 = EbxXeVEcYdfw27846117;     EbxXeVEcYdfw27846117 = EbxXeVEcYdfw56166051;     EbxXeVEcYdfw56166051 = EbxXeVEcYdfw62125111;     EbxXeVEcYdfw62125111 = EbxXeVEcYdfw10553149;     EbxXeVEcYdfw10553149 = EbxXeVEcYdfw27729114;     EbxXeVEcYdfw27729114 = EbxXeVEcYdfw33256332;     EbxXeVEcYdfw33256332 = EbxXeVEcYdfw93999303;     EbxXeVEcYdfw93999303 = EbxXeVEcYdfw55512034;     EbxXeVEcYdfw55512034 = EbxXeVEcYdfw54119026;     EbxXeVEcYdfw54119026 = EbxXeVEcYdfw45683468;     EbxXeVEcYdfw45683468 = EbxXeVEcYdfw14506907;     EbxXeVEcYdfw14506907 = EbxXeVEcYdfw59645833;     EbxXeVEcYdfw59645833 = EbxXeVEcYdfw56123799;     EbxXeVEcYdfw56123799 = EbxXeVEcYdfw15597385;     EbxXeVEcYdfw15597385 = EbxXeVEcYdfw10059359;     EbxXeVEcYdfw10059359 = EbxXeVEcYdfw38731607;     EbxXeVEcYdfw38731607 = EbxXeVEcYdfw26412975;     EbxXeVEcYdfw26412975 = EbxXeVEcYdfw51359437;     EbxXeVEcYdfw51359437 = EbxXeVEcYdfw84011215;     EbxXeVEcYdfw84011215 = EbxXeVEcYdfw55637348;     EbxXeVEcYdfw55637348 = EbxXeVEcYdfw82080610;     EbxXeVEcYdfw82080610 = EbxXeVEcYdfw55964555;     EbxXeVEcYdfw55964555 = EbxXeVEcYdfw76754823;     EbxXeVEcYdfw76754823 = EbxXeVEcYdfw37666422;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void oSwKqDBgrfwJQR119030() {     long IFqhFwQivGBS97262518 = 20302808;    long IFqhFwQivGBS12030632 = -910176688;    long IFqhFwQivGBS22260163 = -194155991;    long IFqhFwQivGBS22683598 = -950634293;    long IFqhFwQivGBS49285782 = -115617296;    long IFqhFwQivGBS2858571 = -189562507;    long IFqhFwQivGBS7387740 = -930455673;    long IFqhFwQivGBS10542057 = -388256497;    long IFqhFwQivGBS36423294 = -291776600;    long IFqhFwQivGBS86521756 = -56737662;    long IFqhFwQivGBS77227111 = -394618155;    long IFqhFwQivGBS43767265 = -42015863;    long IFqhFwQivGBS73888027 = -266564674;    long IFqhFwQivGBS12940800 = -364462225;    long IFqhFwQivGBS73516406 = -908466646;    long IFqhFwQivGBS82535908 = -451633234;    long IFqhFwQivGBS66817329 = -678921045;    long IFqhFwQivGBS82854071 = -940830847;    long IFqhFwQivGBS72098402 = -370671639;    long IFqhFwQivGBS61684802 = -23175403;    long IFqhFwQivGBS86519382 = -917262479;    long IFqhFwQivGBS45279300 = -612599389;    long IFqhFwQivGBS79142727 = -918688979;    long IFqhFwQivGBS35676249 = -768469163;    long IFqhFwQivGBS91597448 = -220298115;    long IFqhFwQivGBS41485234 = -569765573;    long IFqhFwQivGBS58634256 = -985229231;    long IFqhFwQivGBS19220891 = -802568397;    long IFqhFwQivGBS76546789 = -470041954;    long IFqhFwQivGBS35712375 = -410900254;    long IFqhFwQivGBS25271329 = -965097679;    long IFqhFwQivGBS56672305 = -457385078;    long IFqhFwQivGBS18234605 = -189249688;    long IFqhFwQivGBS40047882 = -728360421;    long IFqhFwQivGBS21937880 = -113892944;    long IFqhFwQivGBS17761160 = 4449356;    long IFqhFwQivGBS15003801 = -767743319;    long IFqhFwQivGBS48280340 = -400609322;    long IFqhFwQivGBS36353146 = -469603912;    long IFqhFwQivGBS84072356 = -231945739;    long IFqhFwQivGBS98148564 = -272614226;    long IFqhFwQivGBS58670856 = -368378155;    long IFqhFwQivGBS48330795 = -714764756;    long IFqhFwQivGBS33344290 = -552331765;    long IFqhFwQivGBS15768274 = -835880567;    long IFqhFwQivGBS18287461 = 75621680;    long IFqhFwQivGBS42005901 = -320816571;    long IFqhFwQivGBS64261466 = -346401672;    long IFqhFwQivGBS60243037 = -777454773;    long IFqhFwQivGBS47930535 = -10038308;    long IFqhFwQivGBS92213124 = -111280090;    long IFqhFwQivGBS52823137 = -787737687;    long IFqhFwQivGBS43639092 = -5509730;    long IFqhFwQivGBS27920183 = -83792105;    long IFqhFwQivGBS13599648 = -35389379;    long IFqhFwQivGBS51983218 = -367097804;    long IFqhFwQivGBS32887904 = -991487709;    long IFqhFwQivGBS86583913 = -425686829;    long IFqhFwQivGBS31086149 = -630336179;    long IFqhFwQivGBS7800548 = -545851724;    long IFqhFwQivGBS44224314 = -204333277;    long IFqhFwQivGBS88166849 = -27887276;    long IFqhFwQivGBS33995268 = -918214544;    long IFqhFwQivGBS710920 = -880876346;    long IFqhFwQivGBS61250427 = -91639984;    long IFqhFwQivGBS20554807 = -937233078;    long IFqhFwQivGBS25532660 = -852766176;    long IFqhFwQivGBS33840145 = -538204253;    long IFqhFwQivGBS91002919 = -150569281;    long IFqhFwQivGBS55755246 = -812916002;    long IFqhFwQivGBS67532108 = -683889916;    long IFqhFwQivGBS18536989 = -178311724;    long IFqhFwQivGBS46500926 = -371226936;    long IFqhFwQivGBS88026046 = -38725900;    long IFqhFwQivGBS63536237 = -750561177;    long IFqhFwQivGBS27848526 = -448884324;    long IFqhFwQivGBS96948505 = -897834633;    long IFqhFwQivGBS45798437 = -266357215;    long IFqhFwQivGBS19907975 = -932588597;    long IFqhFwQivGBS73309987 = -195919796;    long IFqhFwQivGBS99479333 = -148949002;    long IFqhFwQivGBS94372790 = -538827560;    long IFqhFwQivGBS58977853 = 74886375;    long IFqhFwQivGBS28616254 = -360003646;    long IFqhFwQivGBS43499250 = -199620165;    long IFqhFwQivGBS72448191 = -77359992;    long IFqhFwQivGBS13033214 = -351875349;    long IFqhFwQivGBS90314422 = -5457583;    long IFqhFwQivGBS26448234 = -592971043;    long IFqhFwQivGBS69954662 = -746795141;    long IFqhFwQivGBS84873256 = -4062936;    long IFqhFwQivGBS28419887 = -242056491;    long IFqhFwQivGBS17194192 = -770273144;    long IFqhFwQivGBS28552599 = -923752188;    long IFqhFwQivGBS39848042 = 72387537;    long IFqhFwQivGBS9981715 = -144726951;    long IFqhFwQivGBS24675588 = -450163612;    long IFqhFwQivGBS47619876 = -833888410;    long IFqhFwQivGBS72093863 = -360691782;    long IFqhFwQivGBS95213467 = 20302808;     IFqhFwQivGBS97262518 = IFqhFwQivGBS12030632;     IFqhFwQivGBS12030632 = IFqhFwQivGBS22260163;     IFqhFwQivGBS22260163 = IFqhFwQivGBS22683598;     IFqhFwQivGBS22683598 = IFqhFwQivGBS49285782;     IFqhFwQivGBS49285782 = IFqhFwQivGBS2858571;     IFqhFwQivGBS2858571 = IFqhFwQivGBS7387740;     IFqhFwQivGBS7387740 = IFqhFwQivGBS10542057;     IFqhFwQivGBS10542057 = IFqhFwQivGBS36423294;     IFqhFwQivGBS36423294 = IFqhFwQivGBS86521756;     IFqhFwQivGBS86521756 = IFqhFwQivGBS77227111;     IFqhFwQivGBS77227111 = IFqhFwQivGBS43767265;     IFqhFwQivGBS43767265 = IFqhFwQivGBS73888027;     IFqhFwQivGBS73888027 = IFqhFwQivGBS12940800;     IFqhFwQivGBS12940800 = IFqhFwQivGBS73516406;     IFqhFwQivGBS73516406 = IFqhFwQivGBS82535908;     IFqhFwQivGBS82535908 = IFqhFwQivGBS66817329;     IFqhFwQivGBS66817329 = IFqhFwQivGBS82854071;     IFqhFwQivGBS82854071 = IFqhFwQivGBS72098402;     IFqhFwQivGBS72098402 = IFqhFwQivGBS61684802;     IFqhFwQivGBS61684802 = IFqhFwQivGBS86519382;     IFqhFwQivGBS86519382 = IFqhFwQivGBS45279300;     IFqhFwQivGBS45279300 = IFqhFwQivGBS79142727;     IFqhFwQivGBS79142727 = IFqhFwQivGBS35676249;     IFqhFwQivGBS35676249 = IFqhFwQivGBS91597448;     IFqhFwQivGBS91597448 = IFqhFwQivGBS41485234;     IFqhFwQivGBS41485234 = IFqhFwQivGBS58634256;     IFqhFwQivGBS58634256 = IFqhFwQivGBS19220891;     IFqhFwQivGBS19220891 = IFqhFwQivGBS76546789;     IFqhFwQivGBS76546789 = IFqhFwQivGBS35712375;     IFqhFwQivGBS35712375 = IFqhFwQivGBS25271329;     IFqhFwQivGBS25271329 = IFqhFwQivGBS56672305;     IFqhFwQivGBS56672305 = IFqhFwQivGBS18234605;     IFqhFwQivGBS18234605 = IFqhFwQivGBS40047882;     IFqhFwQivGBS40047882 = IFqhFwQivGBS21937880;     IFqhFwQivGBS21937880 = IFqhFwQivGBS17761160;     IFqhFwQivGBS17761160 = IFqhFwQivGBS15003801;     IFqhFwQivGBS15003801 = IFqhFwQivGBS48280340;     IFqhFwQivGBS48280340 = IFqhFwQivGBS36353146;     IFqhFwQivGBS36353146 = IFqhFwQivGBS84072356;     IFqhFwQivGBS84072356 = IFqhFwQivGBS98148564;     IFqhFwQivGBS98148564 = IFqhFwQivGBS58670856;     IFqhFwQivGBS58670856 = IFqhFwQivGBS48330795;     IFqhFwQivGBS48330795 = IFqhFwQivGBS33344290;     IFqhFwQivGBS33344290 = IFqhFwQivGBS15768274;     IFqhFwQivGBS15768274 = IFqhFwQivGBS18287461;     IFqhFwQivGBS18287461 = IFqhFwQivGBS42005901;     IFqhFwQivGBS42005901 = IFqhFwQivGBS64261466;     IFqhFwQivGBS64261466 = IFqhFwQivGBS60243037;     IFqhFwQivGBS60243037 = IFqhFwQivGBS47930535;     IFqhFwQivGBS47930535 = IFqhFwQivGBS92213124;     IFqhFwQivGBS92213124 = IFqhFwQivGBS52823137;     IFqhFwQivGBS52823137 = IFqhFwQivGBS43639092;     IFqhFwQivGBS43639092 = IFqhFwQivGBS27920183;     IFqhFwQivGBS27920183 = IFqhFwQivGBS13599648;     IFqhFwQivGBS13599648 = IFqhFwQivGBS51983218;     IFqhFwQivGBS51983218 = IFqhFwQivGBS32887904;     IFqhFwQivGBS32887904 = IFqhFwQivGBS86583913;     IFqhFwQivGBS86583913 = IFqhFwQivGBS31086149;     IFqhFwQivGBS31086149 = IFqhFwQivGBS7800548;     IFqhFwQivGBS7800548 = IFqhFwQivGBS44224314;     IFqhFwQivGBS44224314 = IFqhFwQivGBS88166849;     IFqhFwQivGBS88166849 = IFqhFwQivGBS33995268;     IFqhFwQivGBS33995268 = IFqhFwQivGBS710920;     IFqhFwQivGBS710920 = IFqhFwQivGBS61250427;     IFqhFwQivGBS61250427 = IFqhFwQivGBS20554807;     IFqhFwQivGBS20554807 = IFqhFwQivGBS25532660;     IFqhFwQivGBS25532660 = IFqhFwQivGBS33840145;     IFqhFwQivGBS33840145 = IFqhFwQivGBS91002919;     IFqhFwQivGBS91002919 = IFqhFwQivGBS55755246;     IFqhFwQivGBS55755246 = IFqhFwQivGBS67532108;     IFqhFwQivGBS67532108 = IFqhFwQivGBS18536989;     IFqhFwQivGBS18536989 = IFqhFwQivGBS46500926;     IFqhFwQivGBS46500926 = IFqhFwQivGBS88026046;     IFqhFwQivGBS88026046 = IFqhFwQivGBS63536237;     IFqhFwQivGBS63536237 = IFqhFwQivGBS27848526;     IFqhFwQivGBS27848526 = IFqhFwQivGBS96948505;     IFqhFwQivGBS96948505 = IFqhFwQivGBS45798437;     IFqhFwQivGBS45798437 = IFqhFwQivGBS19907975;     IFqhFwQivGBS19907975 = IFqhFwQivGBS73309987;     IFqhFwQivGBS73309987 = IFqhFwQivGBS99479333;     IFqhFwQivGBS99479333 = IFqhFwQivGBS94372790;     IFqhFwQivGBS94372790 = IFqhFwQivGBS58977853;     IFqhFwQivGBS58977853 = IFqhFwQivGBS28616254;     IFqhFwQivGBS28616254 = IFqhFwQivGBS43499250;     IFqhFwQivGBS43499250 = IFqhFwQivGBS72448191;     IFqhFwQivGBS72448191 = IFqhFwQivGBS13033214;     IFqhFwQivGBS13033214 = IFqhFwQivGBS90314422;     IFqhFwQivGBS90314422 = IFqhFwQivGBS26448234;     IFqhFwQivGBS26448234 = IFqhFwQivGBS69954662;     IFqhFwQivGBS69954662 = IFqhFwQivGBS84873256;     IFqhFwQivGBS84873256 = IFqhFwQivGBS28419887;     IFqhFwQivGBS28419887 = IFqhFwQivGBS17194192;     IFqhFwQivGBS17194192 = IFqhFwQivGBS28552599;     IFqhFwQivGBS28552599 = IFqhFwQivGBS39848042;     IFqhFwQivGBS39848042 = IFqhFwQivGBS9981715;     IFqhFwQivGBS9981715 = IFqhFwQivGBS24675588;     IFqhFwQivGBS24675588 = IFqhFwQivGBS47619876;     IFqhFwQivGBS47619876 = IFqhFwQivGBS72093863;     IFqhFwQivGBS72093863 = IFqhFwQivGBS95213467;     IFqhFwQivGBS95213467 = IFqhFwQivGBS97262518;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void MpfrvttJswmCTm12664219() {     long HVKBmEdzpPpN16730689 = -392828404;    long HVKBmEdzpPpN65054495 = -356054684;    long HVKBmEdzpPpN39097154 = -945784606;    long HVKBmEdzpPpN41330746 = -767208556;    long HVKBmEdzpPpN49732298 = -741889712;    long HVKBmEdzpPpN28450645 = -80047276;    long HVKBmEdzpPpN52219618 = -273761902;    long HVKBmEdzpPpN75792290 = -482064463;    long HVKBmEdzpPpN97110091 = 80032020;    long HVKBmEdzpPpN64450479 = -62323708;    long HVKBmEdzpPpN31450376 = -827608455;    long HVKBmEdzpPpN47261878 = -41318568;    long HVKBmEdzpPpN64259686 = -690921950;    long HVKBmEdzpPpN21356840 = -906747950;    long HVKBmEdzpPpN34042867 = -106550437;    long HVKBmEdzpPpN48751557 = -914825168;    long HVKBmEdzpPpN72779442 = -850695727;    long HVKBmEdzpPpN6916824 = -691585565;    long HVKBmEdzpPpN71733281 = -747876399;    long HVKBmEdzpPpN42296104 = -740711859;    long HVKBmEdzpPpN98975454 = -423474804;    long HVKBmEdzpPpN60261383 = -24402602;    long HVKBmEdzpPpN47315733 = -116263598;    long HVKBmEdzpPpN53397917 = -405013155;    long HVKBmEdzpPpN2800938 = -514598224;    long HVKBmEdzpPpN46252696 = -255560791;    long HVKBmEdzpPpN42562387 = -650380163;    long HVKBmEdzpPpN70012565 = -966301676;    long HVKBmEdzpPpN18291746 = -483953100;    long HVKBmEdzpPpN20419229 = -502338949;    long HVKBmEdzpPpN55075414 = -830423772;    long HVKBmEdzpPpN96251616 = 78265904;    long HVKBmEdzpPpN29710709 = -744457455;    long HVKBmEdzpPpN98804388 = 67036372;    long HVKBmEdzpPpN61868216 = -176595750;    long HVKBmEdzpPpN53827097 = -299119252;    long HVKBmEdzpPpN83387251 = -194619394;    long HVKBmEdzpPpN89762814 = -477818137;    long HVKBmEdzpPpN3666471 = -934018737;    long HVKBmEdzpPpN5354093 = -228476836;    long HVKBmEdzpPpN39630621 = -782400522;    long HVKBmEdzpPpN70529989 = -607274381;    long HVKBmEdzpPpN19464037 = -662566553;    long HVKBmEdzpPpN16729829 = 98595574;    long HVKBmEdzpPpN95796685 = -13003530;    long HVKBmEdzpPpN72748587 = -461709741;    long HVKBmEdzpPpN23995781 = -234509893;    long HVKBmEdzpPpN64417296 = -529688986;    long HVKBmEdzpPpN1378629 = -791394012;    long HVKBmEdzpPpN88828877 = -871050653;    long HVKBmEdzpPpN66648693 = -517645021;    long HVKBmEdzpPpN69271997 = -65090546;    long HVKBmEdzpPpN13464238 = -781618691;    long HVKBmEdzpPpN850212 = -78385741;    long HVKBmEdzpPpN13688765 = -909948014;    long HVKBmEdzpPpN56469305 = -268425803;    long HVKBmEdzpPpN17738762 = -139791087;    long HVKBmEdzpPpN85699237 = -440771452;    long HVKBmEdzpPpN38529809 = -152610332;    long HVKBmEdzpPpN3479603 = -386328922;    long HVKBmEdzpPpN85888257 = -429667113;    long HVKBmEdzpPpN82207053 = -307460226;    long HVKBmEdzpPpN57500544 = -998111364;    long HVKBmEdzpPpN76690863 = -417629031;    long HVKBmEdzpPpN9375066 = -231899937;    long HVKBmEdzpPpN35198760 = -805874360;    long HVKBmEdzpPpN17551170 = -296861114;    long HVKBmEdzpPpN65455297 = -657958323;    long HVKBmEdzpPpN59488624 = -630152200;    long HVKBmEdzpPpN80215770 = -807431185;    long HVKBmEdzpPpN65364306 = -620205775;    long HVKBmEdzpPpN83016627 = -272877590;    long HVKBmEdzpPpN3250353 = -757566829;    long HVKBmEdzpPpN66379189 = -419399564;    long HVKBmEdzpPpN2665483 = -958311338;    long HVKBmEdzpPpN28445466 = -816200424;    long HVKBmEdzpPpN40797347 = -361836049;    long HVKBmEdzpPpN30585904 = -114859173;    long HVKBmEdzpPpN57601232 = -292009626;    long HVKBmEdzpPpN30052350 = 47111516;    long HVKBmEdzpPpN22256915 = 78949102;    long HVKBmEdzpPpN78145091 = -20691177;    long HVKBmEdzpPpN68633937 = -74907665;    long HVKBmEdzpPpN29462869 = -612902447;    long HVKBmEdzpPpN53770535 = -984693929;    long HVKBmEdzpPpN85803416 = -665333226;    long HVKBmEdzpPpN82787378 = -140115406;    long HVKBmEdzpPpN28860497 = -566071714;    long HVKBmEdzpPpN85115624 = -23015614;    long HVKBmEdzpPpN5398911 = -908169948;    long HVKBmEdzpPpN36088336 = -59328166;    long HVKBmEdzpPpN97688014 = -753847943;    long HVKBmEdzpPpN51233006 = -225207806;    long HVKBmEdzpPpN186869 = -447689815;    long HVKBmEdzpPpN19465835 = -798809723;    long HVKBmEdzpPpN57423568 = -374940296;    long HVKBmEdzpPpN13029445 = -609163018;    long HVKBmEdzpPpN42773174 = -144937523;    long HVKBmEdzpPpN7354764 = -669504489;    long HVKBmEdzpPpN60597926 = -392828404;     HVKBmEdzpPpN16730689 = HVKBmEdzpPpN65054495;     HVKBmEdzpPpN65054495 = HVKBmEdzpPpN39097154;     HVKBmEdzpPpN39097154 = HVKBmEdzpPpN41330746;     HVKBmEdzpPpN41330746 = HVKBmEdzpPpN49732298;     HVKBmEdzpPpN49732298 = HVKBmEdzpPpN28450645;     HVKBmEdzpPpN28450645 = HVKBmEdzpPpN52219618;     HVKBmEdzpPpN52219618 = HVKBmEdzpPpN75792290;     HVKBmEdzpPpN75792290 = HVKBmEdzpPpN97110091;     HVKBmEdzpPpN97110091 = HVKBmEdzpPpN64450479;     HVKBmEdzpPpN64450479 = HVKBmEdzpPpN31450376;     HVKBmEdzpPpN31450376 = HVKBmEdzpPpN47261878;     HVKBmEdzpPpN47261878 = HVKBmEdzpPpN64259686;     HVKBmEdzpPpN64259686 = HVKBmEdzpPpN21356840;     HVKBmEdzpPpN21356840 = HVKBmEdzpPpN34042867;     HVKBmEdzpPpN34042867 = HVKBmEdzpPpN48751557;     HVKBmEdzpPpN48751557 = HVKBmEdzpPpN72779442;     HVKBmEdzpPpN72779442 = HVKBmEdzpPpN6916824;     HVKBmEdzpPpN6916824 = HVKBmEdzpPpN71733281;     HVKBmEdzpPpN71733281 = HVKBmEdzpPpN42296104;     HVKBmEdzpPpN42296104 = HVKBmEdzpPpN98975454;     HVKBmEdzpPpN98975454 = HVKBmEdzpPpN60261383;     HVKBmEdzpPpN60261383 = HVKBmEdzpPpN47315733;     HVKBmEdzpPpN47315733 = HVKBmEdzpPpN53397917;     HVKBmEdzpPpN53397917 = HVKBmEdzpPpN2800938;     HVKBmEdzpPpN2800938 = HVKBmEdzpPpN46252696;     HVKBmEdzpPpN46252696 = HVKBmEdzpPpN42562387;     HVKBmEdzpPpN42562387 = HVKBmEdzpPpN70012565;     HVKBmEdzpPpN70012565 = HVKBmEdzpPpN18291746;     HVKBmEdzpPpN18291746 = HVKBmEdzpPpN20419229;     HVKBmEdzpPpN20419229 = HVKBmEdzpPpN55075414;     HVKBmEdzpPpN55075414 = HVKBmEdzpPpN96251616;     HVKBmEdzpPpN96251616 = HVKBmEdzpPpN29710709;     HVKBmEdzpPpN29710709 = HVKBmEdzpPpN98804388;     HVKBmEdzpPpN98804388 = HVKBmEdzpPpN61868216;     HVKBmEdzpPpN61868216 = HVKBmEdzpPpN53827097;     HVKBmEdzpPpN53827097 = HVKBmEdzpPpN83387251;     HVKBmEdzpPpN83387251 = HVKBmEdzpPpN89762814;     HVKBmEdzpPpN89762814 = HVKBmEdzpPpN3666471;     HVKBmEdzpPpN3666471 = HVKBmEdzpPpN5354093;     HVKBmEdzpPpN5354093 = HVKBmEdzpPpN39630621;     HVKBmEdzpPpN39630621 = HVKBmEdzpPpN70529989;     HVKBmEdzpPpN70529989 = HVKBmEdzpPpN19464037;     HVKBmEdzpPpN19464037 = HVKBmEdzpPpN16729829;     HVKBmEdzpPpN16729829 = HVKBmEdzpPpN95796685;     HVKBmEdzpPpN95796685 = HVKBmEdzpPpN72748587;     HVKBmEdzpPpN72748587 = HVKBmEdzpPpN23995781;     HVKBmEdzpPpN23995781 = HVKBmEdzpPpN64417296;     HVKBmEdzpPpN64417296 = HVKBmEdzpPpN1378629;     HVKBmEdzpPpN1378629 = HVKBmEdzpPpN88828877;     HVKBmEdzpPpN88828877 = HVKBmEdzpPpN66648693;     HVKBmEdzpPpN66648693 = HVKBmEdzpPpN69271997;     HVKBmEdzpPpN69271997 = HVKBmEdzpPpN13464238;     HVKBmEdzpPpN13464238 = HVKBmEdzpPpN850212;     HVKBmEdzpPpN850212 = HVKBmEdzpPpN13688765;     HVKBmEdzpPpN13688765 = HVKBmEdzpPpN56469305;     HVKBmEdzpPpN56469305 = HVKBmEdzpPpN17738762;     HVKBmEdzpPpN17738762 = HVKBmEdzpPpN85699237;     HVKBmEdzpPpN85699237 = HVKBmEdzpPpN38529809;     HVKBmEdzpPpN38529809 = HVKBmEdzpPpN3479603;     HVKBmEdzpPpN3479603 = HVKBmEdzpPpN85888257;     HVKBmEdzpPpN85888257 = HVKBmEdzpPpN82207053;     HVKBmEdzpPpN82207053 = HVKBmEdzpPpN57500544;     HVKBmEdzpPpN57500544 = HVKBmEdzpPpN76690863;     HVKBmEdzpPpN76690863 = HVKBmEdzpPpN9375066;     HVKBmEdzpPpN9375066 = HVKBmEdzpPpN35198760;     HVKBmEdzpPpN35198760 = HVKBmEdzpPpN17551170;     HVKBmEdzpPpN17551170 = HVKBmEdzpPpN65455297;     HVKBmEdzpPpN65455297 = HVKBmEdzpPpN59488624;     HVKBmEdzpPpN59488624 = HVKBmEdzpPpN80215770;     HVKBmEdzpPpN80215770 = HVKBmEdzpPpN65364306;     HVKBmEdzpPpN65364306 = HVKBmEdzpPpN83016627;     HVKBmEdzpPpN83016627 = HVKBmEdzpPpN3250353;     HVKBmEdzpPpN3250353 = HVKBmEdzpPpN66379189;     HVKBmEdzpPpN66379189 = HVKBmEdzpPpN2665483;     HVKBmEdzpPpN2665483 = HVKBmEdzpPpN28445466;     HVKBmEdzpPpN28445466 = HVKBmEdzpPpN40797347;     HVKBmEdzpPpN40797347 = HVKBmEdzpPpN30585904;     HVKBmEdzpPpN30585904 = HVKBmEdzpPpN57601232;     HVKBmEdzpPpN57601232 = HVKBmEdzpPpN30052350;     HVKBmEdzpPpN30052350 = HVKBmEdzpPpN22256915;     HVKBmEdzpPpN22256915 = HVKBmEdzpPpN78145091;     HVKBmEdzpPpN78145091 = HVKBmEdzpPpN68633937;     HVKBmEdzpPpN68633937 = HVKBmEdzpPpN29462869;     HVKBmEdzpPpN29462869 = HVKBmEdzpPpN53770535;     HVKBmEdzpPpN53770535 = HVKBmEdzpPpN85803416;     HVKBmEdzpPpN85803416 = HVKBmEdzpPpN82787378;     HVKBmEdzpPpN82787378 = HVKBmEdzpPpN28860497;     HVKBmEdzpPpN28860497 = HVKBmEdzpPpN85115624;     HVKBmEdzpPpN85115624 = HVKBmEdzpPpN5398911;     HVKBmEdzpPpN5398911 = HVKBmEdzpPpN36088336;     HVKBmEdzpPpN36088336 = HVKBmEdzpPpN97688014;     HVKBmEdzpPpN97688014 = HVKBmEdzpPpN51233006;     HVKBmEdzpPpN51233006 = HVKBmEdzpPpN186869;     HVKBmEdzpPpN186869 = HVKBmEdzpPpN19465835;     HVKBmEdzpPpN19465835 = HVKBmEdzpPpN57423568;     HVKBmEdzpPpN57423568 = HVKBmEdzpPpN13029445;     HVKBmEdzpPpN13029445 = HVKBmEdzpPpN42773174;     HVKBmEdzpPpN42773174 = HVKBmEdzpPpN7354764;     HVKBmEdzpPpN7354764 = HVKBmEdzpPpN60597926;     HVKBmEdzpPpN60597926 = HVKBmEdzpPpN16730689;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void MqllqwMKTknkqs72966876() {     double bDfuqTHClgEo6856998 = -451584605;    double bDfuqTHClgEo48179560 = -730980854;    double bDfuqTHClgEo34589853 = 17420933;    double bDfuqTHClgEo14829321 = -953380378;    double bDfuqTHClgEo62789033 = -683213154;    double bDfuqTHClgEo9237049 = 27319617;    double bDfuqTHClgEo46883057 = 88692625;    double bDfuqTHClgEo28670854 = -118512201;    double bDfuqTHClgEo20921779 = 72139383;    double bDfuqTHClgEo68706149 = -732198233;    double bDfuqTHClgEo7602195 = -236028613;    double bDfuqTHClgEo82011386 = -620906703;    double bDfuqTHClgEo2605819 = 96842189;    double bDfuqTHClgEo59775693 = -904908835;    double bDfuqTHClgEo32117239 = -591671380;    double bDfuqTHClgEo72931299 = -615205038;    double bDfuqTHClgEo16741623 = -12040968;    double bDfuqTHClgEo28272536 = -34434857;    double bDfuqTHClgEo32647672 = -114286835;    double bDfuqTHClgEo9620352 = -288590168;    double bDfuqTHClgEo86897856 = -127899897;    double bDfuqTHClgEo58342965 = -357499237;    double bDfuqTHClgEo80554151 = -522723519;    double bDfuqTHClgEo61319015 = -853037530;    double bDfuqTHClgEo49686125 = -58109168;    double bDfuqTHClgEo65043660 = -131434526;    double bDfuqTHClgEo64529722 = -409909156;    double bDfuqTHClgEo93182940 = 73808265;    double bDfuqTHClgEo79500744 = -146152148;    double bDfuqTHClgEo68208309 = -376741340;    double bDfuqTHClgEo58538816 = -57090315;    double bDfuqTHClgEo95618530 = -422558516;    double bDfuqTHClgEo38679750 = 55317386;    double bDfuqTHClgEo22643034 = 75585214;    double bDfuqTHClgEo97464750 = -926931411;    double bDfuqTHClgEo7058105 = -602148663;    double bDfuqTHClgEo83620820 = -810435298;    double bDfuqTHClgEo14120098 = -343877381;    double bDfuqTHClgEo14199488 = -641480782;    double bDfuqTHClgEo49866234 = -133184609;    double bDfuqTHClgEo53330295 = -488261797;    double bDfuqTHClgEo25174452 = -421767594;    double bDfuqTHClgEo79280877 = -37992149;    double bDfuqTHClgEo47391770 = -865487614;    double bDfuqTHClgEo87761102 = -125513486;    double bDfuqTHClgEo93187581 = -945333646;    double bDfuqTHClgEo4419071 = -882992393;    double bDfuqTHClgEo54803755 = -556345239;    double bDfuqTHClgEo29297283 = -127333358;    double bDfuqTHClgEo18109284 = -228046991;    double bDfuqTHClgEo96014217 = -892027066;    double bDfuqTHClgEo13045105 = -29517379;    double bDfuqTHClgEo62916693 = -493471685;    double bDfuqTHClgEo53757274 = -201941023;    double bDfuqTHClgEo86069019 = 61451715;    double bDfuqTHClgEo48514032 = 5914632;    double bDfuqTHClgEo67625408 = -108257336;    double bDfuqTHClgEo73270838 = -129541537;    double bDfuqTHClgEo65143195 = -795271210;    double bDfuqTHClgEo97745373 = -451778629;    double bDfuqTHClgEo44707327 = -562771228;    double bDfuqTHClgEo53700116 = -985115641;    double bDfuqTHClgEo49170110 = -972360054;    double bDfuqTHClgEo52713470 = -551119278;    double bDfuqTHClgEo10167333 = -575107919;    double bDfuqTHClgEo11983665 = -813470098;    double bDfuqTHClgEo43331636 = -576224089;    double bDfuqTHClgEo79962785 = -978743026;    double bDfuqTHClgEo62310943 = -977977424;    double bDfuqTHClgEo25059135 = -989522718;    double bDfuqTHClgEo89310479 = -804769740;    double bDfuqTHClgEo2621525 = -668163587;    double bDfuqTHClgEo14073048 = -392954076;    double bDfuqTHClgEo82781438 = -981102227;    double bDfuqTHClgEo56290057 = -800328372;    double bDfuqTHClgEo61723404 = -706132303;    double bDfuqTHClgEo79062087 = -219507089;    double bDfuqTHClgEo33162382 = -657235905;    double bDfuqTHClgEo73557912 = -627524045;    double bDfuqTHClgEo56498544 = -112775522;    double bDfuqTHClgEo60624589 = -248442133;    double bDfuqTHClgEo9725967 = -853563918;    double bDfuqTHClgEo63885658 = -798858377;    double bDfuqTHClgEo61391460 = -918105158;    double bDfuqTHClgEo72194091 = -484714275;    double bDfuqTHClgEo45493712 = 72427064;    double bDfuqTHClgEo32701837 = -929086831;    double bDfuqTHClgEo84922476 = -742741592;    double bDfuqTHClgEo36574014 = -985866501;    double bDfuqTHClgEo48950718 = -832846043;    double bDfuqTHClgEo39432696 = -393891327;    double bDfuqTHClgEo10349982 = -580893761;    double bDfuqTHClgEo48976902 = -548606172;    double bDfuqTHClgEo16454115 = -89702154;    double bDfuqTHClgEo5158907 = -570413382;    double bDfuqTHClgEo99630178 = -503146157;    double bDfuqTHClgEo76004342 = -449407540;    double bDfuqTHClgEo26567408 = -486872872;    double bDfuqTHClgEo37224437 = -190379696;    double bDfuqTHClgEo75777438 = -451584605;     bDfuqTHClgEo6856998 = bDfuqTHClgEo48179560;     bDfuqTHClgEo48179560 = bDfuqTHClgEo34589853;     bDfuqTHClgEo34589853 = bDfuqTHClgEo14829321;     bDfuqTHClgEo14829321 = bDfuqTHClgEo62789033;     bDfuqTHClgEo62789033 = bDfuqTHClgEo9237049;     bDfuqTHClgEo9237049 = bDfuqTHClgEo46883057;     bDfuqTHClgEo46883057 = bDfuqTHClgEo28670854;     bDfuqTHClgEo28670854 = bDfuqTHClgEo20921779;     bDfuqTHClgEo20921779 = bDfuqTHClgEo68706149;     bDfuqTHClgEo68706149 = bDfuqTHClgEo7602195;     bDfuqTHClgEo7602195 = bDfuqTHClgEo82011386;     bDfuqTHClgEo82011386 = bDfuqTHClgEo2605819;     bDfuqTHClgEo2605819 = bDfuqTHClgEo59775693;     bDfuqTHClgEo59775693 = bDfuqTHClgEo32117239;     bDfuqTHClgEo32117239 = bDfuqTHClgEo72931299;     bDfuqTHClgEo72931299 = bDfuqTHClgEo16741623;     bDfuqTHClgEo16741623 = bDfuqTHClgEo28272536;     bDfuqTHClgEo28272536 = bDfuqTHClgEo32647672;     bDfuqTHClgEo32647672 = bDfuqTHClgEo9620352;     bDfuqTHClgEo9620352 = bDfuqTHClgEo86897856;     bDfuqTHClgEo86897856 = bDfuqTHClgEo58342965;     bDfuqTHClgEo58342965 = bDfuqTHClgEo80554151;     bDfuqTHClgEo80554151 = bDfuqTHClgEo61319015;     bDfuqTHClgEo61319015 = bDfuqTHClgEo49686125;     bDfuqTHClgEo49686125 = bDfuqTHClgEo65043660;     bDfuqTHClgEo65043660 = bDfuqTHClgEo64529722;     bDfuqTHClgEo64529722 = bDfuqTHClgEo93182940;     bDfuqTHClgEo93182940 = bDfuqTHClgEo79500744;     bDfuqTHClgEo79500744 = bDfuqTHClgEo68208309;     bDfuqTHClgEo68208309 = bDfuqTHClgEo58538816;     bDfuqTHClgEo58538816 = bDfuqTHClgEo95618530;     bDfuqTHClgEo95618530 = bDfuqTHClgEo38679750;     bDfuqTHClgEo38679750 = bDfuqTHClgEo22643034;     bDfuqTHClgEo22643034 = bDfuqTHClgEo97464750;     bDfuqTHClgEo97464750 = bDfuqTHClgEo7058105;     bDfuqTHClgEo7058105 = bDfuqTHClgEo83620820;     bDfuqTHClgEo83620820 = bDfuqTHClgEo14120098;     bDfuqTHClgEo14120098 = bDfuqTHClgEo14199488;     bDfuqTHClgEo14199488 = bDfuqTHClgEo49866234;     bDfuqTHClgEo49866234 = bDfuqTHClgEo53330295;     bDfuqTHClgEo53330295 = bDfuqTHClgEo25174452;     bDfuqTHClgEo25174452 = bDfuqTHClgEo79280877;     bDfuqTHClgEo79280877 = bDfuqTHClgEo47391770;     bDfuqTHClgEo47391770 = bDfuqTHClgEo87761102;     bDfuqTHClgEo87761102 = bDfuqTHClgEo93187581;     bDfuqTHClgEo93187581 = bDfuqTHClgEo4419071;     bDfuqTHClgEo4419071 = bDfuqTHClgEo54803755;     bDfuqTHClgEo54803755 = bDfuqTHClgEo29297283;     bDfuqTHClgEo29297283 = bDfuqTHClgEo18109284;     bDfuqTHClgEo18109284 = bDfuqTHClgEo96014217;     bDfuqTHClgEo96014217 = bDfuqTHClgEo13045105;     bDfuqTHClgEo13045105 = bDfuqTHClgEo62916693;     bDfuqTHClgEo62916693 = bDfuqTHClgEo53757274;     bDfuqTHClgEo53757274 = bDfuqTHClgEo86069019;     bDfuqTHClgEo86069019 = bDfuqTHClgEo48514032;     bDfuqTHClgEo48514032 = bDfuqTHClgEo67625408;     bDfuqTHClgEo67625408 = bDfuqTHClgEo73270838;     bDfuqTHClgEo73270838 = bDfuqTHClgEo65143195;     bDfuqTHClgEo65143195 = bDfuqTHClgEo97745373;     bDfuqTHClgEo97745373 = bDfuqTHClgEo44707327;     bDfuqTHClgEo44707327 = bDfuqTHClgEo53700116;     bDfuqTHClgEo53700116 = bDfuqTHClgEo49170110;     bDfuqTHClgEo49170110 = bDfuqTHClgEo52713470;     bDfuqTHClgEo52713470 = bDfuqTHClgEo10167333;     bDfuqTHClgEo10167333 = bDfuqTHClgEo11983665;     bDfuqTHClgEo11983665 = bDfuqTHClgEo43331636;     bDfuqTHClgEo43331636 = bDfuqTHClgEo79962785;     bDfuqTHClgEo79962785 = bDfuqTHClgEo62310943;     bDfuqTHClgEo62310943 = bDfuqTHClgEo25059135;     bDfuqTHClgEo25059135 = bDfuqTHClgEo89310479;     bDfuqTHClgEo89310479 = bDfuqTHClgEo2621525;     bDfuqTHClgEo2621525 = bDfuqTHClgEo14073048;     bDfuqTHClgEo14073048 = bDfuqTHClgEo82781438;     bDfuqTHClgEo82781438 = bDfuqTHClgEo56290057;     bDfuqTHClgEo56290057 = bDfuqTHClgEo61723404;     bDfuqTHClgEo61723404 = bDfuqTHClgEo79062087;     bDfuqTHClgEo79062087 = bDfuqTHClgEo33162382;     bDfuqTHClgEo33162382 = bDfuqTHClgEo73557912;     bDfuqTHClgEo73557912 = bDfuqTHClgEo56498544;     bDfuqTHClgEo56498544 = bDfuqTHClgEo60624589;     bDfuqTHClgEo60624589 = bDfuqTHClgEo9725967;     bDfuqTHClgEo9725967 = bDfuqTHClgEo63885658;     bDfuqTHClgEo63885658 = bDfuqTHClgEo61391460;     bDfuqTHClgEo61391460 = bDfuqTHClgEo72194091;     bDfuqTHClgEo72194091 = bDfuqTHClgEo45493712;     bDfuqTHClgEo45493712 = bDfuqTHClgEo32701837;     bDfuqTHClgEo32701837 = bDfuqTHClgEo84922476;     bDfuqTHClgEo84922476 = bDfuqTHClgEo36574014;     bDfuqTHClgEo36574014 = bDfuqTHClgEo48950718;     bDfuqTHClgEo48950718 = bDfuqTHClgEo39432696;     bDfuqTHClgEo39432696 = bDfuqTHClgEo10349982;     bDfuqTHClgEo10349982 = bDfuqTHClgEo48976902;     bDfuqTHClgEo48976902 = bDfuqTHClgEo16454115;     bDfuqTHClgEo16454115 = bDfuqTHClgEo5158907;     bDfuqTHClgEo5158907 = bDfuqTHClgEo99630178;     bDfuqTHClgEo99630178 = bDfuqTHClgEo76004342;     bDfuqTHClgEo76004342 = bDfuqTHClgEo26567408;     bDfuqTHClgEo26567408 = bDfuqTHClgEo37224437;     bDfuqTHClgEo37224437 = bDfuqTHClgEo75777438;     bDfuqTHClgEo75777438 = bDfuqTHClgEo6856998;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void ThfkrusdkP85512065() {     double baDIKLmfwPtL26325168 = -864715817;    double baDIKLmfwPtL1203424 = -176858850;    double baDIKLmfwPtL51426845 = -734207682;    double baDIKLmfwPtL33476470 = -769954641;    double baDIKLmfwPtL63235550 = -209485570;    double baDIKLmfwPtL34829123 = -963165152;    double baDIKLmfwPtL91714935 = -354613605;    double baDIKLmfwPtL93921087 = -212320167;    double baDIKLmfwPtL81608576 = -656051996;    double baDIKLmfwPtL46634872 = -737784279;    double baDIKLmfwPtL61825458 = -669018913;    double baDIKLmfwPtL85505999 = -620209408;    double baDIKLmfwPtL92977477 = -327515087;    double baDIKLmfwPtL68191733 = -347194560;    double baDIKLmfwPtL92643700 = -889755172;    double baDIKLmfwPtL39146948 = 21603028;    double baDIKLmfwPtL22703736 = -183815650;    double baDIKLmfwPtL52335287 = -885189575;    double baDIKLmfwPtL32282552 = -491491596;    double baDIKLmfwPtL90231653 = 93873375;    double baDIKLmfwPtL99353928 = -734112222;    double baDIKLmfwPtL73325048 = -869302450;    double baDIKLmfwPtL48727158 = -820298137;    double baDIKLmfwPtL79040683 = -489581522;    double baDIKLmfwPtL60889614 = -352409277;    double baDIKLmfwPtL69811122 = -917229744;    double baDIKLmfwPtL48457853 = -75060088;    double baDIKLmfwPtL43974616 = -89925014;    double baDIKLmfwPtL21245701 = -160063293;    double baDIKLmfwPtL52915163 = -468180035;    double baDIKLmfwPtL88342901 = 77583592;    double baDIKLmfwPtL35197841 = -986907534;    double baDIKLmfwPtL50155853 = -499890381;    double baDIKLmfwPtL81399540 = -229017992;    double baDIKLmfwPtL37395087 = -989634217;    double baDIKLmfwPtL43124041 = -905717271;    double baDIKLmfwPtL52004271 = -237311373;    double baDIKLmfwPtL55602572 = -421086197;    double baDIKLmfwPtL81512813 = -5895607;    double baDIKLmfwPtL71147970 = -129715706;    double baDIKLmfwPtL94812351 = -998048093;    double baDIKLmfwPtL37033585 = -660663820;    double baDIKLmfwPtL50414119 = 14206054;    double baDIKLmfwPtL30777309 = -214560275;    double baDIKLmfwPtL67789513 = -402636449;    double baDIKLmfwPtL47648708 = -382665067;    double baDIKLmfwPtL86408951 = -796685716;    double baDIKLmfwPtL54959585 = -739632554;    double baDIKLmfwPtL70432873 = -141272597;    double baDIKLmfwPtL59007626 = 10940664;    double baDIKLmfwPtL70449786 = -198391997;    double baDIKLmfwPtL29493965 = -406870239;    double baDIKLmfwPtL32741840 = -169580646;    double baDIKLmfwPtL26687302 = -196534659;    double baDIKLmfwPtL86158136 = -813106920;    double baDIKLmfwPtL53000119 = -995413367;    double baDIKLmfwPtL52476266 = -356560714;    double baDIKLmfwPtL72386162 = -144626161;    double baDIKLmfwPtL72586855 = -317545364;    double baDIKLmfwPtL93424428 = -292255827;    double baDIKLmfwPtL86371270 = -788105064;    double baDIKLmfwPtL47740320 = -164688592;    double baDIKLmfwPtL72675386 = 47743126;    double baDIKLmfwPtL28693414 = -87871962;    double baDIKLmfwPtL58291971 = -715367872;    double baDIKLmfwPtL26627618 = -682111380;    double baDIKLmfwPtL35350146 = -20319027;    double baDIKLmfwPtL11577938 = 1502904;    double baDIKLmfwPtL30796647 = -357560344;    double baDIKLmfwPtL49519659 = -984037901;    double baDIKLmfwPtL87142677 = -741085599;    double baDIKLmfwPtL67101163 = -762729453;    double baDIKLmfwPtL70822474 = -779293968;    double baDIKLmfwPtL61134582 = -261775891;    double baDIKLmfwPtL95419301 = 91921468;    double baDIKLmfwPtL62320343 = 26551597;    double baDIKLmfwPtL22910930 = -783508504;    double baDIKLmfwPtL17949849 = -505737863;    double baDIKLmfwPtL11251170 = 13054926;    double baDIKLmfwPtL13240906 = -969744210;    double baDIKLmfwPtL83402171 = -20544028;    double baDIKLmfwPtL93498267 = -335427535;    double baDIKLmfwPtL73541742 = -948652417;    double baDIKLmfwPtL62238075 = -71003958;    double baDIKLmfwPtL82465376 = -169788039;    double baDIKLmfwPtL58848937 = -515546170;    double baDIKLmfwPtL2456002 = -717326888;    double baDIKLmfwPtL23468551 = -203355722;    double baDIKLmfwPtL95241404 = -415911072;    double baDIKLmfwPtL84394967 = -994220851;    double baDIKLmfwPtL90647775 = -449156558;    double baDIKLmfwPtL79618109 = 7314787;    double baDIKLmfwPtL83015717 = -3540833;    double baDIKLmfwPtL88088384 = -713639781;    double baDIKLmfwPtL84776699 = -341610642;    double baDIKLmfwPtL47072032 = -733359502;    double baDIKLmfwPtL64358199 = -608406946;    double baDIKLmfwPtL21720706 = -897921985;    double baDIKLmfwPtL72485338 = -499192404;    double baDIKLmfwPtL41161896 = -864715817;     baDIKLmfwPtL26325168 = baDIKLmfwPtL1203424;     baDIKLmfwPtL1203424 = baDIKLmfwPtL51426845;     baDIKLmfwPtL51426845 = baDIKLmfwPtL33476470;     baDIKLmfwPtL33476470 = baDIKLmfwPtL63235550;     baDIKLmfwPtL63235550 = baDIKLmfwPtL34829123;     baDIKLmfwPtL34829123 = baDIKLmfwPtL91714935;     baDIKLmfwPtL91714935 = baDIKLmfwPtL93921087;     baDIKLmfwPtL93921087 = baDIKLmfwPtL81608576;     baDIKLmfwPtL81608576 = baDIKLmfwPtL46634872;     baDIKLmfwPtL46634872 = baDIKLmfwPtL61825458;     baDIKLmfwPtL61825458 = baDIKLmfwPtL85505999;     baDIKLmfwPtL85505999 = baDIKLmfwPtL92977477;     baDIKLmfwPtL92977477 = baDIKLmfwPtL68191733;     baDIKLmfwPtL68191733 = baDIKLmfwPtL92643700;     baDIKLmfwPtL92643700 = baDIKLmfwPtL39146948;     baDIKLmfwPtL39146948 = baDIKLmfwPtL22703736;     baDIKLmfwPtL22703736 = baDIKLmfwPtL52335287;     baDIKLmfwPtL52335287 = baDIKLmfwPtL32282552;     baDIKLmfwPtL32282552 = baDIKLmfwPtL90231653;     baDIKLmfwPtL90231653 = baDIKLmfwPtL99353928;     baDIKLmfwPtL99353928 = baDIKLmfwPtL73325048;     baDIKLmfwPtL73325048 = baDIKLmfwPtL48727158;     baDIKLmfwPtL48727158 = baDIKLmfwPtL79040683;     baDIKLmfwPtL79040683 = baDIKLmfwPtL60889614;     baDIKLmfwPtL60889614 = baDIKLmfwPtL69811122;     baDIKLmfwPtL69811122 = baDIKLmfwPtL48457853;     baDIKLmfwPtL48457853 = baDIKLmfwPtL43974616;     baDIKLmfwPtL43974616 = baDIKLmfwPtL21245701;     baDIKLmfwPtL21245701 = baDIKLmfwPtL52915163;     baDIKLmfwPtL52915163 = baDIKLmfwPtL88342901;     baDIKLmfwPtL88342901 = baDIKLmfwPtL35197841;     baDIKLmfwPtL35197841 = baDIKLmfwPtL50155853;     baDIKLmfwPtL50155853 = baDIKLmfwPtL81399540;     baDIKLmfwPtL81399540 = baDIKLmfwPtL37395087;     baDIKLmfwPtL37395087 = baDIKLmfwPtL43124041;     baDIKLmfwPtL43124041 = baDIKLmfwPtL52004271;     baDIKLmfwPtL52004271 = baDIKLmfwPtL55602572;     baDIKLmfwPtL55602572 = baDIKLmfwPtL81512813;     baDIKLmfwPtL81512813 = baDIKLmfwPtL71147970;     baDIKLmfwPtL71147970 = baDIKLmfwPtL94812351;     baDIKLmfwPtL94812351 = baDIKLmfwPtL37033585;     baDIKLmfwPtL37033585 = baDIKLmfwPtL50414119;     baDIKLmfwPtL50414119 = baDIKLmfwPtL30777309;     baDIKLmfwPtL30777309 = baDIKLmfwPtL67789513;     baDIKLmfwPtL67789513 = baDIKLmfwPtL47648708;     baDIKLmfwPtL47648708 = baDIKLmfwPtL86408951;     baDIKLmfwPtL86408951 = baDIKLmfwPtL54959585;     baDIKLmfwPtL54959585 = baDIKLmfwPtL70432873;     baDIKLmfwPtL70432873 = baDIKLmfwPtL59007626;     baDIKLmfwPtL59007626 = baDIKLmfwPtL70449786;     baDIKLmfwPtL70449786 = baDIKLmfwPtL29493965;     baDIKLmfwPtL29493965 = baDIKLmfwPtL32741840;     baDIKLmfwPtL32741840 = baDIKLmfwPtL26687302;     baDIKLmfwPtL26687302 = baDIKLmfwPtL86158136;     baDIKLmfwPtL86158136 = baDIKLmfwPtL53000119;     baDIKLmfwPtL53000119 = baDIKLmfwPtL52476266;     baDIKLmfwPtL52476266 = baDIKLmfwPtL72386162;     baDIKLmfwPtL72386162 = baDIKLmfwPtL72586855;     baDIKLmfwPtL72586855 = baDIKLmfwPtL93424428;     baDIKLmfwPtL93424428 = baDIKLmfwPtL86371270;     baDIKLmfwPtL86371270 = baDIKLmfwPtL47740320;     baDIKLmfwPtL47740320 = baDIKLmfwPtL72675386;     baDIKLmfwPtL72675386 = baDIKLmfwPtL28693414;     baDIKLmfwPtL28693414 = baDIKLmfwPtL58291971;     baDIKLmfwPtL58291971 = baDIKLmfwPtL26627618;     baDIKLmfwPtL26627618 = baDIKLmfwPtL35350146;     baDIKLmfwPtL35350146 = baDIKLmfwPtL11577938;     baDIKLmfwPtL11577938 = baDIKLmfwPtL30796647;     baDIKLmfwPtL30796647 = baDIKLmfwPtL49519659;     baDIKLmfwPtL49519659 = baDIKLmfwPtL87142677;     baDIKLmfwPtL87142677 = baDIKLmfwPtL67101163;     baDIKLmfwPtL67101163 = baDIKLmfwPtL70822474;     baDIKLmfwPtL70822474 = baDIKLmfwPtL61134582;     baDIKLmfwPtL61134582 = baDIKLmfwPtL95419301;     baDIKLmfwPtL95419301 = baDIKLmfwPtL62320343;     baDIKLmfwPtL62320343 = baDIKLmfwPtL22910930;     baDIKLmfwPtL22910930 = baDIKLmfwPtL17949849;     baDIKLmfwPtL17949849 = baDIKLmfwPtL11251170;     baDIKLmfwPtL11251170 = baDIKLmfwPtL13240906;     baDIKLmfwPtL13240906 = baDIKLmfwPtL83402171;     baDIKLmfwPtL83402171 = baDIKLmfwPtL93498267;     baDIKLmfwPtL93498267 = baDIKLmfwPtL73541742;     baDIKLmfwPtL73541742 = baDIKLmfwPtL62238075;     baDIKLmfwPtL62238075 = baDIKLmfwPtL82465376;     baDIKLmfwPtL82465376 = baDIKLmfwPtL58848937;     baDIKLmfwPtL58848937 = baDIKLmfwPtL2456002;     baDIKLmfwPtL2456002 = baDIKLmfwPtL23468551;     baDIKLmfwPtL23468551 = baDIKLmfwPtL95241404;     baDIKLmfwPtL95241404 = baDIKLmfwPtL84394967;     baDIKLmfwPtL84394967 = baDIKLmfwPtL90647775;     baDIKLmfwPtL90647775 = baDIKLmfwPtL79618109;     baDIKLmfwPtL79618109 = baDIKLmfwPtL83015717;     baDIKLmfwPtL83015717 = baDIKLmfwPtL88088384;     baDIKLmfwPtL88088384 = baDIKLmfwPtL84776699;     baDIKLmfwPtL84776699 = baDIKLmfwPtL47072032;     baDIKLmfwPtL47072032 = baDIKLmfwPtL64358199;     baDIKLmfwPtL64358199 = baDIKLmfwPtL21720706;     baDIKLmfwPtL21720706 = baDIKLmfwPtL72485338;     baDIKLmfwPtL72485338 = baDIKLmfwPtL41161896;     baDIKLmfwPtL41161896 = baDIKLmfwPtL26325168;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void kZynOQijqE81695225() {     double JnJsqbfyiM85921264 = 6527806;    double JnJsqbfyiM2709274 = 12985765;    double JnJsqbfyiM88428233 = -808348605;    double JnJsqbfyiM29352228 = -542565518;    double JnJsqbfyiM74528776 = -109992597;    double JnJsqbfyiM32506244 = -821424825;    double JnJsqbfyiM89073417 = -784331191;    double JnJsqbfyiM44746371 = -566531543;    double JnJsqbfyiM95422020 = -88724496;    double JnJsqbfyiM29659388 = -679043133;    double JnJsqbfyiM87120389 = 29438648;    double JnJsqbfyiM20177201 = -715230657;    double JnJsqbfyiM63732041 = -233693606;    double JnJsqbfyiM26565573 = -251352908;    double JnJsqbfyiM89951506 = -582281693;    double JnJsqbfyiM35901203 = -883769863;    double JnJsqbfyiM58664839 = -112031930;    double JnJsqbfyiM17003619 = -154525680;    double JnJsqbfyiM12724755 = -630611226;    double JnJsqbfyiM70148763 = -568535278;    double JnJsqbfyiM79815047 = -567133047;    double JnJsqbfyiM41814647 = -761704328;    double JnJsqbfyiM40918983 = -584593216;    double JnJsqbfyiM43770922 = -53919759;    double JnJsqbfyiM36867619 = -908546867;    double JnJsqbfyiM64226029 = 48152785;    double JnJsqbfyiM61797923 = -524540085;    double JnJsqbfyiM9085785 = -711306604;    double JnJsqbfyiM71030043 = 50344091;    double JnJsqbfyiM91388629 = -515163277;    double JnJsqbfyiM13257220 = -567635736;    double JnJsqbfyiM77963101 = -304125531;    double JnJsqbfyiM99237891 = -479837253;    double JnJsqbfyiM63923983 = -830901923;    double JnJsqbfyiM42332448 = -637844203;    double JnJsqbfyiM21713938 = -117373853;    double JnJsqbfyiM42635948 = -530090008;    double JnJsqbfyiM53962910 = -365538586;    double JnJsqbfyiM530756 = -824602124;    double JnJsqbfyiM43973624 = -403596654;    double JnJsqbfyiM53030165 = -366709689;    double JnJsqbfyiM7112766 = -665605238;    double JnJsqbfyiM91293361 = -819238776;    double JnJsqbfyiM5016814 = -638475014;    double JnJsqbfyiM68777829 = -948954517;    double JnJsqbfyiM12441838 = -625609226;    double JnJsqbfyiM91897673 = -688541383;    double JnJsqbfyiM1655979 = 27614218;    double JnJsqbfyiM9822522 = -425210217;    double JnJsqbfyiM74175018 = -310311796;    double JnJsqbfyiM20936037 = 15499779;    double JnJsqbfyiM36079118 = -378113494;    double JnJsqbfyiM8157354 = -409529100;    double JnJsqbfyiM99961825 = -456703615;    double JnJsqbfyiM1880179 = -777041007;    double JnJsqbfyiM44106618 = -231767867;    double JnJsqbfyiM61790291 = -402421020;    double JnJsqbfyiM44657311 = -654428846;    double JnJsqbfyiM92484608 = -634018651;    double JnJsqbfyiM10302748 = -58145383;    double JnJsqbfyiM70708320 = -196884740;    double JnJsqbfyiM79987633 = 26975413;    double JnJsqbfyiM73716327 = -516875635;    double JnJsqbfyiM4033391 = -573561219;    double JnJsqbfyiM16402168 = -11407397;    double JnJsqbfyiM9157289 = -666435822;    double JnJsqbfyiM20939310 = -135393404;    double JnJsqbfyiM99808058 = -402791683;    double JnJsqbfyiM84233124 = -613508705;    double JnJsqbfyiM68237568 = -364907840;    double JnJsqbfyiM93265254 = -253679856;    double JnJsqbfyiM4701930 = -746493344;    double JnJsqbfyiM16472863 = -329923557;    double JnJsqbfyiM68751130 = -127014573;    double JnJsqbfyiM17118598 = -101825589;    double JnJsqbfyiM72702281 = -901527809;    double JnJsqbfyiM50521286 = -942465553;    double JnJsqbfyiM35902169 = -946118203;    double JnJsqbfyiM74993093 = -104965242;    double JnJsqbfyiM24425782 = -182937642;    double JnJsqbfyiM72328355 = -263305832;    double JnJsqbfyiM60141944 = -452154304;    double JnJsqbfyiM99263263 = -186096388;    double JnJsqbfyiM96855025 = -639344113;    double JnJsqbfyiM70452593 = -430663057;    double JnJsqbfyiM77178102 = -89522243;    double JnJsqbfyiM69805747 = -894596432;    double JnJsqbfyiM99276066 = 76866361;    double JnJsqbfyiM62043805 = 46139084;    double JnJsqbfyiM98225830 = -306076336;    double JnJsqbfyiM59923647 = -714952834;    double JnJsqbfyiM97978637 = -875661162;    double JnJsqbfyiM61478301 = -731519936;    double JnJsqbfyiM90228008 = -666456742;    double JnJsqbfyiM73265304 = -106711914;    double JnJsqbfyiM73042532 = -293685102;    double JnJsqbfyiM33396439 = -48729604;    double JnJsqbfyiM87259970 = -145677557;    double JnJsqbfyiM88614646 = -527067617;    double JnJsqbfyiM59620541 = 6527806;     JnJsqbfyiM85921264 = JnJsqbfyiM2709274;     JnJsqbfyiM2709274 = JnJsqbfyiM88428233;     JnJsqbfyiM88428233 = JnJsqbfyiM29352228;     JnJsqbfyiM29352228 = JnJsqbfyiM74528776;     JnJsqbfyiM74528776 = JnJsqbfyiM32506244;     JnJsqbfyiM32506244 = JnJsqbfyiM89073417;     JnJsqbfyiM89073417 = JnJsqbfyiM44746371;     JnJsqbfyiM44746371 = JnJsqbfyiM95422020;     JnJsqbfyiM95422020 = JnJsqbfyiM29659388;     JnJsqbfyiM29659388 = JnJsqbfyiM87120389;     JnJsqbfyiM87120389 = JnJsqbfyiM20177201;     JnJsqbfyiM20177201 = JnJsqbfyiM63732041;     JnJsqbfyiM63732041 = JnJsqbfyiM26565573;     JnJsqbfyiM26565573 = JnJsqbfyiM89951506;     JnJsqbfyiM89951506 = JnJsqbfyiM35901203;     JnJsqbfyiM35901203 = JnJsqbfyiM58664839;     JnJsqbfyiM58664839 = JnJsqbfyiM17003619;     JnJsqbfyiM17003619 = JnJsqbfyiM12724755;     JnJsqbfyiM12724755 = JnJsqbfyiM70148763;     JnJsqbfyiM70148763 = JnJsqbfyiM79815047;     JnJsqbfyiM79815047 = JnJsqbfyiM41814647;     JnJsqbfyiM41814647 = JnJsqbfyiM40918983;     JnJsqbfyiM40918983 = JnJsqbfyiM43770922;     JnJsqbfyiM43770922 = JnJsqbfyiM36867619;     JnJsqbfyiM36867619 = JnJsqbfyiM64226029;     JnJsqbfyiM64226029 = JnJsqbfyiM61797923;     JnJsqbfyiM61797923 = JnJsqbfyiM9085785;     JnJsqbfyiM9085785 = JnJsqbfyiM71030043;     JnJsqbfyiM71030043 = JnJsqbfyiM91388629;     JnJsqbfyiM91388629 = JnJsqbfyiM13257220;     JnJsqbfyiM13257220 = JnJsqbfyiM77963101;     JnJsqbfyiM77963101 = JnJsqbfyiM99237891;     JnJsqbfyiM99237891 = JnJsqbfyiM63923983;     JnJsqbfyiM63923983 = JnJsqbfyiM42332448;     JnJsqbfyiM42332448 = JnJsqbfyiM21713938;     JnJsqbfyiM21713938 = JnJsqbfyiM42635948;     JnJsqbfyiM42635948 = JnJsqbfyiM53962910;     JnJsqbfyiM53962910 = JnJsqbfyiM530756;     JnJsqbfyiM530756 = JnJsqbfyiM43973624;     JnJsqbfyiM43973624 = JnJsqbfyiM53030165;     JnJsqbfyiM53030165 = JnJsqbfyiM7112766;     JnJsqbfyiM7112766 = JnJsqbfyiM91293361;     JnJsqbfyiM91293361 = JnJsqbfyiM5016814;     JnJsqbfyiM5016814 = JnJsqbfyiM68777829;     JnJsqbfyiM68777829 = JnJsqbfyiM12441838;     JnJsqbfyiM12441838 = JnJsqbfyiM91897673;     JnJsqbfyiM91897673 = JnJsqbfyiM1655979;     JnJsqbfyiM1655979 = JnJsqbfyiM9822522;     JnJsqbfyiM9822522 = JnJsqbfyiM74175018;     JnJsqbfyiM74175018 = JnJsqbfyiM20936037;     JnJsqbfyiM20936037 = JnJsqbfyiM36079118;     JnJsqbfyiM36079118 = JnJsqbfyiM8157354;     JnJsqbfyiM8157354 = JnJsqbfyiM99961825;     JnJsqbfyiM99961825 = JnJsqbfyiM1880179;     JnJsqbfyiM1880179 = JnJsqbfyiM44106618;     JnJsqbfyiM44106618 = JnJsqbfyiM61790291;     JnJsqbfyiM61790291 = JnJsqbfyiM44657311;     JnJsqbfyiM44657311 = JnJsqbfyiM92484608;     JnJsqbfyiM92484608 = JnJsqbfyiM10302748;     JnJsqbfyiM10302748 = JnJsqbfyiM70708320;     JnJsqbfyiM70708320 = JnJsqbfyiM79987633;     JnJsqbfyiM79987633 = JnJsqbfyiM73716327;     JnJsqbfyiM73716327 = JnJsqbfyiM4033391;     JnJsqbfyiM4033391 = JnJsqbfyiM16402168;     JnJsqbfyiM16402168 = JnJsqbfyiM9157289;     JnJsqbfyiM9157289 = JnJsqbfyiM20939310;     JnJsqbfyiM20939310 = JnJsqbfyiM99808058;     JnJsqbfyiM99808058 = JnJsqbfyiM84233124;     JnJsqbfyiM84233124 = JnJsqbfyiM68237568;     JnJsqbfyiM68237568 = JnJsqbfyiM93265254;     JnJsqbfyiM93265254 = JnJsqbfyiM4701930;     JnJsqbfyiM4701930 = JnJsqbfyiM16472863;     JnJsqbfyiM16472863 = JnJsqbfyiM68751130;     JnJsqbfyiM68751130 = JnJsqbfyiM17118598;     JnJsqbfyiM17118598 = JnJsqbfyiM72702281;     JnJsqbfyiM72702281 = JnJsqbfyiM50521286;     JnJsqbfyiM50521286 = JnJsqbfyiM35902169;     JnJsqbfyiM35902169 = JnJsqbfyiM74993093;     JnJsqbfyiM74993093 = JnJsqbfyiM24425782;     JnJsqbfyiM24425782 = JnJsqbfyiM72328355;     JnJsqbfyiM72328355 = JnJsqbfyiM60141944;     JnJsqbfyiM60141944 = JnJsqbfyiM99263263;     JnJsqbfyiM99263263 = JnJsqbfyiM96855025;     JnJsqbfyiM96855025 = JnJsqbfyiM70452593;     JnJsqbfyiM70452593 = JnJsqbfyiM77178102;     JnJsqbfyiM77178102 = JnJsqbfyiM69805747;     JnJsqbfyiM69805747 = JnJsqbfyiM99276066;     JnJsqbfyiM99276066 = JnJsqbfyiM62043805;     JnJsqbfyiM62043805 = JnJsqbfyiM98225830;     JnJsqbfyiM98225830 = JnJsqbfyiM59923647;     JnJsqbfyiM59923647 = JnJsqbfyiM97978637;     JnJsqbfyiM97978637 = JnJsqbfyiM61478301;     JnJsqbfyiM61478301 = JnJsqbfyiM90228008;     JnJsqbfyiM90228008 = JnJsqbfyiM73265304;     JnJsqbfyiM73265304 = JnJsqbfyiM73042532;     JnJsqbfyiM73042532 = JnJsqbfyiM33396439;     JnJsqbfyiM33396439 = JnJsqbfyiM87259970;     JnJsqbfyiM87259970 = JnJsqbfyiM88614646;     JnJsqbfyiM88614646 = JnJsqbfyiM59620541;     JnJsqbfyiM59620541 = JnJsqbfyiM85921264;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void WvvvTUNIQg94240414() {     double GZxcGrBqpk5389435 = -406603406;    double GZxcGrBqpk55733137 = -532892231;    double GZxcGrBqpk5265225 = -459977220;    double GZxcGrBqpk47999377 = -359139781;    double GZxcGrBqpk74975292 = -736265013;    double GZxcGrBqpk58098318 = -711909593;    double GZxcGrBqpk33905296 = -127637421;    double GZxcGrBqpk9996605 = -660339509;    double GZxcGrBqpk56108817 = -816915875;    double GZxcGrBqpk7588111 = -684629179;    double GZxcGrBqpk41343653 = -403551653;    double GZxcGrBqpk23671815 = -714533362;    double GZxcGrBqpk54103700 = -658050882;    double GZxcGrBqpk34981613 = -793638633;    double GZxcGrBqpk50477967 = -880365484;    double GZxcGrBqpk2116852 = -246961797;    double GZxcGrBqpk64626953 = -283806611;    double GZxcGrBqpk41066370 = 94719602;    double GZxcGrBqpk12359634 = 92184014;    double GZxcGrBqpk50760065 = -186071734;    double GZxcGrBqpk92271119 = -73345372;    double GZxcGrBqpk56796730 = -173507541;    double GZxcGrBqpk9091989 = -882167835;    double GZxcGrBqpk61492591 = -790463751;    double GZxcGrBqpk48071108 = -102846977;    double GZxcGrBqpk68993490 = -737642433;    double GZxcGrBqpk45726054 = -189691017;    double GZxcGrBqpk59877459 = -875039883;    double GZxcGrBqpk12775001 = 36432945;    double GZxcGrBqpk76095483 = -606601971;    double GZxcGrBqpk43061305 = -432961829;    double GZxcGrBqpk17542412 = -868474549;    double GZxcGrBqpk10713996 = 64954980;    double GZxcGrBqpk22680490 = -35505129;    double GZxcGrBqpk82262783 = -700547009;    double GZxcGrBqpk57779875 = -420942461;    double GZxcGrBqpk11019399 = 43033917;    double GZxcGrBqpk95445384 = -442747402;    double GZxcGrBqpk67844080 = -189016949;    double GZxcGrBqpk65255360 = -400127750;    double GZxcGrBqpk94512222 = -876495985;    double GZxcGrBqpk18971899 = -904501464;    double GZxcGrBqpk62426602 = -767040573;    double GZxcGrBqpk88402352 = 12452325;    double GZxcGrBqpk48806240 = -126077480;    double GZxcGrBqpk66902964 = -62940648;    double GZxcGrBqpk73887553 = -602234706;    double GZxcGrBqpk1811809 = -155673096;    double GZxcGrBqpk50958112 = -439149455;    double GZxcGrBqpk15073361 = -71324141;    double GZxcGrBqpk95371605 = -390865152;    double GZxcGrBqpk52527978 = -755466353;    double GZxcGrBqpk77982500 = -85638061;    double GZxcGrBqpk72891854 = -451297251;    double GZxcGrBqpk1969295 = -551599642;    double GZxcGrBqpk48592705 = -133095866;    double GZxcGrBqpk46641149 = -650724397;    double GZxcGrBqpk43772634 = -669513470;    double GZxcGrBqpk99928268 = -156292805;    double GZxcGrBqpk5981803 = -998622581;    double GZxcGrBqpk12372264 = -422218577;    double GZxcGrBqpk74027837 = -252597538;    double GZxcGrBqpk97221603 = -596772455;    double GZxcGrBqpk80013333 = -110313904;    double GZxcGrBqpk64526805 = -151667350;    double GZxcGrBqpk23801242 = -535077104;    double GZxcGrBqpk12957820 = -679488342;    double GZxcGrBqpk31423211 = -522545753;    double GZxcGrBqpk52718829 = 6908375;    double GZxcGrBqpk92698092 = -359423023;    double GZxcGrBqpk91097452 = -189995715;    double GZxcGrBqpk69181568 = -841059210;    double GZxcGrBqpk73222289 = -716263450;    double GZxcGrBqpk47104274 = -507688237;    double GZxcGrBqpk56247842 = -309575749;    double GZxcGrBqpk73299220 = -168843909;    double GZxcGrBqpk94370127 = -406466968;    double GZxcGrBqpk20689636 = -794620161;    double GZxcGrBqpk12686351 = -564386271;    double GZxcGrBqpk81168144 = 60093670;    double GZxcGrBqpk95105937 = -35407728;    double GZxcGrBqpk43914245 = 65982079;    double GZxcGrBqpk8919347 = -335890428;    double GZxcGrBqpk97701639 = -892242914;    double GZxcGrBqpk80723878 = -115736820;    double GZxcGrBqpk90533326 = -677495476;    double GZxcGrBqpk39559912 = -682836489;    double GZxcGrBqpk37822141 = -483747770;    double GZxcGrBqpk20711196 = -483905487;    double GZxcGrBqpk33670079 = -467451144;    double GZxcGrBqpk11138727 = -770218064;    double GZxcGrBqpk67246765 = -287452614;    double GZxcGrBqpk95517115 = -186454598;    double GZxcGrBqpk61862278 = -190394369;    double GZxcGrBqpk52883097 = -977909174;    double GZxcGrBqpk20484386 = -523898447;    double GZxcGrBqpk21750296 = -207729010;    double GZxcGrBqpk82413268 = -556726670;    double GZxcGrBqpk23875547 = -835880325;    double GZxcGrBqpk25004999 = -406603406;     GZxcGrBqpk5389435 = GZxcGrBqpk55733137;     GZxcGrBqpk55733137 = GZxcGrBqpk5265225;     GZxcGrBqpk5265225 = GZxcGrBqpk47999377;     GZxcGrBqpk47999377 = GZxcGrBqpk74975292;     GZxcGrBqpk74975292 = GZxcGrBqpk58098318;     GZxcGrBqpk58098318 = GZxcGrBqpk33905296;     GZxcGrBqpk33905296 = GZxcGrBqpk9996605;     GZxcGrBqpk9996605 = GZxcGrBqpk56108817;     GZxcGrBqpk56108817 = GZxcGrBqpk7588111;     GZxcGrBqpk7588111 = GZxcGrBqpk41343653;     GZxcGrBqpk41343653 = GZxcGrBqpk23671815;     GZxcGrBqpk23671815 = GZxcGrBqpk54103700;     GZxcGrBqpk54103700 = GZxcGrBqpk34981613;     GZxcGrBqpk34981613 = GZxcGrBqpk50477967;     GZxcGrBqpk50477967 = GZxcGrBqpk2116852;     GZxcGrBqpk2116852 = GZxcGrBqpk64626953;     GZxcGrBqpk64626953 = GZxcGrBqpk41066370;     GZxcGrBqpk41066370 = GZxcGrBqpk12359634;     GZxcGrBqpk12359634 = GZxcGrBqpk50760065;     GZxcGrBqpk50760065 = GZxcGrBqpk92271119;     GZxcGrBqpk92271119 = GZxcGrBqpk56796730;     GZxcGrBqpk56796730 = GZxcGrBqpk9091989;     GZxcGrBqpk9091989 = GZxcGrBqpk61492591;     GZxcGrBqpk61492591 = GZxcGrBqpk48071108;     GZxcGrBqpk48071108 = GZxcGrBqpk68993490;     GZxcGrBqpk68993490 = GZxcGrBqpk45726054;     GZxcGrBqpk45726054 = GZxcGrBqpk59877459;     GZxcGrBqpk59877459 = GZxcGrBqpk12775001;     GZxcGrBqpk12775001 = GZxcGrBqpk76095483;     GZxcGrBqpk76095483 = GZxcGrBqpk43061305;     GZxcGrBqpk43061305 = GZxcGrBqpk17542412;     GZxcGrBqpk17542412 = GZxcGrBqpk10713996;     GZxcGrBqpk10713996 = GZxcGrBqpk22680490;     GZxcGrBqpk22680490 = GZxcGrBqpk82262783;     GZxcGrBqpk82262783 = GZxcGrBqpk57779875;     GZxcGrBqpk57779875 = GZxcGrBqpk11019399;     GZxcGrBqpk11019399 = GZxcGrBqpk95445384;     GZxcGrBqpk95445384 = GZxcGrBqpk67844080;     GZxcGrBqpk67844080 = GZxcGrBqpk65255360;     GZxcGrBqpk65255360 = GZxcGrBqpk94512222;     GZxcGrBqpk94512222 = GZxcGrBqpk18971899;     GZxcGrBqpk18971899 = GZxcGrBqpk62426602;     GZxcGrBqpk62426602 = GZxcGrBqpk88402352;     GZxcGrBqpk88402352 = GZxcGrBqpk48806240;     GZxcGrBqpk48806240 = GZxcGrBqpk66902964;     GZxcGrBqpk66902964 = GZxcGrBqpk73887553;     GZxcGrBqpk73887553 = GZxcGrBqpk1811809;     GZxcGrBqpk1811809 = GZxcGrBqpk50958112;     GZxcGrBqpk50958112 = GZxcGrBqpk15073361;     GZxcGrBqpk15073361 = GZxcGrBqpk95371605;     GZxcGrBqpk95371605 = GZxcGrBqpk52527978;     GZxcGrBqpk52527978 = GZxcGrBqpk77982500;     GZxcGrBqpk77982500 = GZxcGrBqpk72891854;     GZxcGrBqpk72891854 = GZxcGrBqpk1969295;     GZxcGrBqpk1969295 = GZxcGrBqpk48592705;     GZxcGrBqpk48592705 = GZxcGrBqpk46641149;     GZxcGrBqpk46641149 = GZxcGrBqpk43772634;     GZxcGrBqpk43772634 = GZxcGrBqpk99928268;     GZxcGrBqpk99928268 = GZxcGrBqpk5981803;     GZxcGrBqpk5981803 = GZxcGrBqpk12372264;     GZxcGrBqpk12372264 = GZxcGrBqpk74027837;     GZxcGrBqpk74027837 = GZxcGrBqpk97221603;     GZxcGrBqpk97221603 = GZxcGrBqpk80013333;     GZxcGrBqpk80013333 = GZxcGrBqpk64526805;     GZxcGrBqpk64526805 = GZxcGrBqpk23801242;     GZxcGrBqpk23801242 = GZxcGrBqpk12957820;     GZxcGrBqpk12957820 = GZxcGrBqpk31423211;     GZxcGrBqpk31423211 = GZxcGrBqpk52718829;     GZxcGrBqpk52718829 = GZxcGrBqpk92698092;     GZxcGrBqpk92698092 = GZxcGrBqpk91097452;     GZxcGrBqpk91097452 = GZxcGrBqpk69181568;     GZxcGrBqpk69181568 = GZxcGrBqpk73222289;     GZxcGrBqpk73222289 = GZxcGrBqpk47104274;     GZxcGrBqpk47104274 = GZxcGrBqpk56247842;     GZxcGrBqpk56247842 = GZxcGrBqpk73299220;     GZxcGrBqpk73299220 = GZxcGrBqpk94370127;     GZxcGrBqpk94370127 = GZxcGrBqpk20689636;     GZxcGrBqpk20689636 = GZxcGrBqpk12686351;     GZxcGrBqpk12686351 = GZxcGrBqpk81168144;     GZxcGrBqpk81168144 = GZxcGrBqpk95105937;     GZxcGrBqpk95105937 = GZxcGrBqpk43914245;     GZxcGrBqpk43914245 = GZxcGrBqpk8919347;     GZxcGrBqpk8919347 = GZxcGrBqpk97701639;     GZxcGrBqpk97701639 = GZxcGrBqpk80723878;     GZxcGrBqpk80723878 = GZxcGrBqpk90533326;     GZxcGrBqpk90533326 = GZxcGrBqpk39559912;     GZxcGrBqpk39559912 = GZxcGrBqpk37822141;     GZxcGrBqpk37822141 = GZxcGrBqpk20711196;     GZxcGrBqpk20711196 = GZxcGrBqpk33670079;     GZxcGrBqpk33670079 = GZxcGrBqpk11138727;     GZxcGrBqpk11138727 = GZxcGrBqpk67246765;     GZxcGrBqpk67246765 = GZxcGrBqpk95517115;     GZxcGrBqpk95517115 = GZxcGrBqpk61862278;     GZxcGrBqpk61862278 = GZxcGrBqpk52883097;     GZxcGrBqpk52883097 = GZxcGrBqpk20484386;     GZxcGrBqpk20484386 = GZxcGrBqpk21750296;     GZxcGrBqpk21750296 = GZxcGrBqpk82413268;     GZxcGrBqpk82413268 = GZxcGrBqpk23875547;     GZxcGrBqpk23875547 = GZxcGrBqpk25004999;     GZxcGrBqpk25004999 = GZxcGrBqpk5389435;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void SNDRmdMMWV54543071() {     double dTunlSoVma95515743 = -465359607;    double dTunlSoVma38858202 = -907818402;    double dTunlSoVma757924 = -596771681;    double dTunlSoVma21497952 = -545311603;    double dTunlSoVma88032028 = -677588455;    double dTunlSoVma38884723 = -604542701;    double dTunlSoVma28568735 = -865182893;    double dTunlSoVma62875167 = -296787247;    double dTunlSoVma79920505 = -824808512;    double dTunlSoVma11843781 = -254503704;    double dTunlSoVma17495473 = -911971810;    double dTunlSoVma58421322 = -194121497;    double dTunlSoVma92449832 = -970286743;    double dTunlSoVma73400466 = -791799518;    double dTunlSoVma48552339 = -265486427;    double dTunlSoVma26296594 = 52658333;    double dTunlSoVma8589134 = -545151853;    double dTunlSoVma62422082 = -348129690;    double dTunlSoVma73274025 = -374226422;    double dTunlSoVma18084313 = -833950043;    double dTunlSoVma80193521 = -877770465;    double dTunlSoVma54878312 = -506604176;    double dTunlSoVma42330407 = -188627756;    double dTunlSoVma69413688 = -138488126;    double dTunlSoVma94956296 = -746357921;    double dTunlSoVma87784455 = -613516168;    double dTunlSoVma67693389 = 50779989;    double dTunlSoVma83047834 = -934929941;    double dTunlSoVma73983998 = -725766103;    double dTunlSoVma23884564 = -481004363;    double dTunlSoVma46524708 = -759628373;    double dTunlSoVma16909326 = -269298969;    double dTunlSoVma19683036 = -235270180;    double dTunlSoVma46519135 = -26956287;    double dTunlSoVma17859318 = -350882670;    double dTunlSoVma11010882 = -723971871;    double dTunlSoVma11252968 = -572781987;    double dTunlSoVma19802668 = -308806646;    double dTunlSoVma78377097 = -996478995;    double dTunlSoVma9767502 = -304835523;    double dTunlSoVma8211896 = -582357261;    double dTunlSoVma73616362 = -718994677;    double dTunlSoVma22243444 = -142466169;    double dTunlSoVma19064294 = -951630863;    double dTunlSoVma40770658 = -238587436;    double dTunlSoVma87341958 = -546564553;    double dTunlSoVma54310843 = -150717206;    double dTunlSoVma92198268 = -182329350;    double dTunlSoVma78876766 = -875088802;    double dTunlSoVma44353766 = -528320479;    double dTunlSoVma24737130 = -765247196;    double dTunlSoVma96301085 = -719893186;    double dTunlSoVma27434955 = -897491056;    double dTunlSoVma25798916 = -574852533;    double dTunlSoVma74349550 = -680199914;    double dTunlSoVma40637431 = -958755431;    double dTunlSoVma96527795 = -619190646;    double dTunlSoVma31344236 = -358283555;    double dTunlSoVma26541655 = -798953683;    double dTunlSoVma247573 = 35927712;    double dTunlSoVma71191333 = -555322691;    double dTunlSoVma45520900 = -930252953;    double dTunlSoVma88891169 = -571021145;    double dTunlSoVma56035941 = -243804150;    double dTunlSoVma65319073 = -494875332;    double dTunlSoVma586147 = -542672842;    double dTunlSoVma38738286 = -958851318;    double dTunlSoVma45930698 = -843330456;    double dTunlSoVma55541148 = -340916849;    double dTunlSoVma37541457 = -541514556;    double dTunlSoVma15043626 = -374559681;    double dTunlSoVma88786465 = -136345207;    double dTunlSoVma84044984 = -351650696;    double dTunlSoVma63506523 = 30609101;    double dTunlSoVma9872418 = -151592783;    double dTunlSoVma6577160 = -58775788;    double dTunlSoVma32634869 = -264138008;    double dTunlSoVma23266114 = -236996893;    double dTunlSoVma28643031 = -899900690;    double dTunlSoVma7614339 = -99793368;    double dTunlSoVma33473612 = -362798963;    double dTunlSoVma75495121 = -766890662;    double dTunlSoVma4171069 = 40158860;    double dTunlSoVma29630232 = -97445624;    double dTunlSoVma99147434 = -715757167;    double dTunlSoVma50223622 = 60264813;    double dTunlSoVma89474370 = -371807914;    double dTunlSoVma93884120 = -660417648;    double dTunlSoVma72169585 = -346756374;    double dTunlSoVma77221887 = -392127239;    double dTunlSoVma14483087 = -4781225;    double dTunlSoVma79908732 = -114498432;    double dTunlSoVma93261012 = -509852963;    double dTunlSoVma78129524 = -932406708;    double dTunlSoVma38576169 = -749512833;    double dTunlSoVma62690995 = -652104308;    double dTunlSoVma84725193 = -47973532;    double dTunlSoVma66207502 = -898662019;    double dTunlSoVma53745220 = -356755532;    double dTunlSoVma40184511 = -465359607;     dTunlSoVma95515743 = dTunlSoVma38858202;     dTunlSoVma38858202 = dTunlSoVma757924;     dTunlSoVma757924 = dTunlSoVma21497952;     dTunlSoVma21497952 = dTunlSoVma88032028;     dTunlSoVma88032028 = dTunlSoVma38884723;     dTunlSoVma38884723 = dTunlSoVma28568735;     dTunlSoVma28568735 = dTunlSoVma62875167;     dTunlSoVma62875167 = dTunlSoVma79920505;     dTunlSoVma79920505 = dTunlSoVma11843781;     dTunlSoVma11843781 = dTunlSoVma17495473;     dTunlSoVma17495473 = dTunlSoVma58421322;     dTunlSoVma58421322 = dTunlSoVma92449832;     dTunlSoVma92449832 = dTunlSoVma73400466;     dTunlSoVma73400466 = dTunlSoVma48552339;     dTunlSoVma48552339 = dTunlSoVma26296594;     dTunlSoVma26296594 = dTunlSoVma8589134;     dTunlSoVma8589134 = dTunlSoVma62422082;     dTunlSoVma62422082 = dTunlSoVma73274025;     dTunlSoVma73274025 = dTunlSoVma18084313;     dTunlSoVma18084313 = dTunlSoVma80193521;     dTunlSoVma80193521 = dTunlSoVma54878312;     dTunlSoVma54878312 = dTunlSoVma42330407;     dTunlSoVma42330407 = dTunlSoVma69413688;     dTunlSoVma69413688 = dTunlSoVma94956296;     dTunlSoVma94956296 = dTunlSoVma87784455;     dTunlSoVma87784455 = dTunlSoVma67693389;     dTunlSoVma67693389 = dTunlSoVma83047834;     dTunlSoVma83047834 = dTunlSoVma73983998;     dTunlSoVma73983998 = dTunlSoVma23884564;     dTunlSoVma23884564 = dTunlSoVma46524708;     dTunlSoVma46524708 = dTunlSoVma16909326;     dTunlSoVma16909326 = dTunlSoVma19683036;     dTunlSoVma19683036 = dTunlSoVma46519135;     dTunlSoVma46519135 = dTunlSoVma17859318;     dTunlSoVma17859318 = dTunlSoVma11010882;     dTunlSoVma11010882 = dTunlSoVma11252968;     dTunlSoVma11252968 = dTunlSoVma19802668;     dTunlSoVma19802668 = dTunlSoVma78377097;     dTunlSoVma78377097 = dTunlSoVma9767502;     dTunlSoVma9767502 = dTunlSoVma8211896;     dTunlSoVma8211896 = dTunlSoVma73616362;     dTunlSoVma73616362 = dTunlSoVma22243444;     dTunlSoVma22243444 = dTunlSoVma19064294;     dTunlSoVma19064294 = dTunlSoVma40770658;     dTunlSoVma40770658 = dTunlSoVma87341958;     dTunlSoVma87341958 = dTunlSoVma54310843;     dTunlSoVma54310843 = dTunlSoVma92198268;     dTunlSoVma92198268 = dTunlSoVma78876766;     dTunlSoVma78876766 = dTunlSoVma44353766;     dTunlSoVma44353766 = dTunlSoVma24737130;     dTunlSoVma24737130 = dTunlSoVma96301085;     dTunlSoVma96301085 = dTunlSoVma27434955;     dTunlSoVma27434955 = dTunlSoVma25798916;     dTunlSoVma25798916 = dTunlSoVma74349550;     dTunlSoVma74349550 = dTunlSoVma40637431;     dTunlSoVma40637431 = dTunlSoVma96527795;     dTunlSoVma96527795 = dTunlSoVma31344236;     dTunlSoVma31344236 = dTunlSoVma26541655;     dTunlSoVma26541655 = dTunlSoVma247573;     dTunlSoVma247573 = dTunlSoVma71191333;     dTunlSoVma71191333 = dTunlSoVma45520900;     dTunlSoVma45520900 = dTunlSoVma88891169;     dTunlSoVma88891169 = dTunlSoVma56035941;     dTunlSoVma56035941 = dTunlSoVma65319073;     dTunlSoVma65319073 = dTunlSoVma586147;     dTunlSoVma586147 = dTunlSoVma38738286;     dTunlSoVma38738286 = dTunlSoVma45930698;     dTunlSoVma45930698 = dTunlSoVma55541148;     dTunlSoVma55541148 = dTunlSoVma37541457;     dTunlSoVma37541457 = dTunlSoVma15043626;     dTunlSoVma15043626 = dTunlSoVma88786465;     dTunlSoVma88786465 = dTunlSoVma84044984;     dTunlSoVma84044984 = dTunlSoVma63506523;     dTunlSoVma63506523 = dTunlSoVma9872418;     dTunlSoVma9872418 = dTunlSoVma6577160;     dTunlSoVma6577160 = dTunlSoVma32634869;     dTunlSoVma32634869 = dTunlSoVma23266114;     dTunlSoVma23266114 = dTunlSoVma28643031;     dTunlSoVma28643031 = dTunlSoVma7614339;     dTunlSoVma7614339 = dTunlSoVma33473612;     dTunlSoVma33473612 = dTunlSoVma75495121;     dTunlSoVma75495121 = dTunlSoVma4171069;     dTunlSoVma4171069 = dTunlSoVma29630232;     dTunlSoVma29630232 = dTunlSoVma99147434;     dTunlSoVma99147434 = dTunlSoVma50223622;     dTunlSoVma50223622 = dTunlSoVma89474370;     dTunlSoVma89474370 = dTunlSoVma93884120;     dTunlSoVma93884120 = dTunlSoVma72169585;     dTunlSoVma72169585 = dTunlSoVma77221887;     dTunlSoVma77221887 = dTunlSoVma14483087;     dTunlSoVma14483087 = dTunlSoVma79908732;     dTunlSoVma79908732 = dTunlSoVma93261012;     dTunlSoVma93261012 = dTunlSoVma78129524;     dTunlSoVma78129524 = dTunlSoVma38576169;     dTunlSoVma38576169 = dTunlSoVma62690995;     dTunlSoVma62690995 = dTunlSoVma84725193;     dTunlSoVma84725193 = dTunlSoVma66207502;     dTunlSoVma66207502 = dTunlSoVma53745220;     dTunlSoVma53745220 = dTunlSoVma40184511;     dTunlSoVma40184511 = dTunlSoVma95515743;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void ZVaxZtBDJV67088260() {     double CeBgdrAMNz14983914 = -878490819;    double CeBgdrAMNz91882066 = -353696398;    double CeBgdrAMNz17594916 = -248400296;    double CeBgdrAMNz40145101 = -361885866;    double CeBgdrAMNz88478544 = -203860871;    double CeBgdrAMNz64476797 = -495027470;    double CeBgdrAMNz73400613 = -208489123;    double CeBgdrAMNz28125401 = -390595213;    double CeBgdrAMNz40607302 = -452999891;    double CeBgdrAMNz89772504 = -260089750;    double CeBgdrAMNz71718736 = -244962110;    double CeBgdrAMNz61915935 = -193424202;    double CeBgdrAMNz82821492 = -294644019;    double CeBgdrAMNz81816506 = -234085244;    double CeBgdrAMNz9078801 = -563570218;    double CeBgdrAMNz92512242 = -410533601;    double CeBgdrAMNz14551247 = -716926534;    double CeBgdrAMNz86484833 = -98884409;    double CeBgdrAMNz72908904 = -751431183;    double CeBgdrAMNz98695614 = -451486500;    double CeBgdrAMNz92649593 = -383982790;    double CeBgdrAMNz69860395 = 81592610;    double CeBgdrAMNz10503413 = -486202374;    double CeBgdrAMNz87135356 = -875032118;    double CeBgdrAMNz6159786 = 59341970;    double CeBgdrAMNz92551916 = -299311386;    double CeBgdrAMNz51621520 = -714370942;    double CeBgdrAMNz33839510 = 1336780;    double CeBgdrAMNz15728956 = -739677248;    double CeBgdrAMNz8591418 = -572443057;    double CeBgdrAMNz76328793 = -624954465;    double CeBgdrAMNz56488636 = -833647987;    double CeBgdrAMNz31159140 = -790477946;    double CeBgdrAMNz5275642 = -331559494;    double CeBgdrAMNz57789654 = -413585476;    double CeBgdrAMNz47076819 = 72459520;    double CeBgdrAMNz79636418 = 341938;    double CeBgdrAMNz61285141 = -386015461;    double CeBgdrAMNz45690423 = -360893820;    double CeBgdrAMNz31049238 = -301366620;    double CeBgdrAMNz49693953 = 7856444;    double CeBgdrAMNz85475495 = -957890903;    double CeBgdrAMNz93376684 = -90267966;    double CeBgdrAMNz2449833 = -300703524;    double CeBgdrAMNz20799069 = -515710399;    double CeBgdrAMNz41803085 = 16104026;    double CeBgdrAMNz36300723 = -64410529;    double CeBgdrAMNz92354098 = -365616664;    double CeBgdrAMNz20012358 = -889028040;    double CeBgdrAMNz85252108 = -289332824;    double CeBgdrAMNz99172698 = -71612128;    double CeBgdrAMNz12749946 = 2753954;    double CeBgdrAMNz97260101 = -573600017;    double CeBgdrAMNz98728944 = -569446169;    double CeBgdrAMNz74438666 = -454758549;    double CeBgdrAMNz45123519 = -860083430;    double CeBgdrAMNz81378653 = -867494024;    double CeBgdrAMNz30459559 = -373368178;    double CeBgdrAMNz33985315 = -321227836;    double CeBgdrAMNz95926627 = -904549485;    double CeBgdrAMNz12855277 = -780656528;    double CeBgdrAMNz39561104 = -109825904;    double CeBgdrAMNz12396446 = -650917965;    double CeBgdrAMNz32015885 = -880556835;    double CeBgdrAMNz13443711 = -635135285;    double CeBgdrAMNz15230100 = -411314123;    double CeBgdrAMNz30756796 = -402946256;    double CeBgdrAMNz77545850 = -963084526;    double CeBgdrAMNz24026852 = -820499768;    double CeBgdrAMNz62001981 = -536029739;    double CeBgdrAMNz12875825 = -310875540;    double CeBgdrAMNz53266105 = -230911073;    double CeBgdrAMNz40794411 = -737990589;    double CeBgdrAMNz41859666 = -350064563;    double CeBgdrAMNz49001662 = -359342944;    double CeBgdrAMNz7174099 = -426091888;    double CeBgdrAMNz76483710 = -828139424;    double CeBgdrAMNz8053581 = -85498850;    double CeBgdrAMNz66336288 = -259321719;    double CeBgdrAMNz64356700 = -956762057;    double CeBgdrAMNz56251193 = -134900858;    double CeBgdrAMNz59267422 = -248754279;    double CeBgdrAMNz13827152 = -109635180;    double CeBgdrAMNz30476847 = -350344425;    double CeBgdrAMNz9418720 = -400830930;    double CeBgdrAMNz63578847 = -527708420;    double CeBgdrAMNz59228535 = -160047971;    double CeBgdrAMNz32430195 = -121031778;    double CeBgdrAMNz30836975 = -876800945;    double CeBgdrAMNz12666136 = -553502046;    double CeBgdrAMNz65698166 = -60046456;    double CeBgdrAMNz49176859 = -626289884;    double CeBgdrAMNz27299827 = 35212375;    double CeBgdrAMNz49763795 = -456344335;    double CeBgdrAMNz18193962 = -520710093;    double CeBgdrAMNz10132849 = -882317653;    double CeBgdrAMNz73079049 = -206972938;    double CeBgdrAMNz61360800 = -209711132;    double CeBgdrAMNz89006121 = -665568240;    double CeBgdrAMNz5568970 = -878490819;     CeBgdrAMNz14983914 = CeBgdrAMNz91882066;     CeBgdrAMNz91882066 = CeBgdrAMNz17594916;     CeBgdrAMNz17594916 = CeBgdrAMNz40145101;     CeBgdrAMNz40145101 = CeBgdrAMNz88478544;     CeBgdrAMNz88478544 = CeBgdrAMNz64476797;     CeBgdrAMNz64476797 = CeBgdrAMNz73400613;     CeBgdrAMNz73400613 = CeBgdrAMNz28125401;     CeBgdrAMNz28125401 = CeBgdrAMNz40607302;     CeBgdrAMNz40607302 = CeBgdrAMNz89772504;     CeBgdrAMNz89772504 = CeBgdrAMNz71718736;     CeBgdrAMNz71718736 = CeBgdrAMNz61915935;     CeBgdrAMNz61915935 = CeBgdrAMNz82821492;     CeBgdrAMNz82821492 = CeBgdrAMNz81816506;     CeBgdrAMNz81816506 = CeBgdrAMNz9078801;     CeBgdrAMNz9078801 = CeBgdrAMNz92512242;     CeBgdrAMNz92512242 = CeBgdrAMNz14551247;     CeBgdrAMNz14551247 = CeBgdrAMNz86484833;     CeBgdrAMNz86484833 = CeBgdrAMNz72908904;     CeBgdrAMNz72908904 = CeBgdrAMNz98695614;     CeBgdrAMNz98695614 = CeBgdrAMNz92649593;     CeBgdrAMNz92649593 = CeBgdrAMNz69860395;     CeBgdrAMNz69860395 = CeBgdrAMNz10503413;     CeBgdrAMNz10503413 = CeBgdrAMNz87135356;     CeBgdrAMNz87135356 = CeBgdrAMNz6159786;     CeBgdrAMNz6159786 = CeBgdrAMNz92551916;     CeBgdrAMNz92551916 = CeBgdrAMNz51621520;     CeBgdrAMNz51621520 = CeBgdrAMNz33839510;     CeBgdrAMNz33839510 = CeBgdrAMNz15728956;     CeBgdrAMNz15728956 = CeBgdrAMNz8591418;     CeBgdrAMNz8591418 = CeBgdrAMNz76328793;     CeBgdrAMNz76328793 = CeBgdrAMNz56488636;     CeBgdrAMNz56488636 = CeBgdrAMNz31159140;     CeBgdrAMNz31159140 = CeBgdrAMNz5275642;     CeBgdrAMNz5275642 = CeBgdrAMNz57789654;     CeBgdrAMNz57789654 = CeBgdrAMNz47076819;     CeBgdrAMNz47076819 = CeBgdrAMNz79636418;     CeBgdrAMNz79636418 = CeBgdrAMNz61285141;     CeBgdrAMNz61285141 = CeBgdrAMNz45690423;     CeBgdrAMNz45690423 = CeBgdrAMNz31049238;     CeBgdrAMNz31049238 = CeBgdrAMNz49693953;     CeBgdrAMNz49693953 = CeBgdrAMNz85475495;     CeBgdrAMNz85475495 = CeBgdrAMNz93376684;     CeBgdrAMNz93376684 = CeBgdrAMNz2449833;     CeBgdrAMNz2449833 = CeBgdrAMNz20799069;     CeBgdrAMNz20799069 = CeBgdrAMNz41803085;     CeBgdrAMNz41803085 = CeBgdrAMNz36300723;     CeBgdrAMNz36300723 = CeBgdrAMNz92354098;     CeBgdrAMNz92354098 = CeBgdrAMNz20012358;     CeBgdrAMNz20012358 = CeBgdrAMNz85252108;     CeBgdrAMNz85252108 = CeBgdrAMNz99172698;     CeBgdrAMNz99172698 = CeBgdrAMNz12749946;     CeBgdrAMNz12749946 = CeBgdrAMNz97260101;     CeBgdrAMNz97260101 = CeBgdrAMNz98728944;     CeBgdrAMNz98728944 = CeBgdrAMNz74438666;     CeBgdrAMNz74438666 = CeBgdrAMNz45123519;     CeBgdrAMNz45123519 = CeBgdrAMNz81378653;     CeBgdrAMNz81378653 = CeBgdrAMNz30459559;     CeBgdrAMNz30459559 = CeBgdrAMNz33985315;     CeBgdrAMNz33985315 = CeBgdrAMNz95926627;     CeBgdrAMNz95926627 = CeBgdrAMNz12855277;     CeBgdrAMNz12855277 = CeBgdrAMNz39561104;     CeBgdrAMNz39561104 = CeBgdrAMNz12396446;     CeBgdrAMNz12396446 = CeBgdrAMNz32015885;     CeBgdrAMNz32015885 = CeBgdrAMNz13443711;     CeBgdrAMNz13443711 = CeBgdrAMNz15230100;     CeBgdrAMNz15230100 = CeBgdrAMNz30756796;     CeBgdrAMNz30756796 = CeBgdrAMNz77545850;     CeBgdrAMNz77545850 = CeBgdrAMNz24026852;     CeBgdrAMNz24026852 = CeBgdrAMNz62001981;     CeBgdrAMNz62001981 = CeBgdrAMNz12875825;     CeBgdrAMNz12875825 = CeBgdrAMNz53266105;     CeBgdrAMNz53266105 = CeBgdrAMNz40794411;     CeBgdrAMNz40794411 = CeBgdrAMNz41859666;     CeBgdrAMNz41859666 = CeBgdrAMNz49001662;     CeBgdrAMNz49001662 = CeBgdrAMNz7174099;     CeBgdrAMNz7174099 = CeBgdrAMNz76483710;     CeBgdrAMNz76483710 = CeBgdrAMNz8053581;     CeBgdrAMNz8053581 = CeBgdrAMNz66336288;     CeBgdrAMNz66336288 = CeBgdrAMNz64356700;     CeBgdrAMNz64356700 = CeBgdrAMNz56251193;     CeBgdrAMNz56251193 = CeBgdrAMNz59267422;     CeBgdrAMNz59267422 = CeBgdrAMNz13827152;     CeBgdrAMNz13827152 = CeBgdrAMNz30476847;     CeBgdrAMNz30476847 = CeBgdrAMNz9418720;     CeBgdrAMNz9418720 = CeBgdrAMNz63578847;     CeBgdrAMNz63578847 = CeBgdrAMNz59228535;     CeBgdrAMNz59228535 = CeBgdrAMNz32430195;     CeBgdrAMNz32430195 = CeBgdrAMNz30836975;     CeBgdrAMNz30836975 = CeBgdrAMNz12666136;     CeBgdrAMNz12666136 = CeBgdrAMNz65698166;     CeBgdrAMNz65698166 = CeBgdrAMNz49176859;     CeBgdrAMNz49176859 = CeBgdrAMNz27299827;     CeBgdrAMNz27299827 = CeBgdrAMNz49763795;     CeBgdrAMNz49763795 = CeBgdrAMNz18193962;     CeBgdrAMNz18193962 = CeBgdrAMNz10132849;     CeBgdrAMNz10132849 = CeBgdrAMNz73079049;     CeBgdrAMNz73079049 = CeBgdrAMNz61360800;     CeBgdrAMNz61360800 = CeBgdrAMNz89006121;     CeBgdrAMNz89006121 = CeBgdrAMNz5568970;     CeBgdrAMNz5568970 = CeBgdrAMNz14983914;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void jAHTJZkIti63271420() {     double dbGXguPTwl74580010 = -7247196;    double dbGXguPTwl93387915 = -163851783;    double dbGXguPTwl54596304 = -322541218;    double dbGXguPTwl36020859 = -134496744;    double dbGXguPTwl99771770 = -104367898;    double dbGXguPTwl62153917 = -353287143;    double dbGXguPTwl70759095 = -638206709;    double dbGXguPTwl78950684 = -744806589;    double dbGXguPTwl54420746 = -985672391;    double dbGXguPTwl72797019 = -201348603;    double dbGXguPTwl97013667 = -646504550;    double dbGXguPTwl96587137 = -288445451;    double dbGXguPTwl53576055 = -200822538;    double dbGXguPTwl40190345 = -138243591;    double dbGXguPTwl6386607 = -256096740;    double dbGXguPTwl89266497 = -215906492;    double dbGXguPTwl50512350 = -645142814;    double dbGXguPTwl51153165 = -468220513;    double dbGXguPTwl53351107 = -890550813;    double dbGXguPTwl78612724 = -13895153;    double dbGXguPTwl73110712 = -217003615;    double dbGXguPTwl38349994 = -910809267;    double dbGXguPTwl2695238 = -250497453;    double dbGXguPTwl51865596 = -439370355;    double dbGXguPTwl82137790 = -496795620;    double dbGXguPTwl86966823 = -433928857;    double dbGXguPTwl64961591 = -63850940;    double dbGXguPTwl98950678 = -620044810;    double dbGXguPTwl65513298 = -529269864;    double dbGXguPTwl47064884 = -619426299;    double dbGXguPTwl1243112 = -170173793;    double dbGXguPTwl99253896 = -150865984;    double dbGXguPTwl80241178 = -770424819;    double dbGXguPTwl87800084 = -933443425;    double dbGXguPTwl62727015 = -61795461;    double dbGXguPTwl25666716 = -239197062;    double dbGXguPTwl70268096 = -292436697;    double dbGXguPTwl59645479 = -330467851;    double dbGXguPTwl64708365 = -79600337;    double dbGXguPTwl3874893 = -575247568;    double dbGXguPTwl7911767 = -460805153;    double dbGXguPTwl55554676 = -962832322;    double dbGXguPTwl34255927 = -923712796;    double dbGXguPTwl76689337 = -724618263;    double dbGXguPTwl21787384 = 37971532;    double dbGXguPTwl6596214 = -226840133;    double dbGXguPTwl41789446 = 43733804;    double dbGXguPTwl39050492 = -698369892;    double dbGXguPTwl59402005 = -72965660;    double dbGXguPTwl419502 = -610585285;    double dbGXguPTwl49658949 = -957720352;    double dbGXguPTwl19335099 = 31510699;    double dbGXguPTwl72675615 = -813548471;    double dbGXguPTwl72003468 = -829615124;    double dbGXguPTwl90160708 = -418692636;    double dbGXguPTwl36230017 = -96437929;    double dbGXguPTwl90692677 = -913354330;    double dbGXguPTwl2730709 = -883170864;    double dbGXguPTwl53883068 = -637701124;    double dbGXguPTwl12804947 = -670439041;    double dbGXguPTwl97192326 = -189436204;    double dbGXguPTwl71808417 = 81838101;    double dbGXguPTwl13437387 = -115536726;    double dbGXguPTwl7355862 = -266246092;    double dbGXguPTwl71553908 = 68825189;    double dbGXguPTwl97759770 = -395638566;    double dbGXguPTwl16345959 = -518020633;    double dbGXguPTwl65775971 = -267379113;    double dbGXguPTwl77463330 = 23551870;    double dbGXguPTwl80719890 = 83100322;    double dbGXguPTwl18998401 = -923469796;    double dbGXguPTwl90866870 = -214674964;    double dbGXguPTwl86444799 = -288620177;    double dbGXguPTwl49476215 = -215303245;    double dbGXguPTwl70700958 = -553090000;    double dbGXguPTwl17556036 = -254171294;    double dbGXguPTwl4094067 = -987096472;    double dbGXguPTwl26005901 = -525879191;    double dbGXguPTwl30078212 = -377341887;    double dbGXguPTwl75541576 = -169955488;    double dbGXguPTwl45177378 = -377662662;    double dbGXguPTwl25911099 = -365481048;    double dbGXguPTwl39548673 = -447079151;    double dbGXguPTwl65093797 = -918684579;    double dbGXguPTwl97405935 = -661705948;    double dbGXguPTwl81908012 = -101684493;    double dbGXguPTwl26578281 = -337317514;    double dbGXguPTwl8237711 = -940809695;    double dbGXguPTwl97639375 = -414750789;    double dbGXguPTwl26496999 = -965357532;    double dbGXguPTwl34974038 = -325842732;    double dbGXguPTwl67537388 = -409265833;    double dbGXguPTwl5762411 = -692766728;    double dbGXguPTwl51903418 = -409161296;    double dbGXguPTwl6682566 = -285811365;    double dbGXguPTwl36103349 = -442643254;    double dbGXguPTwl42117290 = -747295597;    double dbGXguPTwl26900065 = -557466704;    double dbGXguPTwl5135430 = -693443453;    double dbGXguPTwl24027614 = -7247196;     dbGXguPTwl74580010 = dbGXguPTwl93387915;     dbGXguPTwl93387915 = dbGXguPTwl54596304;     dbGXguPTwl54596304 = dbGXguPTwl36020859;     dbGXguPTwl36020859 = dbGXguPTwl99771770;     dbGXguPTwl99771770 = dbGXguPTwl62153917;     dbGXguPTwl62153917 = dbGXguPTwl70759095;     dbGXguPTwl70759095 = dbGXguPTwl78950684;     dbGXguPTwl78950684 = dbGXguPTwl54420746;     dbGXguPTwl54420746 = dbGXguPTwl72797019;     dbGXguPTwl72797019 = dbGXguPTwl97013667;     dbGXguPTwl97013667 = dbGXguPTwl96587137;     dbGXguPTwl96587137 = dbGXguPTwl53576055;     dbGXguPTwl53576055 = dbGXguPTwl40190345;     dbGXguPTwl40190345 = dbGXguPTwl6386607;     dbGXguPTwl6386607 = dbGXguPTwl89266497;     dbGXguPTwl89266497 = dbGXguPTwl50512350;     dbGXguPTwl50512350 = dbGXguPTwl51153165;     dbGXguPTwl51153165 = dbGXguPTwl53351107;     dbGXguPTwl53351107 = dbGXguPTwl78612724;     dbGXguPTwl78612724 = dbGXguPTwl73110712;     dbGXguPTwl73110712 = dbGXguPTwl38349994;     dbGXguPTwl38349994 = dbGXguPTwl2695238;     dbGXguPTwl2695238 = dbGXguPTwl51865596;     dbGXguPTwl51865596 = dbGXguPTwl82137790;     dbGXguPTwl82137790 = dbGXguPTwl86966823;     dbGXguPTwl86966823 = dbGXguPTwl64961591;     dbGXguPTwl64961591 = dbGXguPTwl98950678;     dbGXguPTwl98950678 = dbGXguPTwl65513298;     dbGXguPTwl65513298 = dbGXguPTwl47064884;     dbGXguPTwl47064884 = dbGXguPTwl1243112;     dbGXguPTwl1243112 = dbGXguPTwl99253896;     dbGXguPTwl99253896 = dbGXguPTwl80241178;     dbGXguPTwl80241178 = dbGXguPTwl87800084;     dbGXguPTwl87800084 = dbGXguPTwl62727015;     dbGXguPTwl62727015 = dbGXguPTwl25666716;     dbGXguPTwl25666716 = dbGXguPTwl70268096;     dbGXguPTwl70268096 = dbGXguPTwl59645479;     dbGXguPTwl59645479 = dbGXguPTwl64708365;     dbGXguPTwl64708365 = dbGXguPTwl3874893;     dbGXguPTwl3874893 = dbGXguPTwl7911767;     dbGXguPTwl7911767 = dbGXguPTwl55554676;     dbGXguPTwl55554676 = dbGXguPTwl34255927;     dbGXguPTwl34255927 = dbGXguPTwl76689337;     dbGXguPTwl76689337 = dbGXguPTwl21787384;     dbGXguPTwl21787384 = dbGXguPTwl6596214;     dbGXguPTwl6596214 = dbGXguPTwl41789446;     dbGXguPTwl41789446 = dbGXguPTwl39050492;     dbGXguPTwl39050492 = dbGXguPTwl59402005;     dbGXguPTwl59402005 = dbGXguPTwl419502;     dbGXguPTwl419502 = dbGXguPTwl49658949;     dbGXguPTwl49658949 = dbGXguPTwl19335099;     dbGXguPTwl19335099 = dbGXguPTwl72675615;     dbGXguPTwl72675615 = dbGXguPTwl72003468;     dbGXguPTwl72003468 = dbGXguPTwl90160708;     dbGXguPTwl90160708 = dbGXguPTwl36230017;     dbGXguPTwl36230017 = dbGXguPTwl90692677;     dbGXguPTwl90692677 = dbGXguPTwl2730709;     dbGXguPTwl2730709 = dbGXguPTwl53883068;     dbGXguPTwl53883068 = dbGXguPTwl12804947;     dbGXguPTwl12804947 = dbGXguPTwl97192326;     dbGXguPTwl97192326 = dbGXguPTwl71808417;     dbGXguPTwl71808417 = dbGXguPTwl13437387;     dbGXguPTwl13437387 = dbGXguPTwl7355862;     dbGXguPTwl7355862 = dbGXguPTwl71553908;     dbGXguPTwl71553908 = dbGXguPTwl97759770;     dbGXguPTwl97759770 = dbGXguPTwl16345959;     dbGXguPTwl16345959 = dbGXguPTwl65775971;     dbGXguPTwl65775971 = dbGXguPTwl77463330;     dbGXguPTwl77463330 = dbGXguPTwl80719890;     dbGXguPTwl80719890 = dbGXguPTwl18998401;     dbGXguPTwl18998401 = dbGXguPTwl90866870;     dbGXguPTwl90866870 = dbGXguPTwl86444799;     dbGXguPTwl86444799 = dbGXguPTwl49476215;     dbGXguPTwl49476215 = dbGXguPTwl70700958;     dbGXguPTwl70700958 = dbGXguPTwl17556036;     dbGXguPTwl17556036 = dbGXguPTwl4094067;     dbGXguPTwl4094067 = dbGXguPTwl26005901;     dbGXguPTwl26005901 = dbGXguPTwl30078212;     dbGXguPTwl30078212 = dbGXguPTwl75541576;     dbGXguPTwl75541576 = dbGXguPTwl45177378;     dbGXguPTwl45177378 = dbGXguPTwl25911099;     dbGXguPTwl25911099 = dbGXguPTwl39548673;     dbGXguPTwl39548673 = dbGXguPTwl65093797;     dbGXguPTwl65093797 = dbGXguPTwl97405935;     dbGXguPTwl97405935 = dbGXguPTwl81908012;     dbGXguPTwl81908012 = dbGXguPTwl26578281;     dbGXguPTwl26578281 = dbGXguPTwl8237711;     dbGXguPTwl8237711 = dbGXguPTwl97639375;     dbGXguPTwl97639375 = dbGXguPTwl26496999;     dbGXguPTwl26496999 = dbGXguPTwl34974038;     dbGXguPTwl34974038 = dbGXguPTwl67537388;     dbGXguPTwl67537388 = dbGXguPTwl5762411;     dbGXguPTwl5762411 = dbGXguPTwl51903418;     dbGXguPTwl51903418 = dbGXguPTwl6682566;     dbGXguPTwl6682566 = dbGXguPTwl36103349;     dbGXguPTwl36103349 = dbGXguPTwl42117290;     dbGXguPTwl42117290 = dbGXguPTwl26900065;     dbGXguPTwl26900065 = dbGXguPTwl5135430;     dbGXguPTwl5135430 = dbGXguPTwl24027614;     dbGXguPTwl24027614 = dbGXguPTwl74580010;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void FvMIapcIDt23574078() {     double NTdopSEazG64706319 = -66003397;    double NTdopSEazG76512980 = -538777953;    double NTdopSEazG50089003 = -459335679;    double NTdopSEazG9519434 = -320668566;    double NTdopSEazG12828506 = -45691340;    double NTdopSEazG42940322 = -245920251;    double NTdopSEazG65422534 = -275752182;    double NTdopSEazG31829248 = -381254328;    double NTdopSEazG78232433 = -993565028;    double NTdopSEazG77052689 = -871223129;    double NTdopSEazG73165486 = -54924707;    double NTdopSEazG31336645 = -868033587;    double NTdopSEazG91922187 = -513058398;    double NTdopSEazG78609199 = -136404475;    double NTdopSEazG4460978 = -741217682;    double NTdopSEazG13446239 = 83713638;    double NTdopSEazG94474530 = -906488056;    double NTdopSEazG72508877 = -911069806;    double NTdopSEazG14265499 = -256961249;    double NTdopSEazG45936972 = -661773462;    double NTdopSEazG61033114 = 78571293;    double NTdopSEazG36431576 = -143905903;    double NTdopSEazG35933656 = -656957374;    double NTdopSEazG59786693 = -887394730;    double NTdopSEazG29022979 = -40306564;    double NTdopSEazG5757789 = -309802592;    double NTdopSEazG86928925 = -923379934;    double NTdopSEazG22121054 = -679934868;    double NTdopSEazG26722296 = -191468912;    double NTdopSEazG94853964 = -493828690;    double NTdopSEazG4706514 = -496840337;    double NTdopSEazG98620810 = -651690404;    double NTdopSEazG89210219 = 29350021;    double NTdopSEazG11638729 = -924894583;    double NTdopSEazG98323549 = -812131122;    double NTdopSEazG78897722 = -542226472;    double NTdopSEazG70501665 = -908252601;    double NTdopSEazG84002762 = -196527095;    double NTdopSEazG75241382 = -887062382;    double NTdopSEazG48387034 = -479955341;    double NTdopSEazG21611440 = -166666428;    double NTdopSEazG10199140 = -777325535;    double NTdopSEazG94072768 = -299138391;    double NTdopSEazG7351279 = -588701452;    double NTdopSEazG13751802 = -74538424;    double NTdopSEazG27035208 = -710464038;    double NTdopSEazG22212736 = -604748696;    double NTdopSEazG29436951 = -725026145;    double NTdopSEazG87320658 = -508905006;    double NTdopSEazG29699907 = 32418378;    double NTdopSEazG79024472 = -232102396;    double NTdopSEazG63108206 = 67083866;    double NTdopSEazG22128071 = -525401465;    double NTdopSEazG24910530 = -953170406;    double NTdopSEazG62540963 = -547292907;    double NTdopSEazG28274744 = -922097495;    double NTdopSEazG40579325 = -881820579;    double NTdopSEazG90302309 = -571940950;    double NTdopSEazG80496455 = -180362002;    double NTdopSEazG7070718 = -735888748;    double NTdopSEazG56011396 = -322540318;    double NTdopSEazG43301481 = -595817314;    double NTdopSEazG5106953 = -89785416;    double NTdopSEazG83378469 = -399736338;    double NTdopSEazG72346175 = -274382792;    double NTdopSEazG74544675 = -403234304;    double NTdopSEazG42126425 = -797383609;    double NTdopSEazG80283458 = -588163816;    double NTdopSEazG80285649 = -324273354;    double NTdopSEazG25563256 = -98991211;    double NTdopSEazG42944574 = -8033762;    double NTdopSEazG10471768 = -609960961;    double NTdopSEazG97267494 = 75992576;    double NTdopSEazG65878464 = -777005908;    double NTdopSEazG24325533 = -395107034;    double NTdopSEazG50833975 = -144103173;    double NTdopSEazG42358808 = -844767512;    double NTdopSEazG28582378 = 31744077;    double NTdopSEazG46034891 = -712856307;    double NTdopSEazG1987772 = -329842526;    double NTdopSEazG83545052 = -705053897;    double NTdopSEazG57491975 = -98353789;    double NTdopSEazG34800395 = -71029863;    double NTdopSEazG97022388 = -123887290;    double NTdopSEazG15829492 = -161726295;    double NTdopSEazG41598308 = -463924204;    double NTdopSEazG76492740 = -26288939;    double NTdopSEazG64299689 = -17479573;    double NTdopSEazG49097766 = -277601676;    double NTdopSEazG70048806 = -890033628;    double NTdopSEazG38318398 = -660405893;    double NTdopSEazG80199355 = -236311652;    double NTdopSEazG3506308 = 83834906;    double NTdopSEazG68170665 = -51173634;    double NTdopSEazG92375637 = -57415024;    double NTdopSEazG78309959 = -570849115;    double NTdopSEazG5092188 = -587540119;    double NTdopSEazG10694299 = -899402053;    double NTdopSEazG35005103 = -214318660;    double NTdopSEazG39207126 = -66003397;     NTdopSEazG64706319 = NTdopSEazG76512980;     NTdopSEazG76512980 = NTdopSEazG50089003;     NTdopSEazG50089003 = NTdopSEazG9519434;     NTdopSEazG9519434 = NTdopSEazG12828506;     NTdopSEazG12828506 = NTdopSEazG42940322;     NTdopSEazG42940322 = NTdopSEazG65422534;     NTdopSEazG65422534 = NTdopSEazG31829248;     NTdopSEazG31829248 = NTdopSEazG78232433;     NTdopSEazG78232433 = NTdopSEazG77052689;     NTdopSEazG77052689 = NTdopSEazG73165486;     NTdopSEazG73165486 = NTdopSEazG31336645;     NTdopSEazG31336645 = NTdopSEazG91922187;     NTdopSEazG91922187 = NTdopSEazG78609199;     NTdopSEazG78609199 = NTdopSEazG4460978;     NTdopSEazG4460978 = NTdopSEazG13446239;     NTdopSEazG13446239 = NTdopSEazG94474530;     NTdopSEazG94474530 = NTdopSEazG72508877;     NTdopSEazG72508877 = NTdopSEazG14265499;     NTdopSEazG14265499 = NTdopSEazG45936972;     NTdopSEazG45936972 = NTdopSEazG61033114;     NTdopSEazG61033114 = NTdopSEazG36431576;     NTdopSEazG36431576 = NTdopSEazG35933656;     NTdopSEazG35933656 = NTdopSEazG59786693;     NTdopSEazG59786693 = NTdopSEazG29022979;     NTdopSEazG29022979 = NTdopSEazG5757789;     NTdopSEazG5757789 = NTdopSEazG86928925;     NTdopSEazG86928925 = NTdopSEazG22121054;     NTdopSEazG22121054 = NTdopSEazG26722296;     NTdopSEazG26722296 = NTdopSEazG94853964;     NTdopSEazG94853964 = NTdopSEazG4706514;     NTdopSEazG4706514 = NTdopSEazG98620810;     NTdopSEazG98620810 = NTdopSEazG89210219;     NTdopSEazG89210219 = NTdopSEazG11638729;     NTdopSEazG11638729 = NTdopSEazG98323549;     NTdopSEazG98323549 = NTdopSEazG78897722;     NTdopSEazG78897722 = NTdopSEazG70501665;     NTdopSEazG70501665 = NTdopSEazG84002762;     NTdopSEazG84002762 = NTdopSEazG75241382;     NTdopSEazG75241382 = NTdopSEazG48387034;     NTdopSEazG48387034 = NTdopSEazG21611440;     NTdopSEazG21611440 = NTdopSEazG10199140;     NTdopSEazG10199140 = NTdopSEazG94072768;     NTdopSEazG94072768 = NTdopSEazG7351279;     NTdopSEazG7351279 = NTdopSEazG13751802;     NTdopSEazG13751802 = NTdopSEazG27035208;     NTdopSEazG27035208 = NTdopSEazG22212736;     NTdopSEazG22212736 = NTdopSEazG29436951;     NTdopSEazG29436951 = NTdopSEazG87320658;     NTdopSEazG87320658 = NTdopSEazG29699907;     NTdopSEazG29699907 = NTdopSEazG79024472;     NTdopSEazG79024472 = NTdopSEazG63108206;     NTdopSEazG63108206 = NTdopSEazG22128071;     NTdopSEazG22128071 = NTdopSEazG24910530;     NTdopSEazG24910530 = NTdopSEazG62540963;     NTdopSEazG62540963 = NTdopSEazG28274744;     NTdopSEazG28274744 = NTdopSEazG40579325;     NTdopSEazG40579325 = NTdopSEazG90302309;     NTdopSEazG90302309 = NTdopSEazG80496455;     NTdopSEazG80496455 = NTdopSEazG7070718;     NTdopSEazG7070718 = NTdopSEazG56011396;     NTdopSEazG56011396 = NTdopSEazG43301481;     NTdopSEazG43301481 = NTdopSEazG5106953;     NTdopSEazG5106953 = NTdopSEazG83378469;     NTdopSEazG83378469 = NTdopSEazG72346175;     NTdopSEazG72346175 = NTdopSEazG74544675;     NTdopSEazG74544675 = NTdopSEazG42126425;     NTdopSEazG42126425 = NTdopSEazG80283458;     NTdopSEazG80283458 = NTdopSEazG80285649;     NTdopSEazG80285649 = NTdopSEazG25563256;     NTdopSEazG25563256 = NTdopSEazG42944574;     NTdopSEazG42944574 = NTdopSEazG10471768;     NTdopSEazG10471768 = NTdopSEazG97267494;     NTdopSEazG97267494 = NTdopSEazG65878464;     NTdopSEazG65878464 = NTdopSEazG24325533;     NTdopSEazG24325533 = NTdopSEazG50833975;     NTdopSEazG50833975 = NTdopSEazG42358808;     NTdopSEazG42358808 = NTdopSEazG28582378;     NTdopSEazG28582378 = NTdopSEazG46034891;     NTdopSEazG46034891 = NTdopSEazG1987772;     NTdopSEazG1987772 = NTdopSEazG83545052;     NTdopSEazG83545052 = NTdopSEazG57491975;     NTdopSEazG57491975 = NTdopSEazG34800395;     NTdopSEazG34800395 = NTdopSEazG97022388;     NTdopSEazG97022388 = NTdopSEazG15829492;     NTdopSEazG15829492 = NTdopSEazG41598308;     NTdopSEazG41598308 = NTdopSEazG76492740;     NTdopSEazG76492740 = NTdopSEazG64299689;     NTdopSEazG64299689 = NTdopSEazG49097766;     NTdopSEazG49097766 = NTdopSEazG70048806;     NTdopSEazG70048806 = NTdopSEazG38318398;     NTdopSEazG38318398 = NTdopSEazG80199355;     NTdopSEazG80199355 = NTdopSEazG3506308;     NTdopSEazG3506308 = NTdopSEazG68170665;     NTdopSEazG68170665 = NTdopSEazG92375637;     NTdopSEazG92375637 = NTdopSEazG78309959;     NTdopSEazG78309959 = NTdopSEazG5092188;     NTdopSEazG5092188 = NTdopSEazG10694299;     NTdopSEazG10694299 = NTdopSEazG35005103;     NTdopSEazG35005103 = NTdopSEazG39207126;     NTdopSEazG39207126 = NTdopSEazG64706319;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void Aihqztrtti36119267() {     double dJxKrRngJx84174489 = -479134609;    double dJxKrRngJx29536845 = 15344051;    double dJxKrRngJx66925994 = -110964294;    double dJxKrRngJx28166583 = -137242829;    double dJxKrRngJx13275023 = -671963756;    double dJxKrRngJx68532396 = -136405019;    double dJxKrRngJx10254413 = -719058412;    double dJxKrRngJx97079481 = -475062293;    double dJxKrRngJx38919231 = -621756407;    double dJxKrRngJx54981412 = -876809175;    double dJxKrRngJx27388750 = -487915007;    double dJxKrRngJx34831258 = -867336291;    double dJxKrRngJx82293847 = -937415675;    double dJxKrRngJx87025239 = -678690201;    double dJxKrRngJx64987439 = 60698526;    double dJxKrRngJx79661888 = -379478296;    double dJxKrRngJx436644 = 21737263;    double dJxKrRngJx96571628 = -661824524;    double dJxKrRngJx13900378 = -634166009;    double dJxKrRngJx26548274 = -279309918;    double dJxKrRngJx73489186 = -527641033;    double dJxKrRngJx51413659 = -655709116;    double dJxKrRngJx4106663 = -954531993;    double dJxKrRngJx77508361 = -523938722;    double dJxKrRngJx40226468 = -334606674;    double dJxKrRngJx10525250 = 4402190;    double dJxKrRngJx70857056 = -588530865;    double dJxKrRngJx72912728 = -843668147;    double dJxKrRngJx68467253 = -205380058;    double dJxKrRngJx79560818 = -585267385;    double dJxKrRngJx34510599 = -362166430;    double dJxKrRngJx38200121 = -116039422;    double dJxKrRngJx686323 = -525857745;    double dJxKrRngJx70395236 = -129497789;    double dJxKrRngJx38253886 = -874833928;    double dJxKrRngJx14963660 = -845795080;    double dJxKrRngJx38885116 = -335128676;    double dJxKrRngJx25485237 = -273735910;    double dJxKrRngJx42554707 = -251477207;    double dJxKrRngJx69668770 = -476486438;    double dJxKrRngJx63093496 = -676452724;    double dJxKrRngJx22058273 = 83778239;    double dJxKrRngJx65206009 = -246940189;    double dJxKrRngJx90736817 = 62225888;    double dJxKrRngJx93780212 = -351661387;    double dJxKrRngJx81496334 = -147795460;    double dJxKrRngJx4202616 = -518442018;    double dJxKrRngJx29592781 = -908313460;    double dJxKrRngJx28456250 = -522844245;    double dJxKrRngJx70598249 = -828593967;    double dJxKrRngJx53460042 = -638467327;    double dJxKrRngJx79557066 = -310268993;    double dJxKrRngJx91953217 = -201510426;    double dJxKrRngJx97840558 = -947764042;    double dJxKrRngJx62630080 = -321851542;    double dJxKrRngJx32760831 = -823425494;    double dJxKrRngJx25430182 = -30123957;    double dJxKrRngJx89417633 = -587025573;    double dJxKrRngJx87940114 = -802636155;    double dJxKrRngJx2749773 = -576365946;    double dJxKrRngJx97675339 = -547874154;    double dJxKrRngJx37341684 = -875390265;    double dJxKrRngJx28612229 = -169682236;    double dJxKrRngJx59358412 = 63510977;    double dJxKrRngJx20470814 = -414642745;    double dJxKrRngJx89188628 = -271875585;    double dJxKrRngJx34144936 = -241478547;    double dJxKrRngJx11898611 = -707917886;    double dJxKrRngJx48771353 = -803856273;    double dJxKrRngJx50023780 = -93506394;    double dJxKrRngJx40776773 = 55650379;    double dJxKrRngJx74951407 = -704526827;    double dJxKrRngJx54016921 = -310347317;    double dJxKrRngJx44231607 = -57679572;    double dJxKrRngJx63454777 = -602857195;    double dJxKrRngJx51430914 = -511419272;    double dJxKrRngJx86207649 = -308768927;    double dJxKrRngJx13369845 = -916757881;    double dJxKrRngJx83728148 = -72277336;    double dJxKrRngJx58730133 = -86811214;    double dJxKrRngJx6322634 = -477155793;    double dJxKrRngJx41264276 = -680217406;    double dJxKrRngJx44456478 = -220823903;    double dJxKrRngJx97869003 = -376786091;    double dJxKrRngJx26100777 = -946800058;    double dJxKrRngJx54953533 = 48102563;    double dJxKrRngJx46246904 = -914528996;    double dJxKrRngJx2845765 = -578093703;    double dJxKrRngJx7765156 = -807646247;    double dJxKrRngJx5493056 = 48591565;    double dJxKrRngJx89533477 = -715671124;    double dJxKrRngJx49467483 = -748103104;    double dJxKrRngJx37545122 = -471099755;    double dJxKrRngJx39804935 = -675111262;    double dJxKrRngJx71993430 = -928612284;    double dJxKrRngJx25751813 = -801062460;    double dJxKrRngJx93446044 = -746539525;    double dJxKrRngJx5847597 = -210451166;    double dJxKrRngJx70266003 = -523131368;    double dJxKrRngJx4591585 = -479134609;     dJxKrRngJx84174489 = dJxKrRngJx29536845;     dJxKrRngJx29536845 = dJxKrRngJx66925994;     dJxKrRngJx66925994 = dJxKrRngJx28166583;     dJxKrRngJx28166583 = dJxKrRngJx13275023;     dJxKrRngJx13275023 = dJxKrRngJx68532396;     dJxKrRngJx68532396 = dJxKrRngJx10254413;     dJxKrRngJx10254413 = dJxKrRngJx97079481;     dJxKrRngJx97079481 = dJxKrRngJx38919231;     dJxKrRngJx38919231 = dJxKrRngJx54981412;     dJxKrRngJx54981412 = dJxKrRngJx27388750;     dJxKrRngJx27388750 = dJxKrRngJx34831258;     dJxKrRngJx34831258 = dJxKrRngJx82293847;     dJxKrRngJx82293847 = dJxKrRngJx87025239;     dJxKrRngJx87025239 = dJxKrRngJx64987439;     dJxKrRngJx64987439 = dJxKrRngJx79661888;     dJxKrRngJx79661888 = dJxKrRngJx436644;     dJxKrRngJx436644 = dJxKrRngJx96571628;     dJxKrRngJx96571628 = dJxKrRngJx13900378;     dJxKrRngJx13900378 = dJxKrRngJx26548274;     dJxKrRngJx26548274 = dJxKrRngJx73489186;     dJxKrRngJx73489186 = dJxKrRngJx51413659;     dJxKrRngJx51413659 = dJxKrRngJx4106663;     dJxKrRngJx4106663 = dJxKrRngJx77508361;     dJxKrRngJx77508361 = dJxKrRngJx40226468;     dJxKrRngJx40226468 = dJxKrRngJx10525250;     dJxKrRngJx10525250 = dJxKrRngJx70857056;     dJxKrRngJx70857056 = dJxKrRngJx72912728;     dJxKrRngJx72912728 = dJxKrRngJx68467253;     dJxKrRngJx68467253 = dJxKrRngJx79560818;     dJxKrRngJx79560818 = dJxKrRngJx34510599;     dJxKrRngJx34510599 = dJxKrRngJx38200121;     dJxKrRngJx38200121 = dJxKrRngJx686323;     dJxKrRngJx686323 = dJxKrRngJx70395236;     dJxKrRngJx70395236 = dJxKrRngJx38253886;     dJxKrRngJx38253886 = dJxKrRngJx14963660;     dJxKrRngJx14963660 = dJxKrRngJx38885116;     dJxKrRngJx38885116 = dJxKrRngJx25485237;     dJxKrRngJx25485237 = dJxKrRngJx42554707;     dJxKrRngJx42554707 = dJxKrRngJx69668770;     dJxKrRngJx69668770 = dJxKrRngJx63093496;     dJxKrRngJx63093496 = dJxKrRngJx22058273;     dJxKrRngJx22058273 = dJxKrRngJx65206009;     dJxKrRngJx65206009 = dJxKrRngJx90736817;     dJxKrRngJx90736817 = dJxKrRngJx93780212;     dJxKrRngJx93780212 = dJxKrRngJx81496334;     dJxKrRngJx81496334 = dJxKrRngJx4202616;     dJxKrRngJx4202616 = dJxKrRngJx29592781;     dJxKrRngJx29592781 = dJxKrRngJx28456250;     dJxKrRngJx28456250 = dJxKrRngJx70598249;     dJxKrRngJx70598249 = dJxKrRngJx53460042;     dJxKrRngJx53460042 = dJxKrRngJx79557066;     dJxKrRngJx79557066 = dJxKrRngJx91953217;     dJxKrRngJx91953217 = dJxKrRngJx97840558;     dJxKrRngJx97840558 = dJxKrRngJx62630080;     dJxKrRngJx62630080 = dJxKrRngJx32760831;     dJxKrRngJx32760831 = dJxKrRngJx25430182;     dJxKrRngJx25430182 = dJxKrRngJx89417633;     dJxKrRngJx89417633 = dJxKrRngJx87940114;     dJxKrRngJx87940114 = dJxKrRngJx2749773;     dJxKrRngJx2749773 = dJxKrRngJx97675339;     dJxKrRngJx97675339 = dJxKrRngJx37341684;     dJxKrRngJx37341684 = dJxKrRngJx28612229;     dJxKrRngJx28612229 = dJxKrRngJx59358412;     dJxKrRngJx59358412 = dJxKrRngJx20470814;     dJxKrRngJx20470814 = dJxKrRngJx89188628;     dJxKrRngJx89188628 = dJxKrRngJx34144936;     dJxKrRngJx34144936 = dJxKrRngJx11898611;     dJxKrRngJx11898611 = dJxKrRngJx48771353;     dJxKrRngJx48771353 = dJxKrRngJx50023780;     dJxKrRngJx50023780 = dJxKrRngJx40776773;     dJxKrRngJx40776773 = dJxKrRngJx74951407;     dJxKrRngJx74951407 = dJxKrRngJx54016921;     dJxKrRngJx54016921 = dJxKrRngJx44231607;     dJxKrRngJx44231607 = dJxKrRngJx63454777;     dJxKrRngJx63454777 = dJxKrRngJx51430914;     dJxKrRngJx51430914 = dJxKrRngJx86207649;     dJxKrRngJx86207649 = dJxKrRngJx13369845;     dJxKrRngJx13369845 = dJxKrRngJx83728148;     dJxKrRngJx83728148 = dJxKrRngJx58730133;     dJxKrRngJx58730133 = dJxKrRngJx6322634;     dJxKrRngJx6322634 = dJxKrRngJx41264276;     dJxKrRngJx41264276 = dJxKrRngJx44456478;     dJxKrRngJx44456478 = dJxKrRngJx97869003;     dJxKrRngJx97869003 = dJxKrRngJx26100777;     dJxKrRngJx26100777 = dJxKrRngJx54953533;     dJxKrRngJx54953533 = dJxKrRngJx46246904;     dJxKrRngJx46246904 = dJxKrRngJx2845765;     dJxKrRngJx2845765 = dJxKrRngJx7765156;     dJxKrRngJx7765156 = dJxKrRngJx5493056;     dJxKrRngJx5493056 = dJxKrRngJx89533477;     dJxKrRngJx89533477 = dJxKrRngJx49467483;     dJxKrRngJx49467483 = dJxKrRngJx37545122;     dJxKrRngJx37545122 = dJxKrRngJx39804935;     dJxKrRngJx39804935 = dJxKrRngJx71993430;     dJxKrRngJx71993430 = dJxKrRngJx25751813;     dJxKrRngJx25751813 = dJxKrRngJx93446044;     dJxKrRngJx93446044 = dJxKrRngJx5847597;     dJxKrRngJx5847597 = dJxKrRngJx70266003;     dJxKrRngJx70266003 = dJxKrRngJx4591585;     dJxKrRngJx4591585 = dJxKrRngJx84174489;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void xTIDgJNRZL96421924() {     double DEfIUJDWYZ74300798 = -537890810;    double DEfIUJDWYZ12661910 = -359582119;    double DEfIUJDWYZ62418693 = -247758755;    double DEfIUJDWYZ1665158 = -323414651;    double DEfIUJDWYZ26331758 = -613287198;    double DEfIUJDWYZ49318801 = -29038127;    double DEfIUJDWYZ4917851 = -356603885;    double DEfIUJDWYZ49958045 = -111510032;    double DEfIUJDWYZ62730918 = -629649045;    double DEfIUJDWYZ59237083 = -446683700;    double DEfIUJDWYZ3540569 = -996335164;    double DEfIUJDWYZ69580765 = -346924427;    double DEfIUJDWYZ20639980 = -149651535;    double DEfIUJDWYZ25444093 = -676851085;    double DEfIUJDWYZ63061811 = -424422416;    double DEfIUJDWYZ3841631 = -79858166;    double DEfIUJDWYZ44398824 = -239607979;    double DEfIUJDWYZ17927342 = -4673816;    double DEfIUJDWYZ74814768 = -576445;    double DEfIUJDWYZ93872522 = -927188228;    double DEfIUJDWYZ61411589 = -232066125;    double DEfIUJDWYZ49495241 = -988805751;    double DEfIUJDWYZ37345080 = -260991914;    double DEfIUJDWYZ85429459 = -971963098;    double DEfIUJDWYZ87111655 = -978117618;    double DEfIUJDWYZ29316215 = -971471545;    double DEfIUJDWYZ92824391 = -348059859;    double DEfIUJDWYZ96083103 = -903558206;    double DEfIUJDWYZ29676251 = -967579106;    double DEfIUJDWYZ27349898 = -459669776;    double DEfIUJDWYZ37974002 = -688832974;    double DEfIUJDWYZ37567035 = -616863842;    double DEfIUJDWYZ9655364 = -826082905;    double DEfIUJDWYZ94233880 = -120948947;    double DEfIUJDWYZ73850420 = -525169589;    double DEfIUJDWYZ68194666 = -48824490;    double DEfIUJDWYZ39118684 = -950944580;    double DEfIUJDWYZ49842520 = -139795154;    double DEfIUJDWYZ53087724 = 41060747;    double DEfIUJDWYZ14180912 = -381194211;    double DEfIUJDWYZ76793170 = -382314000;    double DEfIUJDWYZ76702736 = -830714974;    double DEfIUJDWYZ25022850 = -722365784;    double DEfIUJDWYZ21398758 = -901857301;    double DEfIUJDWYZ85744630 = -464171343;    double DEfIUJDWYZ1935329 = -631419365;    double DEfIUJDWYZ84625906 = -66924518;    double DEfIUJDWYZ19979240 = -934969713;    double DEfIUJDWYZ56374904 = -958783591;    double DEfIUJDWYZ99878655 = -185590305;    double DEfIUJDWYZ82825565 = 87150628;    double DEfIUJDWYZ23330173 = -274695826;    double DEfIUJDWYZ41405672 = 86636579;    double DEfIUJDWYZ50747621 = 28680676;    double DEfIUJDWYZ35010335 = -450451814;    double DEfIUJDWYZ24805557 = -549085059;    double DEfIUJDWYZ75316829 = 1409794;    double DEfIUJDWYZ76989234 = -275795658;    double DEfIUJDWYZ14553502 = -345297033;    double DEfIUJDWYZ97015543 = -641815653;    double DEfIUJDWYZ56494409 = -680978269;    double DEfIUJDWYZ8834748 = -453045679;    double DEfIUJDWYZ20281794 = -143930927;    double DEfIUJDWYZ35381020 = -69979269;    double DEfIUJDWYZ21263081 = -757850727;    double DEfIUJDWYZ65973534 = -279471323;    double DEfIUJDWYZ59925402 = -520841522;    double DEfIUJDWYZ26406099 = 71297412;    double DEfIUJDWYZ51593672 = -51681497;    double DEfIUJDWYZ94867144 = -275597927;    double DEfIUJDWYZ64722946 = -128913587;    double DEfIUJDWYZ94556304 = 187175;    double DEfIUJDWYZ64839617 = 54265437;    double DEfIUJDWYZ60633857 = -619382235;    double DEfIUJDWYZ17079353 = -444874229;    double DEfIUJDWYZ84708853 = -401351152;    double DEfIUJDWYZ24472391 = -166439967;    double DEfIUJDWYZ15946323 = -359134613;    double DEfIUJDWYZ99684828 = -407791755;    double DEfIUJDWYZ85176327 = -246698253;    double DEfIUJDWYZ44690308 = -804547027;    double DEfIUJDWYZ72845151 = -413090147;    double DEfIUJDWYZ39708200 = -944774615;    double DEfIUJDWYZ29797596 = -681988802;    double DEfIUJDWYZ44524333 = -446820404;    double DEfIUJDWYZ14643829 = -314137148;    double DEfIUJDWYZ96161363 = -603500421;    double DEfIUJDWYZ58907743 = -754763581;    double DEfIUJDWYZ59223545 = -670497134;    double DEfIUJDWYZ49044863 = -976084530;    double DEfIUJDWYZ92877837 = 49765715;    double DEfIUJDWYZ62129450 = -575148922;    double DEfIUJDWYZ35289019 = -794498121;    double DEfIUJDWYZ56072181 = -317123600;    double DEfIUJDWYZ57686503 = -700215943;    double DEfIUJDWYZ67958423 = -929268321;    double DEfIUJDWYZ56420942 = -586784047;    double DEfIUJDWYZ89641830 = -552386515;    double DEfIUJDWYZ135678 = -44006575;    double DEfIUJDWYZ19771097 = -537890810;     DEfIUJDWYZ74300798 = DEfIUJDWYZ12661910;     DEfIUJDWYZ12661910 = DEfIUJDWYZ62418693;     DEfIUJDWYZ62418693 = DEfIUJDWYZ1665158;     DEfIUJDWYZ1665158 = DEfIUJDWYZ26331758;     DEfIUJDWYZ26331758 = DEfIUJDWYZ49318801;     DEfIUJDWYZ49318801 = DEfIUJDWYZ4917851;     DEfIUJDWYZ4917851 = DEfIUJDWYZ49958045;     DEfIUJDWYZ49958045 = DEfIUJDWYZ62730918;     DEfIUJDWYZ62730918 = DEfIUJDWYZ59237083;     DEfIUJDWYZ59237083 = DEfIUJDWYZ3540569;     DEfIUJDWYZ3540569 = DEfIUJDWYZ69580765;     DEfIUJDWYZ69580765 = DEfIUJDWYZ20639980;     DEfIUJDWYZ20639980 = DEfIUJDWYZ25444093;     DEfIUJDWYZ25444093 = DEfIUJDWYZ63061811;     DEfIUJDWYZ63061811 = DEfIUJDWYZ3841631;     DEfIUJDWYZ3841631 = DEfIUJDWYZ44398824;     DEfIUJDWYZ44398824 = DEfIUJDWYZ17927342;     DEfIUJDWYZ17927342 = DEfIUJDWYZ74814768;     DEfIUJDWYZ74814768 = DEfIUJDWYZ93872522;     DEfIUJDWYZ93872522 = DEfIUJDWYZ61411589;     DEfIUJDWYZ61411589 = DEfIUJDWYZ49495241;     DEfIUJDWYZ49495241 = DEfIUJDWYZ37345080;     DEfIUJDWYZ37345080 = DEfIUJDWYZ85429459;     DEfIUJDWYZ85429459 = DEfIUJDWYZ87111655;     DEfIUJDWYZ87111655 = DEfIUJDWYZ29316215;     DEfIUJDWYZ29316215 = DEfIUJDWYZ92824391;     DEfIUJDWYZ92824391 = DEfIUJDWYZ96083103;     DEfIUJDWYZ96083103 = DEfIUJDWYZ29676251;     DEfIUJDWYZ29676251 = DEfIUJDWYZ27349898;     DEfIUJDWYZ27349898 = DEfIUJDWYZ37974002;     DEfIUJDWYZ37974002 = DEfIUJDWYZ37567035;     DEfIUJDWYZ37567035 = DEfIUJDWYZ9655364;     DEfIUJDWYZ9655364 = DEfIUJDWYZ94233880;     DEfIUJDWYZ94233880 = DEfIUJDWYZ73850420;     DEfIUJDWYZ73850420 = DEfIUJDWYZ68194666;     DEfIUJDWYZ68194666 = DEfIUJDWYZ39118684;     DEfIUJDWYZ39118684 = DEfIUJDWYZ49842520;     DEfIUJDWYZ49842520 = DEfIUJDWYZ53087724;     DEfIUJDWYZ53087724 = DEfIUJDWYZ14180912;     DEfIUJDWYZ14180912 = DEfIUJDWYZ76793170;     DEfIUJDWYZ76793170 = DEfIUJDWYZ76702736;     DEfIUJDWYZ76702736 = DEfIUJDWYZ25022850;     DEfIUJDWYZ25022850 = DEfIUJDWYZ21398758;     DEfIUJDWYZ21398758 = DEfIUJDWYZ85744630;     DEfIUJDWYZ85744630 = DEfIUJDWYZ1935329;     DEfIUJDWYZ1935329 = DEfIUJDWYZ84625906;     DEfIUJDWYZ84625906 = DEfIUJDWYZ19979240;     DEfIUJDWYZ19979240 = DEfIUJDWYZ56374904;     DEfIUJDWYZ56374904 = DEfIUJDWYZ99878655;     DEfIUJDWYZ99878655 = DEfIUJDWYZ82825565;     DEfIUJDWYZ82825565 = DEfIUJDWYZ23330173;     DEfIUJDWYZ23330173 = DEfIUJDWYZ41405672;     DEfIUJDWYZ41405672 = DEfIUJDWYZ50747621;     DEfIUJDWYZ50747621 = DEfIUJDWYZ35010335;     DEfIUJDWYZ35010335 = DEfIUJDWYZ24805557;     DEfIUJDWYZ24805557 = DEfIUJDWYZ75316829;     DEfIUJDWYZ75316829 = DEfIUJDWYZ76989234;     DEfIUJDWYZ76989234 = DEfIUJDWYZ14553502;     DEfIUJDWYZ14553502 = DEfIUJDWYZ97015543;     DEfIUJDWYZ97015543 = DEfIUJDWYZ56494409;     DEfIUJDWYZ56494409 = DEfIUJDWYZ8834748;     DEfIUJDWYZ8834748 = DEfIUJDWYZ20281794;     DEfIUJDWYZ20281794 = DEfIUJDWYZ35381020;     DEfIUJDWYZ35381020 = DEfIUJDWYZ21263081;     DEfIUJDWYZ21263081 = DEfIUJDWYZ65973534;     DEfIUJDWYZ65973534 = DEfIUJDWYZ59925402;     DEfIUJDWYZ59925402 = DEfIUJDWYZ26406099;     DEfIUJDWYZ26406099 = DEfIUJDWYZ51593672;     DEfIUJDWYZ51593672 = DEfIUJDWYZ94867144;     DEfIUJDWYZ94867144 = DEfIUJDWYZ64722946;     DEfIUJDWYZ64722946 = DEfIUJDWYZ94556304;     DEfIUJDWYZ94556304 = DEfIUJDWYZ64839617;     DEfIUJDWYZ64839617 = DEfIUJDWYZ60633857;     DEfIUJDWYZ60633857 = DEfIUJDWYZ17079353;     DEfIUJDWYZ17079353 = DEfIUJDWYZ84708853;     DEfIUJDWYZ84708853 = DEfIUJDWYZ24472391;     DEfIUJDWYZ24472391 = DEfIUJDWYZ15946323;     DEfIUJDWYZ15946323 = DEfIUJDWYZ99684828;     DEfIUJDWYZ99684828 = DEfIUJDWYZ85176327;     DEfIUJDWYZ85176327 = DEfIUJDWYZ44690308;     DEfIUJDWYZ44690308 = DEfIUJDWYZ72845151;     DEfIUJDWYZ72845151 = DEfIUJDWYZ39708200;     DEfIUJDWYZ39708200 = DEfIUJDWYZ29797596;     DEfIUJDWYZ29797596 = DEfIUJDWYZ44524333;     DEfIUJDWYZ44524333 = DEfIUJDWYZ14643829;     DEfIUJDWYZ14643829 = DEfIUJDWYZ96161363;     DEfIUJDWYZ96161363 = DEfIUJDWYZ58907743;     DEfIUJDWYZ58907743 = DEfIUJDWYZ59223545;     DEfIUJDWYZ59223545 = DEfIUJDWYZ49044863;     DEfIUJDWYZ49044863 = DEfIUJDWYZ92877837;     DEfIUJDWYZ92877837 = DEfIUJDWYZ62129450;     DEfIUJDWYZ62129450 = DEfIUJDWYZ35289019;     DEfIUJDWYZ35289019 = DEfIUJDWYZ56072181;     DEfIUJDWYZ56072181 = DEfIUJDWYZ57686503;     DEfIUJDWYZ57686503 = DEfIUJDWYZ67958423;     DEfIUJDWYZ67958423 = DEfIUJDWYZ56420942;     DEfIUJDWYZ56420942 = DEfIUJDWYZ89641830;     DEfIUJDWYZ89641830 = DEfIUJDWYZ135678;     DEfIUJDWYZ135678 = DEfIUJDWYZ19771097;     DEfIUJDWYZ19771097 = DEfIUJDWYZ74300798;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void gZQHbbmxEe92605084() {     double YgHCMnKHEQ33896895 = -766647187;    double YgHCMnKHEQ14167759 = -169737504;    double YgHCMnKHEQ99420081 = -321899678;    double YgHCMnKHEQ97540915 = -96025528;    double YgHCMnKHEQ37624984 = -513794225;    double YgHCMnKHEQ46995921 = -987297800;    double YgHCMnKHEQ2276334 = -786321470;    double YgHCMnKHEQ783329 = -465721408;    double YgHCMnKHEQ76544362 = -62321544;    double YgHCMnKHEQ42261598 = -387942554;    double YgHCMnKHEQ28835501 = -297877604;    double YgHCMnKHEQ4251968 = -441945676;    double YgHCMnKHEQ91394542 = -55830054;    double YgHCMnKHEQ83817931 = -581009433;    double YgHCMnKHEQ60369617 = -116948938;    double YgHCMnKHEQ595885 = -985231058;    double YgHCMnKHEQ80359927 = -167824259;    double YgHCMnKHEQ82595672 = -374009921;    double YgHCMnKHEQ55256972 = -139696075;    double YgHCMnKHEQ73789631 = -489596881;    double YgHCMnKHEQ41872708 = -65086950;    double YgHCMnKHEQ17984839 = -881207629;    double YgHCMnKHEQ29536905 = -25286992;    double YgHCMnKHEQ50159698 = -536301334;    double YgHCMnKHEQ63089661 = -434255208;    double YgHCMnKHEQ23731122 = -6089016;    double YgHCMnKHEQ6164462 = -797539856;    double YgHCMnKHEQ61194272 = -424939796;    double YgHCMnKHEQ79460593 = -757171721;    double YgHCMnKHEQ65823365 = -506653018;    double YgHCMnKHEQ62888320 = -234052302;    double YgHCMnKHEQ80332295 = 65918161;    double YgHCMnKHEQ58737402 = -806029777;    double YgHCMnKHEQ76758323 = -722832878;    double YgHCMnKHEQ78787781 = -173379574;    double YgHCMnKHEQ46784563 = -360481072;    double YgHCMnKHEQ29750362 = -143723215;    double YgHCMnKHEQ48202858 = -84247544;    double YgHCMnKHEQ72105667 = -777645770;    double YgHCMnKHEQ87006566 = -655075159;    double YgHCMnKHEQ35010983 = -850975596;    double YgHCMnKHEQ46781917 = -835656392;    double YgHCMnKHEQ65902092 = -455810614;    double YgHCMnKHEQ95638263 = -225772040;    double YgHCMnKHEQ86732945 = 89510589;    double YgHCMnKHEQ66728457 = -874363524;    double YgHCMnKHEQ90114628 = 41219815;    double YgHCMnKHEQ66675634 = -167722941;    double YgHCMnKHEQ95764551 = -142721211;    double YgHCMnKHEQ15046048 = -506842765;    double YgHCMnKHEQ33311816 = -798957596;    double YgHCMnKHEQ29915326 = -245939081;    double YgHCMnKHEQ16821187 = -153311875;    double YgHCMnKHEQ24022144 = -231488279;    double YgHCMnKHEQ50732377 = -414385901;    double YgHCMnKHEQ15912056 = -885439559;    double YgHCMnKHEQ84630853 = -44450512;    double YgHCMnKHEQ49260384 = -785598344;    double YgHCMnKHEQ34451255 = -661770321;    double YgHCMnKHEQ13893863 = -407705209;    double YgHCMnKHEQ40831459 = -89757945;    double YgHCMnKHEQ41082061 = -261381675;    double YgHCMnKHEQ21322735 = -708549687;    double YgHCMnKHEQ10720997 = -555668526;    double YgHCMnKHEQ79373277 = -53890252;    double YgHCMnKHEQ48503205 = -263795766;    double YgHCMnKHEQ45514565 = -635915899;    double YgHCMnKHEQ14636220 = -332997176;    double YgHCMnKHEQ5030151 = -307629859;    double YgHCMnKHEQ13585054 = -756467866;    double YgHCMnKHEQ70845522 = -741507843;    double YgHCMnKHEQ32157070 = 16423284;    double YgHCMnKHEQ10490006 = -596364152;    double YgHCMnKHEQ68250405 = -484620917;    double YgHCMnKHEQ38778648 = -638621286;    double YgHCMnKHEQ95090790 = -229430558;    double YgHCMnKHEQ52082747 = -325397016;    double YgHCMnKHEQ33898642 = -799514953;    double YgHCMnKHEQ63426752 = -525811923;    double YgHCMnKHEQ96361203 = -559891684;    double YgHCMnKHEQ33616493 = 52691169;    double YgHCMnKHEQ39488828 = -529816915;    double YgHCMnKHEQ65429721 = -182218585;    double YgHCMnKHEQ64414546 = -150328956;    double YgHCMnKHEQ32511549 = -707695423;    double YgHCMnKHEQ32972994 = -988113221;    double YgHCMnKHEQ63511109 = -780769965;    double YgHCMnKHEQ34715259 = -474541499;    double YgHCMnKHEQ26025946 = -208446978;    double YgHCMnKHEQ62875726 = -287940016;    double YgHCMnKHEQ62153709 = -216030560;    double YgHCMnKHEQ80489978 = -358124871;    double YgHCMnKHEQ13751603 = -422477224;    double YgHCMnKHEQ58211805 = -269940561;    double YgHCMnKHEQ46175107 = -465317215;    double YgHCMnKHEQ93928922 = -489593921;    double YgHCMnKHEQ25459182 = -27106705;    double YgHCMnKHEQ55181095 = -900142088;    double YgHCMnKHEQ16264986 = -71881788;    double YgHCMnKHEQ38229741 = -766647187;     YgHCMnKHEQ33896895 = YgHCMnKHEQ14167759;     YgHCMnKHEQ14167759 = YgHCMnKHEQ99420081;     YgHCMnKHEQ99420081 = YgHCMnKHEQ97540915;     YgHCMnKHEQ97540915 = YgHCMnKHEQ37624984;     YgHCMnKHEQ37624984 = YgHCMnKHEQ46995921;     YgHCMnKHEQ46995921 = YgHCMnKHEQ2276334;     YgHCMnKHEQ2276334 = YgHCMnKHEQ783329;     YgHCMnKHEQ783329 = YgHCMnKHEQ76544362;     YgHCMnKHEQ76544362 = YgHCMnKHEQ42261598;     YgHCMnKHEQ42261598 = YgHCMnKHEQ28835501;     YgHCMnKHEQ28835501 = YgHCMnKHEQ4251968;     YgHCMnKHEQ4251968 = YgHCMnKHEQ91394542;     YgHCMnKHEQ91394542 = YgHCMnKHEQ83817931;     YgHCMnKHEQ83817931 = YgHCMnKHEQ60369617;     YgHCMnKHEQ60369617 = YgHCMnKHEQ595885;     YgHCMnKHEQ595885 = YgHCMnKHEQ80359927;     YgHCMnKHEQ80359927 = YgHCMnKHEQ82595672;     YgHCMnKHEQ82595672 = YgHCMnKHEQ55256972;     YgHCMnKHEQ55256972 = YgHCMnKHEQ73789631;     YgHCMnKHEQ73789631 = YgHCMnKHEQ41872708;     YgHCMnKHEQ41872708 = YgHCMnKHEQ17984839;     YgHCMnKHEQ17984839 = YgHCMnKHEQ29536905;     YgHCMnKHEQ29536905 = YgHCMnKHEQ50159698;     YgHCMnKHEQ50159698 = YgHCMnKHEQ63089661;     YgHCMnKHEQ63089661 = YgHCMnKHEQ23731122;     YgHCMnKHEQ23731122 = YgHCMnKHEQ6164462;     YgHCMnKHEQ6164462 = YgHCMnKHEQ61194272;     YgHCMnKHEQ61194272 = YgHCMnKHEQ79460593;     YgHCMnKHEQ79460593 = YgHCMnKHEQ65823365;     YgHCMnKHEQ65823365 = YgHCMnKHEQ62888320;     YgHCMnKHEQ62888320 = YgHCMnKHEQ80332295;     YgHCMnKHEQ80332295 = YgHCMnKHEQ58737402;     YgHCMnKHEQ58737402 = YgHCMnKHEQ76758323;     YgHCMnKHEQ76758323 = YgHCMnKHEQ78787781;     YgHCMnKHEQ78787781 = YgHCMnKHEQ46784563;     YgHCMnKHEQ46784563 = YgHCMnKHEQ29750362;     YgHCMnKHEQ29750362 = YgHCMnKHEQ48202858;     YgHCMnKHEQ48202858 = YgHCMnKHEQ72105667;     YgHCMnKHEQ72105667 = YgHCMnKHEQ87006566;     YgHCMnKHEQ87006566 = YgHCMnKHEQ35010983;     YgHCMnKHEQ35010983 = YgHCMnKHEQ46781917;     YgHCMnKHEQ46781917 = YgHCMnKHEQ65902092;     YgHCMnKHEQ65902092 = YgHCMnKHEQ95638263;     YgHCMnKHEQ95638263 = YgHCMnKHEQ86732945;     YgHCMnKHEQ86732945 = YgHCMnKHEQ66728457;     YgHCMnKHEQ66728457 = YgHCMnKHEQ90114628;     YgHCMnKHEQ90114628 = YgHCMnKHEQ66675634;     YgHCMnKHEQ66675634 = YgHCMnKHEQ95764551;     YgHCMnKHEQ95764551 = YgHCMnKHEQ15046048;     YgHCMnKHEQ15046048 = YgHCMnKHEQ33311816;     YgHCMnKHEQ33311816 = YgHCMnKHEQ29915326;     YgHCMnKHEQ29915326 = YgHCMnKHEQ16821187;     YgHCMnKHEQ16821187 = YgHCMnKHEQ24022144;     YgHCMnKHEQ24022144 = YgHCMnKHEQ50732377;     YgHCMnKHEQ50732377 = YgHCMnKHEQ15912056;     YgHCMnKHEQ15912056 = YgHCMnKHEQ84630853;     YgHCMnKHEQ84630853 = YgHCMnKHEQ49260384;     YgHCMnKHEQ49260384 = YgHCMnKHEQ34451255;     YgHCMnKHEQ34451255 = YgHCMnKHEQ13893863;     YgHCMnKHEQ13893863 = YgHCMnKHEQ40831459;     YgHCMnKHEQ40831459 = YgHCMnKHEQ41082061;     YgHCMnKHEQ41082061 = YgHCMnKHEQ21322735;     YgHCMnKHEQ21322735 = YgHCMnKHEQ10720997;     YgHCMnKHEQ10720997 = YgHCMnKHEQ79373277;     YgHCMnKHEQ79373277 = YgHCMnKHEQ48503205;     YgHCMnKHEQ48503205 = YgHCMnKHEQ45514565;     YgHCMnKHEQ45514565 = YgHCMnKHEQ14636220;     YgHCMnKHEQ14636220 = YgHCMnKHEQ5030151;     YgHCMnKHEQ5030151 = YgHCMnKHEQ13585054;     YgHCMnKHEQ13585054 = YgHCMnKHEQ70845522;     YgHCMnKHEQ70845522 = YgHCMnKHEQ32157070;     YgHCMnKHEQ32157070 = YgHCMnKHEQ10490006;     YgHCMnKHEQ10490006 = YgHCMnKHEQ68250405;     YgHCMnKHEQ68250405 = YgHCMnKHEQ38778648;     YgHCMnKHEQ38778648 = YgHCMnKHEQ95090790;     YgHCMnKHEQ95090790 = YgHCMnKHEQ52082747;     YgHCMnKHEQ52082747 = YgHCMnKHEQ33898642;     YgHCMnKHEQ33898642 = YgHCMnKHEQ63426752;     YgHCMnKHEQ63426752 = YgHCMnKHEQ96361203;     YgHCMnKHEQ96361203 = YgHCMnKHEQ33616493;     YgHCMnKHEQ33616493 = YgHCMnKHEQ39488828;     YgHCMnKHEQ39488828 = YgHCMnKHEQ65429721;     YgHCMnKHEQ65429721 = YgHCMnKHEQ64414546;     YgHCMnKHEQ64414546 = YgHCMnKHEQ32511549;     YgHCMnKHEQ32511549 = YgHCMnKHEQ32972994;     YgHCMnKHEQ32972994 = YgHCMnKHEQ63511109;     YgHCMnKHEQ63511109 = YgHCMnKHEQ34715259;     YgHCMnKHEQ34715259 = YgHCMnKHEQ26025946;     YgHCMnKHEQ26025946 = YgHCMnKHEQ62875726;     YgHCMnKHEQ62875726 = YgHCMnKHEQ62153709;     YgHCMnKHEQ62153709 = YgHCMnKHEQ80489978;     YgHCMnKHEQ80489978 = YgHCMnKHEQ13751603;     YgHCMnKHEQ13751603 = YgHCMnKHEQ58211805;     YgHCMnKHEQ58211805 = YgHCMnKHEQ46175107;     YgHCMnKHEQ46175107 = YgHCMnKHEQ93928922;     YgHCMnKHEQ93928922 = YgHCMnKHEQ25459182;     YgHCMnKHEQ25459182 = YgHCMnKHEQ55181095;     YgHCMnKHEQ55181095 = YgHCMnKHEQ16264986;     YgHCMnKHEQ16264986 = YgHCMnKHEQ38229741;     YgHCMnKHEQ38229741 = YgHCMnKHEQ33896895;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void VJBnKyieLK5150274() {     int gOemBVMSDD53365065 = -79778399;    int gOemBVMSDD67191622 = -715615500;    int gOemBVMSDD16257074 = 26471707;    int gOemBVMSDD16188065 = 87400209;    int gOemBVMSDD38071500 = -40066641;    int gOemBVMSDD72587995 = -877782569;    int gOemBVMSDD47108212 = -129627700;    int gOemBVMSDD66033562 = -559529374;    int gOemBVMSDD37231159 = -790512923;    int gOemBVMSDD20190321 = -393528600;    int gOemBVMSDD83058764 = -730867904;    int gOemBVMSDD7746581 = -441248381;    int gOemBVMSDD81766201 = -480187330;    int gOemBVMSDD92233971 = -23295158;    int gOemBVMSDD20896078 = -415032729;    int gOemBVMSDD66811533 = -348422991;    int gOemBVMSDD86322041 = -339598940;    int gOemBVMSDD6658424 = -124764639;    int gOemBVMSDD54891851 = -516900836;    int gOemBVMSDD54400933 = -107133337;    int gOemBVMSDD54328780 = -671299275;    int gOemBVMSDD32966922 = -293010842;    int gOemBVMSDD97709911 = -322861611;    int gOemBVMSDD67881366 = -172845326;    int gOemBVMSDD74293150 = -728555317;    int gOemBVMSDD28498583 = -791884235;    int gOemBVMSDD90092593 = -462690788;    int gOemBVMSDD11985948 = -588673075;    int gOemBVMSDD21205551 = -771082867;    int gOemBVMSDD50530219 = -598091713;    int gOemBVMSDD92692405 = -99378395;    int gOemBVMSDD19911607 = -498430857;    int gOemBVMSDD70213506 = -261237544;    int gOemBVMSDD35514830 = 72563915;    int gOemBVMSDD18718118 = -236082380;    int gOemBVMSDD82850500 = -664049681;    int gOemBVMSDD98133812 = -670599290;    int gOemBVMSDD89685331 = -161456359;    int gOemBVMSDD39418992 = -142060595;    int gOemBVMSDD8288303 = -651606256;    int gOemBVMSDD76493040 = -260761892;    int gOemBVMSDD58641050 = 25447382;    int gOemBVMSDD37035334 = -403612411;    int gOemBVMSDD79023802 = -674844701;    int gOemBVMSDD66761357 = -187612374;    int gOemBVMSDD21189584 = -311694945;    int gOemBVMSDD72104508 = -972473508;    int gOemBVMSDD66831464 = -351010256;    int gOemBVMSDD36900143 = -156660449;    int gOemBVMSDD55944390 = -267855110;    int gOemBVMSDD7747385 = -105322527;    int gOemBVMSDD46364186 = -623291941;    int gOemBVMSDD86646332 = -929420836;    int gOemBVMSDD96952172 = -226081916;    int gOemBVMSDD50821493 = -188944536;    int gOemBVMSDD20398143 = -786767558;    int gOemBVMSDD69481711 = -292753890;    int gOemBVMSDD48375707 = -800682967;    int gOemBVMSDD41894915 = -184044474;    int gOemBVMSDD9572918 = -248182407;    int gOemBVMSDD82495402 = -315091781;    int gOemBVMSDD35122265 = -540954626;    int gOemBVMSDD44828012 = -788446507;    int gOemBVMSDD86700940 = -92421211;    int gOemBVMSDD27497916 = -194150206;    int gOemBVMSDD63147158 = -132437047;    int gOemBVMSDD37533075 = -80010837;    int gOemBVMSDD46251372 = -452751246;    int gOemBVMSDD73515854 = -787212778;    int gOemBVMSDD38045578 = -750983049;    int gOemBVMSDD68677721 = -677823702;    int gOemBVMSDD96636709 = -78142581;    int gOemBVMSDD67239431 = -982704045;    int gOemBVMSDD46603548 = -865294581;    int gOemBVMSDD77907893 = -846371446;    int gOemBVMSDD95687729 = -596746657;    int gOemBVMSDD95931588 = -889398431;    int gOemBVMSDD18686110 = -648016911;    int gOemBVMSDD1120010 = -985232952;    int gOemBVMSDD53103566 = -316860372;    int gOemBVMSDD56394074 = -819410727;    int gOemBVMSDD23261129 = -11680533;    int gOemBVMSDD75085804 = -332012626;    int gOemBVMSDD65261160 = -403227757;    int gOemBVMSDD42782834 = -392769186;    int gOemBVMSDD46328219 = -476086454;    int gOemBVMSDD33265274 = -569010022;    int gOemBVMSDD73261333 = 64844371;    int gOemBVMSDD84693336 = -738491549;    int gOemBVMSDD98319974 = -449314823;    int gOemBVMSDD13368789 = -271295791;    int gOemBVMSDD49758106 = -869916323;    int gOemBVMSDD47790417 = -977411886;    int gOemBVMSDD29846075 = -893878188;    int gOemBVMSDD25792900 = -236514475;    int gOemBVMSDD41370776 = -719807266;    int gOemBVMSDD13813039 = -186106111;    int gOemBVMSDD50334394 = -211191201;    int gOemBVMSDD51525886 = -380694496;    int gOemBVMSDD3614200 = -79778399;     gOemBVMSDD53365065 = gOemBVMSDD67191622;     gOemBVMSDD67191622 = gOemBVMSDD16257074;     gOemBVMSDD16257074 = gOemBVMSDD16188065;     gOemBVMSDD16188065 = gOemBVMSDD38071500;     gOemBVMSDD38071500 = gOemBVMSDD72587995;     gOemBVMSDD72587995 = gOemBVMSDD47108212;     gOemBVMSDD47108212 = gOemBVMSDD66033562;     gOemBVMSDD66033562 = gOemBVMSDD37231159;     gOemBVMSDD37231159 = gOemBVMSDD20190321;     gOemBVMSDD20190321 = gOemBVMSDD83058764;     gOemBVMSDD83058764 = gOemBVMSDD7746581;     gOemBVMSDD7746581 = gOemBVMSDD81766201;     gOemBVMSDD81766201 = gOemBVMSDD92233971;     gOemBVMSDD92233971 = gOemBVMSDD20896078;     gOemBVMSDD20896078 = gOemBVMSDD66811533;     gOemBVMSDD66811533 = gOemBVMSDD86322041;     gOemBVMSDD86322041 = gOemBVMSDD6658424;     gOemBVMSDD6658424 = gOemBVMSDD54891851;     gOemBVMSDD54891851 = gOemBVMSDD54400933;     gOemBVMSDD54400933 = gOemBVMSDD54328780;     gOemBVMSDD54328780 = gOemBVMSDD32966922;     gOemBVMSDD32966922 = gOemBVMSDD97709911;     gOemBVMSDD97709911 = gOemBVMSDD67881366;     gOemBVMSDD67881366 = gOemBVMSDD74293150;     gOemBVMSDD74293150 = gOemBVMSDD28498583;     gOemBVMSDD28498583 = gOemBVMSDD90092593;     gOemBVMSDD90092593 = gOemBVMSDD11985948;     gOemBVMSDD11985948 = gOemBVMSDD21205551;     gOemBVMSDD21205551 = gOemBVMSDD50530219;     gOemBVMSDD50530219 = gOemBVMSDD92692405;     gOemBVMSDD92692405 = gOemBVMSDD19911607;     gOemBVMSDD19911607 = gOemBVMSDD70213506;     gOemBVMSDD70213506 = gOemBVMSDD35514830;     gOemBVMSDD35514830 = gOemBVMSDD18718118;     gOemBVMSDD18718118 = gOemBVMSDD82850500;     gOemBVMSDD82850500 = gOemBVMSDD98133812;     gOemBVMSDD98133812 = gOemBVMSDD89685331;     gOemBVMSDD89685331 = gOemBVMSDD39418992;     gOemBVMSDD39418992 = gOemBVMSDD8288303;     gOemBVMSDD8288303 = gOemBVMSDD76493040;     gOemBVMSDD76493040 = gOemBVMSDD58641050;     gOemBVMSDD58641050 = gOemBVMSDD37035334;     gOemBVMSDD37035334 = gOemBVMSDD79023802;     gOemBVMSDD79023802 = gOemBVMSDD66761357;     gOemBVMSDD66761357 = gOemBVMSDD21189584;     gOemBVMSDD21189584 = gOemBVMSDD72104508;     gOemBVMSDD72104508 = gOemBVMSDD66831464;     gOemBVMSDD66831464 = gOemBVMSDD36900143;     gOemBVMSDD36900143 = gOemBVMSDD55944390;     gOemBVMSDD55944390 = gOemBVMSDD7747385;     gOemBVMSDD7747385 = gOemBVMSDD46364186;     gOemBVMSDD46364186 = gOemBVMSDD86646332;     gOemBVMSDD86646332 = gOemBVMSDD96952172;     gOemBVMSDD96952172 = gOemBVMSDD50821493;     gOemBVMSDD50821493 = gOemBVMSDD20398143;     gOemBVMSDD20398143 = gOemBVMSDD69481711;     gOemBVMSDD69481711 = gOemBVMSDD48375707;     gOemBVMSDD48375707 = gOemBVMSDD41894915;     gOemBVMSDD41894915 = gOemBVMSDD9572918;     gOemBVMSDD9572918 = gOemBVMSDD82495402;     gOemBVMSDD82495402 = gOemBVMSDD35122265;     gOemBVMSDD35122265 = gOemBVMSDD44828012;     gOemBVMSDD44828012 = gOemBVMSDD86700940;     gOemBVMSDD86700940 = gOemBVMSDD27497916;     gOemBVMSDD27497916 = gOemBVMSDD63147158;     gOemBVMSDD63147158 = gOemBVMSDD37533075;     gOemBVMSDD37533075 = gOemBVMSDD46251372;     gOemBVMSDD46251372 = gOemBVMSDD73515854;     gOemBVMSDD73515854 = gOemBVMSDD38045578;     gOemBVMSDD38045578 = gOemBVMSDD68677721;     gOemBVMSDD68677721 = gOemBVMSDD96636709;     gOemBVMSDD96636709 = gOemBVMSDD67239431;     gOemBVMSDD67239431 = gOemBVMSDD46603548;     gOemBVMSDD46603548 = gOemBVMSDD77907893;     gOemBVMSDD77907893 = gOemBVMSDD95687729;     gOemBVMSDD95687729 = gOemBVMSDD95931588;     gOemBVMSDD95931588 = gOemBVMSDD18686110;     gOemBVMSDD18686110 = gOemBVMSDD1120010;     gOemBVMSDD1120010 = gOemBVMSDD53103566;     gOemBVMSDD53103566 = gOemBVMSDD56394074;     gOemBVMSDD56394074 = gOemBVMSDD23261129;     gOemBVMSDD23261129 = gOemBVMSDD75085804;     gOemBVMSDD75085804 = gOemBVMSDD65261160;     gOemBVMSDD65261160 = gOemBVMSDD42782834;     gOemBVMSDD42782834 = gOemBVMSDD46328219;     gOemBVMSDD46328219 = gOemBVMSDD33265274;     gOemBVMSDD33265274 = gOemBVMSDD73261333;     gOemBVMSDD73261333 = gOemBVMSDD84693336;     gOemBVMSDD84693336 = gOemBVMSDD98319974;     gOemBVMSDD98319974 = gOemBVMSDD13368789;     gOemBVMSDD13368789 = gOemBVMSDD49758106;     gOemBVMSDD49758106 = gOemBVMSDD47790417;     gOemBVMSDD47790417 = gOemBVMSDD29846075;     gOemBVMSDD29846075 = gOemBVMSDD25792900;     gOemBVMSDD25792900 = gOemBVMSDD41370776;     gOemBVMSDD41370776 = gOemBVMSDD13813039;     gOemBVMSDD13813039 = gOemBVMSDD50334394;     gOemBVMSDD50334394 = gOemBVMSDD51525886;     gOemBVMSDD51525886 = gOemBVMSDD3614200;     gOemBVMSDD3614200 = gOemBVMSDD53365065;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void yBdNsyaEFzPNPgDV1333434() {     int xkiEoggUPI12961162 = -308534777;    int xkiEoggUPI68697472 = -525770885;    int xkiEoggUPI53258461 = -47669216;    int xkiEoggUPI12063823 = -785210668;    int xkiEoggUPI49364726 = 59426332;    int xkiEoggUPI70265116 = -736042242;    int xkiEoggUPI44466695 = -559345286;    int xkiEoggUPI16858846 = -913740749;    int xkiEoggUPI51044603 = -223185423;    int xkiEoggUPI3214836 = -334787453;    int xkiEoggUPI8353696 = -32410344;    int xkiEoggUPI42417783 = -536269630;    int xkiEoggUPI52520765 = -386365848;    int xkiEoggUPI50607810 = 72546494;    int xkiEoggUPI18203884 = -107559250;    int xkiEoggUPI63565788 = -153795883;    int xkiEoggUPI22283145 = -267815221;    int xkiEoggUPI71326755 = -494100744;    int xkiEoggUPI35334054 = -656020466;    int xkiEoggUPI34318043 = -769541990;    int xkiEoggUPI34789898 = -504320100;    int xkiEoggUPI1456521 = -185412720;    int xkiEoggUPI89901736 = -87156690;    int xkiEoggUPI32611605 = -837183563;    int xkiEoggUPI50271155 = -184692907;    int xkiEoggUPI22913490 = -926501706;    int xkiEoggUPI3432664 = -912170785;    int xkiEoggUPI77097116 = -110054665;    int xkiEoggUPI70989893 = -560675482;    int xkiEoggUPI89003685 = -645074955;    int xkiEoggUPI17606724 = -744597722;    int xkiEoggUPI62676866 = -915648854;    int xkiEoggUPI19295545 = -241184416;    int xkiEoggUPI18039273 = -529320016;    int xkiEoggUPI23655479 = -984292366;    int xkiEoggUPI61440396 = -975706262;    int xkiEoggUPI88765490 = -963377924;    int xkiEoggUPI88045669 = -105908749;    int xkiEoggUPI58436935 = -960767111;    int xkiEoggUPI81113957 = -925487204;    int xkiEoggUPI34710854 = -729423488;    int xkiEoggUPI28720231 = 20505963;    int xkiEoggUPI77914576 = -137057241;    int xkiEoggUPI53263307 = 1240561;    int xkiEoggUPI67749672 = -733930443;    int xkiEoggUPI85982713 = -554639104;    int xkiEoggUPI77593230 = -864329175;    int xkiEoggUPI13527858 = -683763484;    int xkiEoggUPI76289790 = -440598069;    int xkiEoggUPI71111782 = -589107571;    int xkiEoggUPI58233635 = -991430751;    int xkiEoggUPI52949339 = -594535196;    int xkiEoggUPI62061847 = -69369290;    int xkiEoggUPI70226695 = -486250871;    int xkiEoggUPI66543535 = -152878623;    int xkiEoggUPI11504641 = -23122057;    int xkiEoggUPI78795736 = -338614196;    int xkiEoggUPI20646856 = -210485653;    int xkiEoggUPI61792668 = -500517762;    int xkiEoggUPI26451237 = -14071963;    int xkiEoggUPI66832452 = -823871457;    int xkiEoggUPI67369578 = -349290622;    int xkiEoggUPI45868953 = -253065268;    int xkiEoggUPI62040917 = -578110468;    int xkiEoggUPI85608112 = -590189731;    int xkiEoggUPI45676829 = -116761490;    int xkiEoggUPI23122238 = -195085214;    int xkiEoggUPI34481493 = -857045833;    int xkiEoggUPI26952332 = 56838860;    int xkiEoggUPI56763487 = -131852988;    int xkiEoggUPI74800297 = -190417959;    int xkiEoggUPI34237475 = -61906472;    int xkiEoggUPI12889820 = -533333633;    int xkiEoggUPI54220097 = -730533262;    int xkiEoggUPI99607188 = 59881497;    int xkiEoggUPI6069668 = -424826063;    int xkiEoggUPI23541945 = 51644520;    int xkiEoggUPI36638430 = 11602749;    int xkiEoggUPI64861933 = -3253120;    int xkiEoggUPI64288442 = -630053804;    int xkiEoggUPI45320259 = 37827469;    int xkiEoggUPI89904805 = -128407302;    int xkiEoggUPI807326 = -669456596;    int xkiEoggUPI99878111 = -971567911;    int xkiEoggUPI30770051 = -653644204;    int xkiEoggUPI64657384 = -50062527;    int xkiEoggUPI615020 = -746279565;    int xkiEoggUPI49068849 = -754933546;    int xkiEoggUPI51495737 = -276441393;    int xkiEoggUPI12150838 = -861170309;    int xkiEoggUPI82644660 = -537092067;    int xkiEoggUPI68118634 = -652892272;    int xkiEoggUPI26253001 = -605390988;    int xkiEoggUPI31985699 = -846695149;    int xkiEoggUPI14281505 = -1615747;    int xkiEoggUPI67341275 = -280132867;    int xkiEoggUPI82851278 = -726428770;    int xkiEoggUPI15873659 = -558946773;    int xkiEoggUPI67655194 = -408569709;    int xkiEoggUPI22072844 = -308534777;     xkiEoggUPI12961162 = xkiEoggUPI68697472;     xkiEoggUPI68697472 = xkiEoggUPI53258461;     xkiEoggUPI53258461 = xkiEoggUPI12063823;     xkiEoggUPI12063823 = xkiEoggUPI49364726;     xkiEoggUPI49364726 = xkiEoggUPI70265116;     xkiEoggUPI70265116 = xkiEoggUPI44466695;     xkiEoggUPI44466695 = xkiEoggUPI16858846;     xkiEoggUPI16858846 = xkiEoggUPI51044603;     xkiEoggUPI51044603 = xkiEoggUPI3214836;     xkiEoggUPI3214836 = xkiEoggUPI8353696;     xkiEoggUPI8353696 = xkiEoggUPI42417783;     xkiEoggUPI42417783 = xkiEoggUPI52520765;     xkiEoggUPI52520765 = xkiEoggUPI50607810;     xkiEoggUPI50607810 = xkiEoggUPI18203884;     xkiEoggUPI18203884 = xkiEoggUPI63565788;     xkiEoggUPI63565788 = xkiEoggUPI22283145;     xkiEoggUPI22283145 = xkiEoggUPI71326755;     xkiEoggUPI71326755 = xkiEoggUPI35334054;     xkiEoggUPI35334054 = xkiEoggUPI34318043;     xkiEoggUPI34318043 = xkiEoggUPI34789898;     xkiEoggUPI34789898 = xkiEoggUPI1456521;     xkiEoggUPI1456521 = xkiEoggUPI89901736;     xkiEoggUPI89901736 = xkiEoggUPI32611605;     xkiEoggUPI32611605 = xkiEoggUPI50271155;     xkiEoggUPI50271155 = xkiEoggUPI22913490;     xkiEoggUPI22913490 = xkiEoggUPI3432664;     xkiEoggUPI3432664 = xkiEoggUPI77097116;     xkiEoggUPI77097116 = xkiEoggUPI70989893;     xkiEoggUPI70989893 = xkiEoggUPI89003685;     xkiEoggUPI89003685 = xkiEoggUPI17606724;     xkiEoggUPI17606724 = xkiEoggUPI62676866;     xkiEoggUPI62676866 = xkiEoggUPI19295545;     xkiEoggUPI19295545 = xkiEoggUPI18039273;     xkiEoggUPI18039273 = xkiEoggUPI23655479;     xkiEoggUPI23655479 = xkiEoggUPI61440396;     xkiEoggUPI61440396 = xkiEoggUPI88765490;     xkiEoggUPI88765490 = xkiEoggUPI88045669;     xkiEoggUPI88045669 = xkiEoggUPI58436935;     xkiEoggUPI58436935 = xkiEoggUPI81113957;     xkiEoggUPI81113957 = xkiEoggUPI34710854;     xkiEoggUPI34710854 = xkiEoggUPI28720231;     xkiEoggUPI28720231 = xkiEoggUPI77914576;     xkiEoggUPI77914576 = xkiEoggUPI53263307;     xkiEoggUPI53263307 = xkiEoggUPI67749672;     xkiEoggUPI67749672 = xkiEoggUPI85982713;     xkiEoggUPI85982713 = xkiEoggUPI77593230;     xkiEoggUPI77593230 = xkiEoggUPI13527858;     xkiEoggUPI13527858 = xkiEoggUPI76289790;     xkiEoggUPI76289790 = xkiEoggUPI71111782;     xkiEoggUPI71111782 = xkiEoggUPI58233635;     xkiEoggUPI58233635 = xkiEoggUPI52949339;     xkiEoggUPI52949339 = xkiEoggUPI62061847;     xkiEoggUPI62061847 = xkiEoggUPI70226695;     xkiEoggUPI70226695 = xkiEoggUPI66543535;     xkiEoggUPI66543535 = xkiEoggUPI11504641;     xkiEoggUPI11504641 = xkiEoggUPI78795736;     xkiEoggUPI78795736 = xkiEoggUPI20646856;     xkiEoggUPI20646856 = xkiEoggUPI61792668;     xkiEoggUPI61792668 = xkiEoggUPI26451237;     xkiEoggUPI26451237 = xkiEoggUPI66832452;     xkiEoggUPI66832452 = xkiEoggUPI67369578;     xkiEoggUPI67369578 = xkiEoggUPI45868953;     xkiEoggUPI45868953 = xkiEoggUPI62040917;     xkiEoggUPI62040917 = xkiEoggUPI85608112;     xkiEoggUPI85608112 = xkiEoggUPI45676829;     xkiEoggUPI45676829 = xkiEoggUPI23122238;     xkiEoggUPI23122238 = xkiEoggUPI34481493;     xkiEoggUPI34481493 = xkiEoggUPI26952332;     xkiEoggUPI26952332 = xkiEoggUPI56763487;     xkiEoggUPI56763487 = xkiEoggUPI74800297;     xkiEoggUPI74800297 = xkiEoggUPI34237475;     xkiEoggUPI34237475 = xkiEoggUPI12889820;     xkiEoggUPI12889820 = xkiEoggUPI54220097;     xkiEoggUPI54220097 = xkiEoggUPI99607188;     xkiEoggUPI99607188 = xkiEoggUPI6069668;     xkiEoggUPI6069668 = xkiEoggUPI23541945;     xkiEoggUPI23541945 = xkiEoggUPI36638430;     xkiEoggUPI36638430 = xkiEoggUPI64861933;     xkiEoggUPI64861933 = xkiEoggUPI64288442;     xkiEoggUPI64288442 = xkiEoggUPI45320259;     xkiEoggUPI45320259 = xkiEoggUPI89904805;     xkiEoggUPI89904805 = xkiEoggUPI807326;     xkiEoggUPI807326 = xkiEoggUPI99878111;     xkiEoggUPI99878111 = xkiEoggUPI30770051;     xkiEoggUPI30770051 = xkiEoggUPI64657384;     xkiEoggUPI64657384 = xkiEoggUPI615020;     xkiEoggUPI615020 = xkiEoggUPI49068849;     xkiEoggUPI49068849 = xkiEoggUPI51495737;     xkiEoggUPI51495737 = xkiEoggUPI12150838;     xkiEoggUPI12150838 = xkiEoggUPI82644660;     xkiEoggUPI82644660 = xkiEoggUPI68118634;     xkiEoggUPI68118634 = xkiEoggUPI26253001;     xkiEoggUPI26253001 = xkiEoggUPI31985699;     xkiEoggUPI31985699 = xkiEoggUPI14281505;     xkiEoggUPI14281505 = xkiEoggUPI67341275;     xkiEoggUPI67341275 = xkiEoggUPI82851278;     xkiEoggUPI82851278 = xkiEoggUPI15873659;     xkiEoggUPI15873659 = xkiEoggUPI67655194;     xkiEoggUPI67655194 = xkiEoggUPI22072844;     xkiEoggUPI22072844 = xkiEoggUPI12961162;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void kkSsfTsafGeZoiTkrXeJWF97516593() {     int QEmaNsHfCKzEuuAtOzldntxjlzI72557258 = -537291154;    int QEmaNsHfCKzEuuAtOzldntxjlzI70203322 = -335926270;    int QEmaNsHfCKzEuuAtOzldntxjlzI90259849 = -121810138;    int QEmaNsHfCKzEuuAtOzldntxjlzI7939582 = -557821546;    int QEmaNsHfCKzEuuAtOzldntxjlzI60657953 = -941080696;    int QEmaNsHfCKzEuuAtOzldntxjlzI67942236 = -594301915;    int QEmaNsHfCKzEuuAtOzldntxjlzI41825177 = -989062872;    int QEmaNsHfCKzEuuAtOzldntxjlzI67684130 = -167952124;    int QEmaNsHfCKzEuuAtOzldntxjlzI64858046 = -755857922;    int QEmaNsHfCKzEuuAtOzldntxjlzI86239351 = -276046307;    int QEmaNsHfCKzEuuAtOzldntxjlzI33648627 = -433952783;    int QEmaNsHfCKzEuuAtOzldntxjlzI77088984 = -631290879;    int QEmaNsHfCKzEuuAtOzldntxjlzI23275328 = -292544367;    int QEmaNsHfCKzEuuAtOzldntxjlzI8981650 = -931611853;    int QEmaNsHfCKzEuuAtOzldntxjlzI15511690 = -900085771;    int QEmaNsHfCKzEuuAtOzldntxjlzI60320042 = 40831226;    int QEmaNsHfCKzEuuAtOzldntxjlzI58244248 = -196031501;    int QEmaNsHfCKzEuuAtOzldntxjlzI35995086 = -863436849;    int QEmaNsHfCKzEuuAtOzldntxjlzI15776257 = -795140095;    int QEmaNsHfCKzEuuAtOzldntxjlzI14235152 = -331950643;    int QEmaNsHfCKzEuuAtOzldntxjlzI15251017 = -337340924;    int QEmaNsHfCKzEuuAtOzldntxjlzI69946119 = -77814598;    int QEmaNsHfCKzEuuAtOzldntxjlzI82093561 = -951451769;    int QEmaNsHfCKzEuuAtOzldntxjlzI97341844 = -401521800;    int QEmaNsHfCKzEuuAtOzldntxjlzI26249160 = -740830497;    int QEmaNsHfCKzEuuAtOzldntxjlzI17328397 = 38880823;    int QEmaNsHfCKzEuuAtOzldntxjlzI16772734 = -261650782;    int QEmaNsHfCKzEuuAtOzldntxjlzI42208285 = -731436255;    int QEmaNsHfCKzEuuAtOzldntxjlzI20774236 = -350268097;    int QEmaNsHfCKzEuuAtOzldntxjlzI27477152 = -692058197;    int QEmaNsHfCKzEuuAtOzldntxjlzI42521042 = -289817050;    int QEmaNsHfCKzEuuAtOzldntxjlzI5442127 = -232866852;    int QEmaNsHfCKzEuuAtOzldntxjlzI68377583 = -221131289;    int QEmaNsHfCKzEuuAtOzldntxjlzI563715 = -31203947;    int QEmaNsHfCKzEuuAtOzldntxjlzI28592840 = -632502352;    int QEmaNsHfCKzEuuAtOzldntxjlzI40030293 = -187362844;    int QEmaNsHfCKzEuuAtOzldntxjlzI79397167 = -156156559;    int QEmaNsHfCKzEuuAtOzldntxjlzI86406007 = -50361139;    int QEmaNsHfCKzEuuAtOzldntxjlzI77454878 = -679473628;    int QEmaNsHfCKzEuuAtOzldntxjlzI53939611 = -99368152;    int QEmaNsHfCKzEuuAtOzldntxjlzI92928667 = -98085085;    int QEmaNsHfCKzEuuAtOzldntxjlzI98799411 = 15564545;    int QEmaNsHfCKzEuuAtOzldntxjlzI18793819 = -970502070;    int QEmaNsHfCKzEuuAtOzldntxjlzI27502812 = -422674178;    int QEmaNsHfCKzEuuAtOzldntxjlzI68737988 = -180248512;    int QEmaNsHfCKzEuuAtOzldntxjlzI50775842 = -797583263;    int QEmaNsHfCKzEuuAtOzldntxjlzI83081952 = -756184842;    int QEmaNsHfCKzEuuAtOzldntxjlzI60224252 = 83483287;    int QEmaNsHfCKzEuuAtOzldntxjlzI15679438 = -724535689;    int QEmaNsHfCKzEuuAtOzldntxjlzI86279174 = -910360032;    int QEmaNsHfCKzEuuAtOzldntxjlzI8719886 = -777538975;    int QEmaNsHfCKzEuuAtOzldntxjlzI59534492 = -565778451;    int QEmaNsHfCKzEuuAtOzldntxjlzI37477361 = -309317743;    int QEmaNsHfCKzEuuAtOzldntxjlzI43501219 = -746419826;    int QEmaNsHfCKzEuuAtOzldntxjlzI82265577 = -116812710;    int QEmaNsHfCKzEuuAtOzldntxjlzI2611139 = -359476557;    int QEmaNsHfCKzEuuAtOzldntxjlzI88109760 = -384474502;    int QEmaNsHfCKzEuuAtOzldntxjlzI92918004 = -720288339;    int QEmaNsHfCKzEuuAtOzldntxjlzI81690422 = -816991049;    int QEmaNsHfCKzEuuAtOzldntxjlzI43329556 = -879961520;    int QEmaNsHfCKzEuuAtOzldntxjlzI51169503 = -232651133;    int QEmaNsHfCKzEuuAtOzldntxjlzI99616892 = -157626617;    int QEmaNsHfCKzEuuAtOzldntxjlzI46909894 = -817684028;    int QEmaNsHfCKzEuuAtOzldntxjlzI37380895 = 36200275;    int QEmaNsHfCKzEuuAtOzldntxjlzI43718309 = -986229257;    int QEmaNsHfCKzEuuAtOzldntxjlzI28206500 = -101085932;    int QEmaNsHfCKzEuuAtOzldntxjlzI8711401 = -310159591;    int QEmaNsHfCKzEuuAtOzldntxjlzI22711614 = -161340420;    int QEmaNsHfCKzEuuAtOzldntxjlzI80388809 = -199109502;    int QEmaNsHfCKzEuuAtOzldntxjlzI75481396 = -612722928;    int QEmaNsHfCKzEuuAtOzldntxjlzI80922874 = -803012215;    int QEmaNsHfCKzEuuAtOzldntxjlzI71838241 = -45670363;    int QEmaNsHfCKzEuuAtOzldntxjlzI58540208 = -83963221;    int QEmaNsHfCKzEuuAtOzldntxjlzI61836645 = -595771944;    int QEmaNsHfCKzEuuAtOzldntxjlzI21306485 = -133865559;    int QEmaNsHfCKzEuuAtOzldntxjlzI16451605 = -252905469;    int QEmaNsHfCKzEuuAtOzldntxjlzI51152301 = -107312528;    int QEmaNsHfCKzEuuAtOzldntxjlzI54590749 = -428777591;    int QEmaNsHfCKzEuuAtOzldntxjlzI28603857 = -121273289;    int QEmaNsHfCKzEuuAtOzldntxjlzI75473318 = -943247235;    int QEmaNsHfCKzEuuAtOzldntxjlzI34246444 = -204934335;    int QEmaNsHfCKzEuuAtOzldntxjlzI56548482 = -245134070;    int QEmaNsHfCKzEuuAtOzldntxjlzI26528847 = 93099433;    int QEmaNsHfCKzEuuAtOzldntxjlzI34495062 = -439908065;    int QEmaNsHfCKzEuuAtOzldntxjlzI18757267 = -914519222;    int QEmaNsHfCKzEuuAtOzldntxjlzI82986549 = -724038600;    int QEmaNsHfCKzEuuAtOzldntxjlzI67964765 = -923549109;    int QEmaNsHfCKzEuuAtOzldntxjlzI24876365 = -474711463;    int QEmaNsHfCKzEuuAtOzldntxjlzI18298138 = -914391237;    int QEmaNsHfCKzEuuAtOzldntxjlzI25981701 = -173025795;    int QEmaNsHfCKzEuuAtOzldntxjlzI51920533 = -802888343;    int QEmaNsHfCKzEuuAtOzldntxjlzI86479163 = -435868221;    int QEmaNsHfCKzEuuAtOzldntxjlzI4715586 = -233370090;    int QEmaNsHfCKzEuuAtOzldntxjlzI34125322 = -799512109;    int QEmaNsHfCKzEuuAtOzldntxjlzI2770109 = -866717019;    int QEmaNsHfCKzEuuAtOzldntxjlzI93311775 = -940458468;    int QEmaNsHfCKzEuuAtOzldntxjlzI51889518 = -166751428;    int QEmaNsHfCKzEuuAtOzldntxjlzI81412924 = -906702346;    int QEmaNsHfCKzEuuAtOzldntxjlzI83784503 = -436444922;    int QEmaNsHfCKzEuuAtOzldntxjlzI40531488 = -537291154;     QEmaNsHfCKzEuuAtOzldntxjlzI72557258 = QEmaNsHfCKzEuuAtOzldntxjlzI70203322;     QEmaNsHfCKzEuuAtOzldntxjlzI70203322 = QEmaNsHfCKzEuuAtOzldntxjlzI90259849;     QEmaNsHfCKzEuuAtOzldntxjlzI90259849 = QEmaNsHfCKzEuuAtOzldntxjlzI7939582;     QEmaNsHfCKzEuuAtOzldntxjlzI7939582 = QEmaNsHfCKzEuuAtOzldntxjlzI60657953;     QEmaNsHfCKzEuuAtOzldntxjlzI60657953 = QEmaNsHfCKzEuuAtOzldntxjlzI67942236;     QEmaNsHfCKzEuuAtOzldntxjlzI67942236 = QEmaNsHfCKzEuuAtOzldntxjlzI41825177;     QEmaNsHfCKzEuuAtOzldntxjlzI41825177 = QEmaNsHfCKzEuuAtOzldntxjlzI67684130;     QEmaNsHfCKzEuuAtOzldntxjlzI67684130 = QEmaNsHfCKzEuuAtOzldntxjlzI64858046;     QEmaNsHfCKzEuuAtOzldntxjlzI64858046 = QEmaNsHfCKzEuuAtOzldntxjlzI86239351;     QEmaNsHfCKzEuuAtOzldntxjlzI86239351 = QEmaNsHfCKzEuuAtOzldntxjlzI33648627;     QEmaNsHfCKzEuuAtOzldntxjlzI33648627 = QEmaNsHfCKzEuuAtOzldntxjlzI77088984;     QEmaNsHfCKzEuuAtOzldntxjlzI77088984 = QEmaNsHfCKzEuuAtOzldntxjlzI23275328;     QEmaNsHfCKzEuuAtOzldntxjlzI23275328 = QEmaNsHfCKzEuuAtOzldntxjlzI8981650;     QEmaNsHfCKzEuuAtOzldntxjlzI8981650 = QEmaNsHfCKzEuuAtOzldntxjlzI15511690;     QEmaNsHfCKzEuuAtOzldntxjlzI15511690 = QEmaNsHfCKzEuuAtOzldntxjlzI60320042;     QEmaNsHfCKzEuuAtOzldntxjlzI60320042 = QEmaNsHfCKzEuuAtOzldntxjlzI58244248;     QEmaNsHfCKzEuuAtOzldntxjlzI58244248 = QEmaNsHfCKzEuuAtOzldntxjlzI35995086;     QEmaNsHfCKzEuuAtOzldntxjlzI35995086 = QEmaNsHfCKzEuuAtOzldntxjlzI15776257;     QEmaNsHfCKzEuuAtOzldntxjlzI15776257 = QEmaNsHfCKzEuuAtOzldntxjlzI14235152;     QEmaNsHfCKzEuuAtOzldntxjlzI14235152 = QEmaNsHfCKzEuuAtOzldntxjlzI15251017;     QEmaNsHfCKzEuuAtOzldntxjlzI15251017 = QEmaNsHfCKzEuuAtOzldntxjlzI69946119;     QEmaNsHfCKzEuuAtOzldntxjlzI69946119 = QEmaNsHfCKzEuuAtOzldntxjlzI82093561;     QEmaNsHfCKzEuuAtOzldntxjlzI82093561 = QEmaNsHfCKzEuuAtOzldntxjlzI97341844;     QEmaNsHfCKzEuuAtOzldntxjlzI97341844 = QEmaNsHfCKzEuuAtOzldntxjlzI26249160;     QEmaNsHfCKzEuuAtOzldntxjlzI26249160 = QEmaNsHfCKzEuuAtOzldntxjlzI17328397;     QEmaNsHfCKzEuuAtOzldntxjlzI17328397 = QEmaNsHfCKzEuuAtOzldntxjlzI16772734;     QEmaNsHfCKzEuuAtOzldntxjlzI16772734 = QEmaNsHfCKzEuuAtOzldntxjlzI42208285;     QEmaNsHfCKzEuuAtOzldntxjlzI42208285 = QEmaNsHfCKzEuuAtOzldntxjlzI20774236;     QEmaNsHfCKzEuuAtOzldntxjlzI20774236 = QEmaNsHfCKzEuuAtOzldntxjlzI27477152;     QEmaNsHfCKzEuuAtOzldntxjlzI27477152 = QEmaNsHfCKzEuuAtOzldntxjlzI42521042;     QEmaNsHfCKzEuuAtOzldntxjlzI42521042 = QEmaNsHfCKzEuuAtOzldntxjlzI5442127;     QEmaNsHfCKzEuuAtOzldntxjlzI5442127 = QEmaNsHfCKzEuuAtOzldntxjlzI68377583;     QEmaNsHfCKzEuuAtOzldntxjlzI68377583 = QEmaNsHfCKzEuuAtOzldntxjlzI563715;     QEmaNsHfCKzEuuAtOzldntxjlzI563715 = QEmaNsHfCKzEuuAtOzldntxjlzI28592840;     QEmaNsHfCKzEuuAtOzldntxjlzI28592840 = QEmaNsHfCKzEuuAtOzldntxjlzI40030293;     QEmaNsHfCKzEuuAtOzldntxjlzI40030293 = QEmaNsHfCKzEuuAtOzldntxjlzI79397167;     QEmaNsHfCKzEuuAtOzldntxjlzI79397167 = QEmaNsHfCKzEuuAtOzldntxjlzI86406007;     QEmaNsHfCKzEuuAtOzldntxjlzI86406007 = QEmaNsHfCKzEuuAtOzldntxjlzI77454878;     QEmaNsHfCKzEuuAtOzldntxjlzI77454878 = QEmaNsHfCKzEuuAtOzldntxjlzI53939611;     QEmaNsHfCKzEuuAtOzldntxjlzI53939611 = QEmaNsHfCKzEuuAtOzldntxjlzI92928667;     QEmaNsHfCKzEuuAtOzldntxjlzI92928667 = QEmaNsHfCKzEuuAtOzldntxjlzI98799411;     QEmaNsHfCKzEuuAtOzldntxjlzI98799411 = QEmaNsHfCKzEuuAtOzldntxjlzI18793819;     QEmaNsHfCKzEuuAtOzldntxjlzI18793819 = QEmaNsHfCKzEuuAtOzldntxjlzI27502812;     QEmaNsHfCKzEuuAtOzldntxjlzI27502812 = QEmaNsHfCKzEuuAtOzldntxjlzI68737988;     QEmaNsHfCKzEuuAtOzldntxjlzI68737988 = QEmaNsHfCKzEuuAtOzldntxjlzI50775842;     QEmaNsHfCKzEuuAtOzldntxjlzI50775842 = QEmaNsHfCKzEuuAtOzldntxjlzI83081952;     QEmaNsHfCKzEuuAtOzldntxjlzI83081952 = QEmaNsHfCKzEuuAtOzldntxjlzI60224252;     QEmaNsHfCKzEuuAtOzldntxjlzI60224252 = QEmaNsHfCKzEuuAtOzldntxjlzI15679438;     QEmaNsHfCKzEuuAtOzldntxjlzI15679438 = QEmaNsHfCKzEuuAtOzldntxjlzI86279174;     QEmaNsHfCKzEuuAtOzldntxjlzI86279174 = QEmaNsHfCKzEuuAtOzldntxjlzI8719886;     QEmaNsHfCKzEuuAtOzldntxjlzI8719886 = QEmaNsHfCKzEuuAtOzldntxjlzI59534492;     QEmaNsHfCKzEuuAtOzldntxjlzI59534492 = QEmaNsHfCKzEuuAtOzldntxjlzI37477361;     QEmaNsHfCKzEuuAtOzldntxjlzI37477361 = QEmaNsHfCKzEuuAtOzldntxjlzI43501219;     QEmaNsHfCKzEuuAtOzldntxjlzI43501219 = QEmaNsHfCKzEuuAtOzldntxjlzI82265577;     QEmaNsHfCKzEuuAtOzldntxjlzI82265577 = QEmaNsHfCKzEuuAtOzldntxjlzI2611139;     QEmaNsHfCKzEuuAtOzldntxjlzI2611139 = QEmaNsHfCKzEuuAtOzldntxjlzI88109760;     QEmaNsHfCKzEuuAtOzldntxjlzI88109760 = QEmaNsHfCKzEuuAtOzldntxjlzI92918004;     QEmaNsHfCKzEuuAtOzldntxjlzI92918004 = QEmaNsHfCKzEuuAtOzldntxjlzI81690422;     QEmaNsHfCKzEuuAtOzldntxjlzI81690422 = QEmaNsHfCKzEuuAtOzldntxjlzI43329556;     QEmaNsHfCKzEuuAtOzldntxjlzI43329556 = QEmaNsHfCKzEuuAtOzldntxjlzI51169503;     QEmaNsHfCKzEuuAtOzldntxjlzI51169503 = QEmaNsHfCKzEuuAtOzldntxjlzI99616892;     QEmaNsHfCKzEuuAtOzldntxjlzI99616892 = QEmaNsHfCKzEuuAtOzldntxjlzI46909894;     QEmaNsHfCKzEuuAtOzldntxjlzI46909894 = QEmaNsHfCKzEuuAtOzldntxjlzI37380895;     QEmaNsHfCKzEuuAtOzldntxjlzI37380895 = QEmaNsHfCKzEuuAtOzldntxjlzI43718309;     QEmaNsHfCKzEuuAtOzldntxjlzI43718309 = QEmaNsHfCKzEuuAtOzldntxjlzI28206500;     QEmaNsHfCKzEuuAtOzldntxjlzI28206500 = QEmaNsHfCKzEuuAtOzldntxjlzI8711401;     QEmaNsHfCKzEuuAtOzldntxjlzI8711401 = QEmaNsHfCKzEuuAtOzldntxjlzI22711614;     QEmaNsHfCKzEuuAtOzldntxjlzI22711614 = QEmaNsHfCKzEuuAtOzldntxjlzI80388809;     QEmaNsHfCKzEuuAtOzldntxjlzI80388809 = QEmaNsHfCKzEuuAtOzldntxjlzI75481396;     QEmaNsHfCKzEuuAtOzldntxjlzI75481396 = QEmaNsHfCKzEuuAtOzldntxjlzI80922874;     QEmaNsHfCKzEuuAtOzldntxjlzI80922874 = QEmaNsHfCKzEuuAtOzldntxjlzI71838241;     QEmaNsHfCKzEuuAtOzldntxjlzI71838241 = QEmaNsHfCKzEuuAtOzldntxjlzI58540208;     QEmaNsHfCKzEuuAtOzldntxjlzI58540208 = QEmaNsHfCKzEuuAtOzldntxjlzI61836645;     QEmaNsHfCKzEuuAtOzldntxjlzI61836645 = QEmaNsHfCKzEuuAtOzldntxjlzI21306485;     QEmaNsHfCKzEuuAtOzldntxjlzI21306485 = QEmaNsHfCKzEuuAtOzldntxjlzI16451605;     QEmaNsHfCKzEuuAtOzldntxjlzI16451605 = QEmaNsHfCKzEuuAtOzldntxjlzI51152301;     QEmaNsHfCKzEuuAtOzldntxjlzI51152301 = QEmaNsHfCKzEuuAtOzldntxjlzI54590749;     QEmaNsHfCKzEuuAtOzldntxjlzI54590749 = QEmaNsHfCKzEuuAtOzldntxjlzI28603857;     QEmaNsHfCKzEuuAtOzldntxjlzI28603857 = QEmaNsHfCKzEuuAtOzldntxjlzI75473318;     QEmaNsHfCKzEuuAtOzldntxjlzI75473318 = QEmaNsHfCKzEuuAtOzldntxjlzI34246444;     QEmaNsHfCKzEuuAtOzldntxjlzI34246444 = QEmaNsHfCKzEuuAtOzldntxjlzI56548482;     QEmaNsHfCKzEuuAtOzldntxjlzI56548482 = QEmaNsHfCKzEuuAtOzldntxjlzI26528847;     QEmaNsHfCKzEuuAtOzldntxjlzI26528847 = QEmaNsHfCKzEuuAtOzldntxjlzI34495062;     QEmaNsHfCKzEuuAtOzldntxjlzI34495062 = QEmaNsHfCKzEuuAtOzldntxjlzI18757267;     QEmaNsHfCKzEuuAtOzldntxjlzI18757267 = QEmaNsHfCKzEuuAtOzldntxjlzI82986549;     QEmaNsHfCKzEuuAtOzldntxjlzI82986549 = QEmaNsHfCKzEuuAtOzldntxjlzI67964765;     QEmaNsHfCKzEuuAtOzldntxjlzI67964765 = QEmaNsHfCKzEuuAtOzldntxjlzI24876365;     QEmaNsHfCKzEuuAtOzldntxjlzI24876365 = QEmaNsHfCKzEuuAtOzldntxjlzI18298138;     QEmaNsHfCKzEuuAtOzldntxjlzI18298138 = QEmaNsHfCKzEuuAtOzldntxjlzI25981701;     QEmaNsHfCKzEuuAtOzldntxjlzI25981701 = QEmaNsHfCKzEuuAtOzldntxjlzI51920533;     QEmaNsHfCKzEuuAtOzldntxjlzI51920533 = QEmaNsHfCKzEuuAtOzldntxjlzI86479163;     QEmaNsHfCKzEuuAtOzldntxjlzI86479163 = QEmaNsHfCKzEuuAtOzldntxjlzI4715586;     QEmaNsHfCKzEuuAtOzldntxjlzI4715586 = QEmaNsHfCKzEuuAtOzldntxjlzI34125322;     QEmaNsHfCKzEuuAtOzldntxjlzI34125322 = QEmaNsHfCKzEuuAtOzldntxjlzI2770109;     QEmaNsHfCKzEuuAtOzldntxjlzI2770109 = QEmaNsHfCKzEuuAtOzldntxjlzI93311775;     QEmaNsHfCKzEuuAtOzldntxjlzI93311775 = QEmaNsHfCKzEuuAtOzldntxjlzI51889518;     QEmaNsHfCKzEuuAtOzldntxjlzI51889518 = QEmaNsHfCKzEuuAtOzldntxjlzI81412924;     QEmaNsHfCKzEuuAtOzldntxjlzI81412924 = QEmaNsHfCKzEuuAtOzldntxjlzI83784503;     QEmaNsHfCKzEuuAtOzldntxjlzI83784503 = QEmaNsHfCKzEuuAtOzldntxjlzI40531488;     QEmaNsHfCKzEuuAtOzldntxjlzI40531488 = QEmaNsHfCKzEuuAtOzldntxjlzI72557258;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void OgsrWBXWqumVhvizsBgcbX10061783() {     int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92025428 = -950422366;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI23227186 = -881804266;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI7096841 = -873438753;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI26586731 = -374395809;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI61104469 = -467353112;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI93534310 = -484786684;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI86657055 = -332369102;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI32934363 = -261760090;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI25544844 = -384049301;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI64168074 = -281632352;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI87871890 = -866943083;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI80583597 = -630593584;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI13646988 = -716901643;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI17397690 = -373897579;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76038151 = -98169563;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI26535691 = -422360708;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI64206361 = -367806182;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI60057837 = -614191567;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI15411136 = -72344856;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI94846453 = 50512901;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI27707089 = -943553250;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI84928202 = -589617811;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI50266568 = -149026387;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI15063513 = -38065792;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI37452649 = 64869393;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI22095858 = -746914395;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI700865 = 73198286;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92999959 = -895169534;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI62519193 = -364179243;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI12184007 = -783496892;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI72325127 = -155143143;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI45021438 = -797215870;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI79853686 = -776339056;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI59320222 = -335807153;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI68523175 = -695205158;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76096230 = -490931453;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI47780618 = -683032634;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI27888482 = -127569954;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI44768203 = -43888453;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI75221347 = -95899249;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI34410725 = -607871380;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI10658545 = -223331681;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI89927059 = -918303868;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI10888351 = -871746839;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI48766399 = -457371475;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI5236969 = -234914684;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI65071832 = -669878165;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI60380082 = -99804027;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI56815029 = -738474927;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI27177517 = -671372377;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI83155454 = -83903906;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI75983352 = -943131311;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI7302508 = 14573296;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI16431248 = -741013462;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI82354693 = -991371345;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI7097227 = -260804556;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI72960618 = -632777880;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92033328 = -735372962;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI89134081 = -339265203;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI39008611 = -720438717;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92833446 = -457984970;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI93657096 = -437199568;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI70415170 = -897580848;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI13360838 = -600552410;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI91842947 = -26489210;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI42850453 = 30272786;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI729912 = -854254529;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI54326766 = -281094491;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI48874514 = -678692421;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI99941920 = -607238111;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI78755072 = -739328074;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI36317880 = -140236229;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI15289635 = -470303114;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40189789 = -976445608;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI60435729 = -341615720;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI17048544 = -620221569;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI95001142 = -671313943;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI39378217 = -277279549;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI66297114 = -580694317;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI32215680 = -700215923;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI57024026 = 22963770;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40320783 = -826997688;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI36184931 = -56694607;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI35341676 = -692806866;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI29028552 = -599592986;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI96341774 = -212011833;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI37718930 = -711789166;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI63422439 = 64674406;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76965528 = -344435809;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI61425949 = -334400602;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI3135613 = -858153574;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI55747290 = -947659672;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI38754400 = -788304752;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI5759592 = -323449737;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI82387901 = -637914279;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40753628 = -70671813;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40243375 = -325750834;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76566222 = -217751459;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI19045404 = -745257630;    int ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI5915946 = -950422366;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92025428 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI23227186;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI23227186 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI7096841;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI7096841 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI26586731;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI26586731 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI61104469;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI61104469 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI93534310;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI93534310 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI86657055;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI86657055 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI32934363;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI32934363 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI25544844;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI25544844 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI64168074;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI64168074 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI87871890;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI87871890 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI80583597;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI80583597 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI13646988;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI13646988 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI17397690;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI17397690 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76038151;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76038151 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI26535691;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI26535691 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI64206361;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI64206361 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI60057837;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI60057837 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI15411136;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI15411136 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI94846453;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI94846453 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI27707089;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI27707089 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI84928202;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI84928202 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI50266568;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI50266568 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI15063513;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI15063513 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI37452649;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI37452649 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI22095858;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI22095858 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI700865;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI700865 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92999959;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92999959 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI62519193;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI62519193 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI12184007;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI12184007 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI72325127;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI72325127 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI45021438;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI45021438 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI79853686;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI79853686 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI59320222;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI59320222 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI68523175;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI68523175 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76096230;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76096230 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI47780618;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI47780618 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI27888482;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI27888482 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI44768203;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI44768203 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI75221347;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI75221347 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI34410725;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI34410725 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI10658545;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI10658545 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI89927059;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI89927059 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI10888351;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI10888351 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI48766399;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI48766399 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI5236969;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI5236969 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI65071832;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI65071832 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI60380082;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI60380082 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI56815029;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI56815029 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI27177517;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI27177517 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI83155454;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI83155454 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI75983352;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI75983352 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI7302508;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI7302508 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI16431248;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI16431248 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI82354693;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI82354693 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI7097227;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI7097227 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI72960618;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI72960618 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92033328;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92033328 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI89134081;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI89134081 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI39008611;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI39008611 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92833446;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92833446 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI93657096;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI93657096 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI70415170;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI70415170 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI13360838;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI13360838 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI91842947;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI91842947 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI42850453;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI42850453 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI729912;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI729912 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI54326766;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI54326766 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI48874514;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI48874514 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI99941920;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI99941920 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI78755072;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI78755072 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI36317880;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI36317880 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI15289635;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI15289635 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40189789;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40189789 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI60435729;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI60435729 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI17048544;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI17048544 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI95001142;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI95001142 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI39378217;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI39378217 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI66297114;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI66297114 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI32215680;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI32215680 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI57024026;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI57024026 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40320783;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40320783 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI36184931;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI36184931 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI35341676;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI35341676 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI29028552;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI29028552 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI96341774;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI96341774 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI37718930;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI37718930 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI63422439;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI63422439 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76965528;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76965528 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI61425949;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI61425949 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI3135613;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI3135613 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI55747290;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI55747290 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI38754400;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI38754400 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI5759592;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI5759592 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI82387901;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI82387901 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40753628;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40753628 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40243375;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI40243375 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76566222;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI76566222 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI19045404;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI19045404 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI5915946;     ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI5915946 = ADApyPPfvuyiXGCeXXgKDXkHEOFsLszzGrfoqgDI92025428;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void TsGQYRiypRzAngLRmZQScu70364439() {     int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP82151737 = 90821433;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP6352251 = -156730437;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP2589540 = 89766786;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP85306 = -560567631;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP74161204 = -408676553;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP74320715 = -377419792;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP81320494 = 30085425;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP85812926 = -998207829;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP49356531 = -391941939;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68423744 = -951506878;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP64023709 = -275363241;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP15333106 = -110181719;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP51993120 = 70862496;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP55816543 = -372058463;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP74112522 = -583290506;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP50715433 = -122740578;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP8168542 = -629151424;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP81413549 = 42959141;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP76325527 = -538755292;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP62170702 = -597365409;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP15629491 = -647978342;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP83009784 = -922714446;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP83504985 = -555486308;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22984610 = -486090167;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP84337836 = -578641551;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP40886823 = -622788130;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22668200 = -786330708;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP16170335 = -955059592;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP23728191 = -26378291;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP59973086 = -657899283;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP75788529 = -481809687;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP44388352 = -198040289;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP88822727 = 23435785;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP83158866 = -327258311;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP4119711 = -345540818;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP29327237 = -793960863;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP48014187 = -198848538;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP52245765 = 6370802;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP55301220 = -851350499;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19733489 = -607022;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP48110398 = -313732656;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP65303008 = -37824894;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP49743901 = -293729463;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP41550292 = -735830028;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP40730816 = -569881431;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP25675963 = -718538590;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP45495123 = -218360665;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP50766541 = -126460280;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP84733683 = -74414274;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56457923 = -28368714;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP12520979 = -458285951;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19756460 = -907558144;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56754963 = -797279699;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP69338309 = -864568744;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP54734949 = -19971617;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP99141952 = 13535879;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22847265 = -601244129;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP79604930 = -424143048;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP15747469 = -981926081;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP33274382 = -785888424;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP51652516 = -591089084;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP65150159 = -14854983;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP62084735 = -871829538;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP89383445 = -734042656;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP92635214 = -369697191;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19635358 = 22677048;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP26510378 = -33617505;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68834253 = -601879193;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP51696833 = 73482355;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP44785286 = -789329643;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP2701246 = -923892040;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP55922777 = -535522226;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP26112330 = -105690360;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56592038 = -438148271;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP14060304 = -183632754;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP50326483 = -510153448;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP33265884 = -528984983;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP41954694 = -819656281;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP82253793 = -916208737;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP58661874 = -860102962;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP95391700 = -304427465;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP71901659 = -559870428;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP31436652 = -780645319;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP67270268 = -998009577;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP47452108 = -99613332;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56032070 = -574251544;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP87633389 = -400760591;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19484418 = -111995472;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP28423918 = -207286695;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP4977758 = -259076698;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP6479972 = -92716735;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68409257 = -774705491;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP36498296 = -11703118;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22026839 = 34537925;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68080973 = -409517938;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP82960238 = -198877674;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP3218273 = -165995356;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP60360455 = -559686808;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP48915077 = -266132837;    int rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP21095459 = 90821433;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP82151737 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP6352251;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP6352251 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP2589540;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP2589540 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP85306;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP85306 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP74161204;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP74161204 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP74320715;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP74320715 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP81320494;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP81320494 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP85812926;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP85812926 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP49356531;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP49356531 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68423744;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68423744 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP64023709;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP64023709 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP15333106;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP15333106 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP51993120;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP51993120 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP55816543;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP55816543 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP74112522;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP74112522 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP50715433;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP50715433 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP8168542;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP8168542 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP81413549;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP81413549 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP76325527;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP76325527 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP62170702;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP62170702 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP15629491;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP15629491 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP83009784;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP83009784 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP83504985;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP83504985 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22984610;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22984610 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP84337836;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP84337836 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP40886823;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP40886823 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22668200;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22668200 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP16170335;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP16170335 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP23728191;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP23728191 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP59973086;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP59973086 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP75788529;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP75788529 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP44388352;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP44388352 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP88822727;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP88822727 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP83158866;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP83158866 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP4119711;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP4119711 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP29327237;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP29327237 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP48014187;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP48014187 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP52245765;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP52245765 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP55301220;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP55301220 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19733489;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19733489 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP48110398;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP48110398 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP65303008;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP65303008 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP49743901;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP49743901 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP41550292;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP41550292 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP40730816;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP40730816 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP25675963;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP25675963 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP45495123;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP45495123 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP50766541;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP50766541 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP84733683;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP84733683 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56457923;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56457923 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP12520979;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP12520979 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19756460;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19756460 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56754963;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56754963 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP69338309;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP69338309 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP54734949;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP54734949 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP99141952;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP99141952 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22847265;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22847265 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP79604930;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP79604930 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP15747469;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP15747469 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP33274382;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP33274382 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP51652516;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP51652516 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP65150159;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP65150159 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP62084735;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP62084735 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP89383445;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP89383445 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP92635214;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP92635214 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19635358;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19635358 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP26510378;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP26510378 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68834253;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68834253 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP51696833;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP51696833 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP44785286;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP44785286 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP2701246;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP2701246 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP55922777;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP55922777 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP26112330;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP26112330 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56592038;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56592038 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP14060304;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP14060304 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP50326483;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP50326483 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP33265884;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP33265884 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP41954694;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP41954694 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP82253793;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP82253793 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP58661874;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP58661874 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP95391700;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP95391700 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP71901659;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP71901659 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP31436652;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP31436652 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP67270268;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP67270268 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP47452108;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP47452108 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56032070;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP56032070 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP87633389;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP87633389 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19484418;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP19484418 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP28423918;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP28423918 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP4977758;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP4977758 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP6479972;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP6479972 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68409257;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68409257 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP36498296;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP36498296 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22026839;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP22026839 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68080973;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP68080973 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP82960238;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP82960238 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP3218273;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP3218273 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP60360455;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP60360455 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP48915077;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP48915077 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP21095459;     rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP21095459 = rQDpQSTJyuRGsLAbcmfrKPMJfRlSsKNxwYBpNiBP82151737;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void RBKMMsDkKJiJGbKkJYVidX66547600() {     int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy41747834 = -137934944;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy7858101 = 33114178;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy39590928 = 15625863;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy95961063 = -333178508;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy85454430 = -309183581;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71997836 = -235679465;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy78678976 = -399632161;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy36638210 = -252419204;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63169975 = -924614438;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy51448259 = -892765731;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy89318640 = -676905680;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50004307 = -205202969;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy22747683 = -935316022;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy14190382 = -276216810;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71420328 = -275817027;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy47469687 = 71886531;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy44129646 = -557367704;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy46081881 = -326376964;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy56767730 = -677874922;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy42087811 = -159774062;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy96090609 = -480999166;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy51499383 = -815116324;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy75696810 = -319781387;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy87714848 = -50428404;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy60315841 = -34779141;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35301730 = -757405601;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy36008270 = -135810705;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy81281503 = -476441183;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy73512533 = -915970906;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy98446552 = -704882525;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy702848 = -27029015;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy87153612 = -615258287;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy37904766 = 43488912;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy65683309 = -929142243;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy9057072 = 6249196;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy7917134 = -5617445;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy38645865 = -491627173;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50606102 = 61918412;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy74319162 = -570057016;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy92559143 = -274487970;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy6328212 = -782394253;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35382189 = -42766313;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy90623142 = -27174293;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy15789797 = -59744766;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy41719132 = -16199499;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy90469091 = -961482748;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50983845 = -110216332;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy97462934 = -459213509;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy24123331 = -358351893;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71625315 = -349621175;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63007228 = -244394175;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy26341613 = -878801399;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy32170477 = 62771847;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy42612833 = -24737699;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy70456990 = 16094296;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy90248451 = -322818621;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy32161290 = -647104435;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy51876079 = -933945733;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35645222 = -198399368;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50152701 = -551777980;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35989566 = 131240;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy97397472 = -923190978;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63125676 = -336448299;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy64723422 = -119731913;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50745411 = -765736717;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy2165029 = 38352606;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy12099541 = -148691882;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy57064374 = 93826220;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy5133311 = -182466007;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63503195 = -170199583;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy8823823 = -436486297;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy93523543 = -519286117;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71762718 = -756319949;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy64208586 = -303386952;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35759600 = -377379810;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy60708420 = -338232854;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy60876240 = -687942032;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy59907014 = -160036621;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy45995717 = 65771095;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy69846750 = -73296393;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy84317885 = -547189269;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy38545336 = -676597197;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy57158173 = -18089290;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy1887219 = -466349731;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35439324 = -360488350;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy74361235 = -148227617;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy54983135 = -578030134;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy95291933 = -931773389;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy95226318 = -845236539;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy18808620 = -670932184;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy75755844 = -358513010;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy86769786 = -557681440;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy14960881 = -739682220;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy24166462 = 81720964;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy56569578 = -174619210;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy8930739 = -859203275;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy72256512 = -706318014;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy25899721 = -907442380;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy65044385 = -294008050;    int LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy39554103 = -137934944;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy41747834 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy7858101;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy7858101 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy39590928;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy39590928 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy95961063;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy95961063 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy85454430;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy85454430 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71997836;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71997836 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy78678976;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy78678976 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy36638210;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy36638210 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63169975;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63169975 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy51448259;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy51448259 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy89318640;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy89318640 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50004307;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50004307 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy22747683;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy22747683 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy14190382;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy14190382 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71420328;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71420328 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy47469687;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy47469687 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy44129646;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy44129646 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy46081881;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy46081881 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy56767730;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy56767730 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy42087811;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy42087811 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy96090609;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy96090609 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy51499383;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy51499383 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy75696810;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy75696810 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy87714848;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy87714848 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy60315841;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy60315841 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35301730;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35301730 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy36008270;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy36008270 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy81281503;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy81281503 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy73512533;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy73512533 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy98446552;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy98446552 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy702848;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy702848 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy87153612;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy87153612 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy37904766;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy37904766 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy65683309;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy65683309 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy9057072;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy9057072 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy7917134;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy7917134 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy38645865;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy38645865 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50606102;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50606102 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy74319162;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy74319162 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy92559143;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy92559143 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy6328212;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy6328212 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35382189;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35382189 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy90623142;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy90623142 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy15789797;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy15789797 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy41719132;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy41719132 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy90469091;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy90469091 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50983845;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50983845 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy97462934;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy97462934 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy24123331;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy24123331 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71625315;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71625315 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63007228;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63007228 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy26341613;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy26341613 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy32170477;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy32170477 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy42612833;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy42612833 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy70456990;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy70456990 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy90248451;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy90248451 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy32161290;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy32161290 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy51876079;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy51876079 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35645222;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35645222 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50152701;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50152701 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35989566;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35989566 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy97397472;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy97397472 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63125676;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63125676 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy64723422;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy64723422 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50745411;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy50745411 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy2165029;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy2165029 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy12099541;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy12099541 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy57064374;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy57064374 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy5133311;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy5133311 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63503195;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy63503195 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy8823823;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy8823823 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy93523543;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy93523543 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71762718;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy71762718 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy64208586;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy64208586 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35759600;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35759600 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy60708420;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy60708420 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy60876240;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy60876240 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy59907014;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy59907014 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy45995717;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy45995717 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy69846750;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy69846750 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy84317885;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy84317885 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy38545336;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy38545336 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy57158173;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy57158173 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy1887219;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy1887219 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35439324;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy35439324 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy74361235;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy74361235 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy54983135;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy54983135 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy95291933;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy95291933 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy95226318;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy95226318 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy18808620;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy18808620 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy75755844;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy75755844 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy86769786;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy86769786 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy14960881;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy14960881 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy24166462;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy24166462 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy56569578;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy56569578 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy8930739;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy8930739 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy72256512;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy72256512 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy25899721;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy25899721 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy65044385;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy65044385 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy39554103;     LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy39554103 = LHPJoEIYREZMCfmlWqKPsuHXpDigwTrFDtpCwCDy41747834;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void oXeSLuvNfBtbSjjLJAyrDB62730760() {     int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo1343931 = -366691321;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo9363950 = -877041207;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76592315 = -58515059;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo91836822 = -105789386;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo96747657 = -209690608;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo69674956 = -93939138;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76037459 = -829349746;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo87463494 = -606630580;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76983418 = -357286937;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo34472775 = -834024585;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo14613573 = 21551880;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo84675508 = -300224218;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo93502246 = -841494541;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo72564220 = -180375157;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo68728134 = 31656452;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo44223942 = -833486360;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo80090749 = -485583985;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo10750212 = -695713068;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo37209933 = -816994552;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo22004920 = -822182715;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76551728 = -314019991;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo19988982 = -707518202;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo67888636 = -84076466;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo52445088 = -714766641;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo36293846 = -590916731;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29716637 = -892023072;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo49348341 = -585290703;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo46392673 = 2177227;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo23296877 = -705563521;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo36920019 = -751865767;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo25617166 = -672248343;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29918872 = 67523716;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86986805 = 63542040;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo48207751 = -431026174;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo13994433 = -741960790;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86507030 = -317274027;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29277543 = -784405808;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo48966440 = -982533977;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo93337105 = -288763532;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo65384798 = -548368918;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo64546024 = -151055849;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo5461371 = -47707731;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo31502385 = -860619122;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo90029302 = -483659505;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo42707447 = -562517568;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo55262220 = -104426907;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo56472567 = -2071999;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo44159329 = -791966737;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo63512978 = -642289513;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86792707 = -670873636;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo13493479 = -30502399;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo32926766 = -850044654;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo7585992 = -177176607;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo15887356 = -284906655;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86179032 = 52160209;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo81354949 = -659173120;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo41475314 = -692964741;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo24147228 = -343748419;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo55542976 = -514872655;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo67031020 = -317667537;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo20326616 = -508648436;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29644787 = -731526974;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo64166617 = -901067059;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo40063400 = -605421170;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo8855609 = -61776242;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo84694700 = 54028164;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo97688703 = -263766259;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo45294495 = -310468367;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo58569788 = -438414368;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo82221104 = -651069522;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo14946399 = 50919447;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo31124310 = -503050008;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo17413106 = -306949537;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo71825135 = -168625634;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo57458895 = -571126867;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo71090358 = -166312260;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo88486596 = -846899080;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo77859334 = -600416961;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo9737641 = -52249073;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo81031626 = -386489824;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo73244070 = -789951073;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo5189013 = -793323966;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo82879694 = -355533260;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo36504169 = 65310114;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo23426541 = -621363369;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo92690400 = -822203689;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo22332881 = -755299678;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo71099449 = -651551306;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo62028719 = -383186383;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo32639483 = 17212330;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo45031716 = -624309286;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo5130315 = -340657389;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo93423464 = -367661322;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo26306086 = -971095996;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo45058182 = 60279518;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo34901238 = -419528875;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo41294753 = -146640673;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo91438985 = -155197953;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo81173693 = -321883263;    int JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo58012747 = -366691321;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo1343931 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo9363950;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo9363950 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76592315;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76592315 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo91836822;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo91836822 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo96747657;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo96747657 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo69674956;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo69674956 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76037459;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76037459 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo87463494;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo87463494 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76983418;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76983418 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo34472775;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo34472775 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo14613573;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo14613573 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo84675508;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo84675508 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo93502246;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo93502246 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo72564220;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo72564220 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo68728134;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo68728134 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo44223942;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo44223942 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo80090749;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo80090749 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo10750212;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo10750212 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo37209933;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo37209933 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo22004920;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo22004920 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76551728;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo76551728 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo19988982;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo19988982 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo67888636;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo67888636 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo52445088;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo52445088 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo36293846;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo36293846 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29716637;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29716637 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo49348341;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo49348341 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo46392673;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo46392673 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo23296877;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo23296877 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo36920019;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo36920019 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo25617166;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo25617166 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29918872;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29918872 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86986805;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86986805 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo48207751;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo48207751 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo13994433;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo13994433 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86507030;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86507030 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29277543;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29277543 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo48966440;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo48966440 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo93337105;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo93337105 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo65384798;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo65384798 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo64546024;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo64546024 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo5461371;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo5461371 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo31502385;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo31502385 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo90029302;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo90029302 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo42707447;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo42707447 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo55262220;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo55262220 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo56472567;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo56472567 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo44159329;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo44159329 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo63512978;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo63512978 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86792707;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86792707 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo13493479;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo13493479 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo32926766;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo32926766 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo7585992;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo7585992 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo15887356;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo15887356 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86179032;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo86179032 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo81354949;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo81354949 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo41475314;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo41475314 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo24147228;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo24147228 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo55542976;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo55542976 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo67031020;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo67031020 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo20326616;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo20326616 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29644787;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo29644787 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo64166617;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo64166617 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo40063400;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo40063400 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo8855609;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo8855609 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo84694700;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo84694700 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo97688703;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo97688703 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo45294495;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo45294495 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo58569788;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo58569788 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo82221104;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo82221104 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo14946399;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo14946399 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo31124310;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo31124310 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo17413106;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo17413106 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo71825135;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo71825135 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo57458895;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo57458895 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo71090358;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo71090358 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo88486596;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo88486596 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo77859334;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo77859334 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo9737641;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo9737641 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo81031626;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo81031626 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo73244070;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo73244070 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo5189013;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo5189013 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo82879694;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo82879694 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo36504169;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo36504169 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo23426541;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo23426541 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo92690400;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo92690400 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo22332881;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo22332881 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo71099449;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo71099449 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo62028719;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo62028719 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo32639483;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo32639483 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo45031716;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo45031716 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo5130315;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo5130315 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo93423464;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo93423464 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo26306086;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo26306086 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo45058182;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo45058182 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo34901238;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo34901238 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo41294753;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo41294753 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo91438985;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo91438985 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo81173693;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo81173693 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo58012747;     JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo58012747 = JZiwrHpnAfYUOPwTbSUVHocgeXKMARWKEnOEkPDo1343931;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void TYSkyjwhjQufoTnXSLTcXA75275949() {     int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR20812101 = -779822533;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62387814 = -322919203;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR93429307 = -810143674;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR10483971 = 77636351;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97194173 = -835963024;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR95267030 = 15576094;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR20869338 = -172655976;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR52713727 = -700438546;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR37670216 = 14521684;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR12401498 = -839610631;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR68836836 = -411438420;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR88170122 = -299526923;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR83873905 = -165851817;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR80980261 = -722660883;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR29254596 = -266427339;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR10439591 = -196678294;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86052862 = -657358666;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR34812963 = -446467787;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR36844812 = -94199312;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR2616222 = -439719171;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR89007800 = -920232317;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR34971065 = -119321415;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR36061642 = -381651085;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR70166756 = -351310632;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR47497335 = -885216840;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR34484098 = -577818290;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR33276472 = -250441634;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97184347 = -161556052;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR65041833 = -719474667;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR21626874 = -843304462;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR55421251 = -537574436;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR69498183 = -496825302;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR98462908 = -491665727;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6964259 = -735629380;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR53924768 = -804663596;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR22572968 = -620842635;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97660993 = -211281882;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR90448914 = 40257207;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR60650430 = -753178357;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86666534 = -544900015;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6028082 = -660842145;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR17320503 = -286603957;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR2635627 = -808420920;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR73414840 = -932732166;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR22735859 = -839640531;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR9723347 = -641758329;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR38462447 = 84234678;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR44315159 = -975254051;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR4648570 = -656228752;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR27691050 = -431885981;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR87929048 = -436867330;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR49375626 = -127397513;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR77411137 = -953285568;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR88817384 = -279500291;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86268148 = -822398426;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR85841036 = -560501119;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR26326172 = -941268119;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR23262551 = -358833042;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62986635 = -37146809;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62710075 = -158144734;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR61990559 = -733982273;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR23684991 = 88900075;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR87671894 = -980963879;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR16043343 = -142173855;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR56980246 = -202036196;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR99338652 = -914613118;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR89707213 = -807861197;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR76909647 = -430222438;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR27055493 = -917997288;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6681629 = -645584705;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR12778598 = -985396412;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR95603948 = -597615874;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR74162532 = -693289430;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR50178278 = -549299298;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR96588140 = -778877027;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR71687297 = -533628360;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR32335438 = -310900495;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62646801 = -448918919;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR47430898 = -511670102;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR37773988 = -143458512;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR96021651 = -562052968;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR88961313 = -275187583;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR92535778 = -505327301;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR37350784 = -187588687;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR33697826 = -306437132;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6045626 = -310176923;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR92087045 = -543539735;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR9645524 = -112165436;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR20696110 = -913230955;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR68083732 = -144162477;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR96246795 = -679574517;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR74398442 = -852448840;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR27462279 = -922595984;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97940355 = -495033623;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR24675975 = -810917742;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR82343091 = -649742220;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR29648609 = -305640079;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86592283 = -566247066;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR16434595 = -630695971;    int dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR23397206 = -779822533;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR20812101 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62387814;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62387814 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR93429307;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR93429307 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR10483971;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR10483971 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97194173;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97194173 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR95267030;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR95267030 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR20869338;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR20869338 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR52713727;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR52713727 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR37670216;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR37670216 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR12401498;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR12401498 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR68836836;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR68836836 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR88170122;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR88170122 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR83873905;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR83873905 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR80980261;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR80980261 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR29254596;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR29254596 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR10439591;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR10439591 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86052862;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86052862 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR34812963;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR34812963 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR36844812;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR36844812 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR2616222;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR2616222 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR89007800;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR89007800 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR34971065;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR34971065 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR36061642;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR36061642 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR70166756;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR70166756 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR47497335;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR47497335 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR34484098;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR34484098 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR33276472;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR33276472 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97184347;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97184347 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR65041833;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR65041833 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR21626874;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR21626874 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR55421251;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR55421251 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR69498183;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR69498183 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR98462908;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR98462908 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6964259;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6964259 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR53924768;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR53924768 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR22572968;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR22572968 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97660993;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97660993 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR90448914;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR90448914 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR60650430;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR60650430 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86666534;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86666534 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6028082;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6028082 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR17320503;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR17320503 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR2635627;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR2635627 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR73414840;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR73414840 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR22735859;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR22735859 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR9723347;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR9723347 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR38462447;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR38462447 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR44315159;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR44315159 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR4648570;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR4648570 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR27691050;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR27691050 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR87929048;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR87929048 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR49375626;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR49375626 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR77411137;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR77411137 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR88817384;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR88817384 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86268148;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86268148 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR85841036;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR85841036 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR26326172;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR26326172 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR23262551;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR23262551 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62986635;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62986635 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62710075;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62710075 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR61990559;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR61990559 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR23684991;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR23684991 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR87671894;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR87671894 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR16043343;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR16043343 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR56980246;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR56980246 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR99338652;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR99338652 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR89707213;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR89707213 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR76909647;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR76909647 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR27055493;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR27055493 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6681629;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6681629 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR12778598;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR12778598 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR95603948;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR95603948 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR74162532;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR74162532 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR50178278;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR50178278 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR96588140;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR96588140 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR71687297;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR71687297 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR32335438;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR32335438 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62646801;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR62646801 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR47430898;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR47430898 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR37773988;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR37773988 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR96021651;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR96021651 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR88961313;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR88961313 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR92535778;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR92535778 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR37350784;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR37350784 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR33697826;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR33697826 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6045626;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR6045626 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR92087045;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR92087045 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR9645524;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR9645524 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR20696110;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR20696110 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR68083732;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR68083732 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR96246795;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR96246795 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR74398442;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR74398442 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR27462279;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR27462279 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97940355;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR97940355 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR24675975;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR24675975 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR82343091;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR82343091 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR29648609;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR29648609 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86592283;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR86592283 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR16434595;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR16434595 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR23397206;     dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR23397206 = dwpFjegdoXckTPLjvVryHdVmeeSzEWmEySvVvtzR20812101;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void irTKAfbBpHWMrFDnMCXCHP35578606() {     int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10938410 = -838578734;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw45512879 = -697845373;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw88922006 = -946938136;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw83982545 = -108535471;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10250909 = -777286466;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76053435 = -977057014;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw15532776 = -910201449;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw5592291 = -336886284;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw61481903 = 6629046;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw16657168 = -409485156;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw44988655 = -919858577;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw22919630 = -879115058;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw22220038 = -478087678;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw19399115 = -720821767;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw27328967 = -751548282;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw34619333 = -997058164;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw30015043 = -918703907;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw56168676 = -889317079;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw97759203 = -560609748;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69940470 = 12402519;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76930202 = -624657409;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw33052647 = -452418050;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69300060 = -788111006;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw78087853 = -799335008;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw94382523 = -428727784;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw53275063 = -453692025;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw55243807 = -9970628;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw20354723 = -221446110;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw26250832 = -381673715;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69415953 = -717706853;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw58884654 = -864240979;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw68865097 = -997649722;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw7431950 = -791890886;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw30802903 = -727080538;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw89521302 = -454999256;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw75803974 = -923872045;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw97894561 = -827097787;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw14806198 = -925802037;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw71183447 = -460640403;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw31178676 = -449607788;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw19727755 = -366703420;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw71964966 = -101097170;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw62452467 = -183846515;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw4076782 = -796815355;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw14700276 = -952150487;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw30162341 = -25382234;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw18885738 = -564247822;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw34701618 = 98089696;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw32567223 = 7831902;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw56971456 = -888882319;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw17294572 = -811249375;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw93148733 = -91824346;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw26863593 = -665138562;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw41724447 = -403055573;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw58648404 = -950998697;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw77885763 = -286160685;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76212818 = -909734368;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10834153 = -47603128;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw89600022 = -679807687;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw56975845 = -223594441;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw20809629 = -867086387;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw95178053 = -588755340;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw79341459 = -955212570;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw92065950 = -275664101;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw57772514 = -545244177;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76123558 = -922208856;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw15487681 = 12775828;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw91417135 = -751007140;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw29877812 = -165822512;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw51524993 = -827676237;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw36724771 = -69960378;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw15208846 = -992901871;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw84985228 = -328676676;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw66580527 = -11001961;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw50212715 = -620894061;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw4965237 = -423560239;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw70600179 = -168571535;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw65223278 = -991295651;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw63387578 = -847184522;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw64220183 = -303345551;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw34389326 = -889444203;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw20542189 = -8060324;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw87787499 = -129278012;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69279375 = -492791397;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw52121382 = -906457478;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw65735921 = -672416634;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw42001504 = -232511160;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw65707503 = -288835314;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw72154499 = -776081841;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw11635540 = -68838572;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw99591155 = 85862322;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw87060409 = -679494659;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw25206176 = -145994350;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw14207602 = -137045962;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10369048 = -582521401;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw24549702 = -777948081;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw92623506 = -145884601;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw70386517 = -908182415;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw46304268 = -151571178;    int AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw38576718 = -838578734;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10938410 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw45512879;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw45512879 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw88922006;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw88922006 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw83982545;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw83982545 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10250909;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10250909 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76053435;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76053435 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw15532776;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw15532776 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw5592291;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw5592291 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw61481903;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw61481903 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw16657168;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw16657168 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw44988655;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw44988655 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw22919630;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw22919630 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw22220038;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw22220038 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw19399115;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw19399115 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw27328967;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw27328967 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw34619333;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw34619333 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw30015043;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw30015043 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw56168676;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw56168676 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw97759203;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw97759203 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69940470;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69940470 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76930202;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76930202 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw33052647;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw33052647 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69300060;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69300060 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw78087853;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw78087853 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw94382523;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw94382523 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw53275063;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw53275063 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw55243807;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw55243807 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw20354723;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw20354723 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw26250832;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw26250832 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69415953;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69415953 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw58884654;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw58884654 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw68865097;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw68865097 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw7431950;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw7431950 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw30802903;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw30802903 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw89521302;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw89521302 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw75803974;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw75803974 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw97894561;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw97894561 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw14806198;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw14806198 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw71183447;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw71183447 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw31178676;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw31178676 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw19727755;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw19727755 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw71964966;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw71964966 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw62452467;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw62452467 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw4076782;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw4076782 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw14700276;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw14700276 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw30162341;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw30162341 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw18885738;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw18885738 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw34701618;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw34701618 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw32567223;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw32567223 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw56971456;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw56971456 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw17294572;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw17294572 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw93148733;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw93148733 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw26863593;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw26863593 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw41724447;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw41724447 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw58648404;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw58648404 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw77885763;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw77885763 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76212818;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76212818 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10834153;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10834153 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw89600022;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw89600022 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw56975845;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw56975845 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw20809629;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw20809629 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw95178053;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw95178053 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw79341459;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw79341459 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw92065950;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw92065950 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw57772514;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw57772514 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76123558;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw76123558 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw15487681;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw15487681 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw91417135;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw91417135 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw29877812;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw29877812 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw51524993;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw51524993 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw36724771;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw36724771 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw15208846;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw15208846 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw84985228;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw84985228 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw66580527;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw66580527 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw50212715;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw50212715 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw4965237;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw4965237 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw70600179;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw70600179 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw65223278;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw65223278 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw63387578;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw63387578 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw64220183;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw64220183 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw34389326;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw34389326 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw20542189;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw20542189 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw87787499;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw87787499 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69279375;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw69279375 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw52121382;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw52121382 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw65735921;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw65735921 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw42001504;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw42001504 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw65707503;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw65707503 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw72154499;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw72154499 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw11635540;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw11635540 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw99591155;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw99591155 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw87060409;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw87060409 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw25206176;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw25206176 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw14207602;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw14207602 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10369048;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10369048 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw24549702;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw24549702 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw92623506;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw92623506 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw70386517;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw70386517 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw46304268;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw46304268 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw38576718;     AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw38576718 = AHbdheOywISravVTGqXQMmtWEdAlTFomgSrLiWyw10938410;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void epcGgcwmCFLukbnMQLXuxN31761767() {     int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70534506 = 32664888;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv47018728 = -508000758;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv25923394 = 78920942;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv79858304 = -981146348;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv21544135 = -677793493;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv73730556 = -835316688;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv12891259 = -239919035;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv56417575 = -691097660;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv75295347 = -526043453;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv99681682 = -350744010;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70283586 = -221401017;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv57590831 = -974136307;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv92974601 = -384266196;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv77772953 = -624980115;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv24636773 = -444074803;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv31373587 = -802431055;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv65976147 = -846920188;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv20837007 = -158653184;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv78201406 = -699729378;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv49857579 = -650006134;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv57391321 = -457678233;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv1542245 = -344819928;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv61491885 = -552406085;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv42818093 = -363673245;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70360528 = -984865374;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv47689970 = -588309496;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv68583877 = -459450625;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv85465891 = -842827700;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv76035174 = -171266330;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv7889420 = -764690095;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83798972 = -409460307;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv11630358 = -314867719;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv56513988 = -771837759;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv13327346 = -228964469;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv94458663 = -103209242;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv54393870 = -135528627;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv88526239 = -19876421;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv13166536 = -870254426;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv90201390 = -179346920;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv4004331 = -723488736;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv77945568 = -835365017;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv42044147 = -106038588;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv3331710 = 82708655;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv78316287 = -120730093;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv15688592 = -398468556;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv94955469 = -268326393;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv24374460 = -456103489;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv81398011 = -234663533;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv71956871 = -276105718;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv72138848 = -110134779;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv67780822 = -597357599;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv99733885 = -63067602;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv2279107 = -905087016;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv14998970 = -663224528;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv74370445 = -914932785;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv68992261 = -622515184;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv85526843 = -955594674;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83105301 = -557405814;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv9497776 = -996280974;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv73854165 = 10516002;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv5146679 = -275866063;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv27425367 = -397091335;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv80382400 = -419831330;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv67405927 = -761353358;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv15882711 = -941283703;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv58653229 = -906533298;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv1076844 = -102298549;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv79647256 = -55301727;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83314289 = -421770873;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70242902 = -208546177;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv42847347 = -682554635;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv52809612 = -976665762;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv30635617 = -979306264;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv74197076 = -976240643;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv71912011 = -814641118;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv15347174 = -251639645;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv98210535 = -327528584;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83175598 = -331675992;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv27129502 = -965204690;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv75405059 = -616538982;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv23315511 = -32206007;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv87185865 = -124787093;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv13509021 = -466721983;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv3896327 = 38868448;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv40108598 = -67332497;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv84065086 = -246392706;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv9351251 = -409780704;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv41515019 = -8613231;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv38956900 = -314031685;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv25466403 = -480694058;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv68867027 = -179933954;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv5420938 = -462470608;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv3668760 = -873973453;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv16347226 = -89862923;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv98857651 = -347622673;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv50520201 = -338273682;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv61661747 = -686207259;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv35925783 = -155937987;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv62433576 = -179446391;    int OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv57035362 = 32664888;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70534506 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv47018728;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv47018728 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv25923394;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv25923394 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv79858304;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv79858304 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv21544135;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv21544135 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv73730556;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv73730556 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv12891259;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv12891259 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv56417575;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv56417575 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv75295347;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv75295347 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv99681682;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv99681682 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70283586;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70283586 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv57590831;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv57590831 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv92974601;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv92974601 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv77772953;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv77772953 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv24636773;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv24636773 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv31373587;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv31373587 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv65976147;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv65976147 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv20837007;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv20837007 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv78201406;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv78201406 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv49857579;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv49857579 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv57391321;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv57391321 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv1542245;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv1542245 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv61491885;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv61491885 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv42818093;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv42818093 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70360528;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70360528 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv47689970;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv47689970 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv68583877;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv68583877 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv85465891;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv85465891 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv76035174;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv76035174 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv7889420;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv7889420 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83798972;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83798972 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv11630358;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv11630358 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv56513988;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv56513988 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv13327346;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv13327346 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv94458663;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv94458663 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv54393870;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv54393870 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv88526239;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv88526239 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv13166536;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv13166536 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv90201390;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv90201390 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv4004331;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv4004331 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv77945568;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv77945568 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv42044147;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv42044147 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv3331710;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv3331710 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv78316287;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv78316287 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv15688592;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv15688592 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv94955469;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv94955469 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv24374460;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv24374460 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv81398011;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv81398011 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv71956871;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv71956871 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv72138848;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv72138848 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv67780822;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv67780822 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv99733885;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv99733885 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv2279107;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv2279107 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv14998970;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv14998970 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv74370445;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv74370445 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv68992261;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv68992261 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv85526843;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv85526843 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83105301;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83105301 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv9497776;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv9497776 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv73854165;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv73854165 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv5146679;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv5146679 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv27425367;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv27425367 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv80382400;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv80382400 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv67405927;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv67405927 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv15882711;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv15882711 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv58653229;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv58653229 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv1076844;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv1076844 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv79647256;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv79647256 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83314289;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83314289 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70242902;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70242902 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv42847347;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv42847347 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv52809612;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv52809612 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv30635617;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv30635617 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv74197076;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv74197076 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv71912011;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv71912011 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv15347174;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv15347174 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv98210535;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv98210535 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83175598;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv83175598 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv27129502;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv27129502 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv75405059;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv75405059 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv23315511;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv23315511 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv87185865;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv87185865 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv13509021;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv13509021 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv3896327;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv3896327 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv40108598;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv40108598 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv84065086;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv84065086 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv9351251;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv9351251 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv41515019;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv41515019 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv38956900;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv38956900 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv25466403;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv25466403 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv68867027;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv68867027 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv5420938;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv5420938 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv3668760;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv3668760 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv16347226;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv16347226 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv98857651;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv98857651 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv50520201;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv50520201 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv61661747;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv61661747 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv35925783;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv35925783 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv62433576;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv62433576 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv57035362;     OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv57035362 = OhJVSAwULOBakXTaQWCzsAsBeiIXkQOCwQbvxKKv70534506;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void AJzGuXuHBfKWjJFIWaEOsp44306955() {     int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU90002676 = -380466324;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42593 = 46121246;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42760386 = -672707673;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU98505452 = -797720611;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU21990652 = -204065909;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU99322630 = -725801456;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU57723137 = -683225265;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU21667808 = -784905626;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU35982145 = -154234832;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU77610406 = -356330055;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU24506850 = -654391317;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU61085445 = -973439012;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU83346260 = -808623473;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU86188993 = -67265840;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU85163234 = -742158595;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97589235 = -165622989;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU71938260 = 81305131;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU44899758 = 90592098;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU77836285 = 23065861;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU30468881 = -267542590;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU69847393 = 36109441;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU16524328 = -856623141;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU29664891 = -849980703;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU60539761 = -217237;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU81564017 = -179165484;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU52457432 = -274104714;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU52512008 = -124601557;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU36257566 = 93439021;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU17780131 = -185177476;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU92596274 = -856128790;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU13603058 = -274786400;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU51209668 = -879216737;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU67990091 = -227045525;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU72083852 = -533567676;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU34389000 = -165912048;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU90459807 = -439097236;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU56909690 = -546752496;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU54649009 = -947463242;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU57514715 = -643761745;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU25286067 = -720019832;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU19427626 = -245151312;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU53903280 = -344934814;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU74464951 = -965093142;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU61701825 = -569802754;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU95717002 = -675591519;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU49416597 = -805657814;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU6364340 = -369796812;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU81553841 = -417950847;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU13092462 = -290044956;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU13037191 = -971147124;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42216391 = 96277470;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU16182746 = -440420461;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU72104253 = -581195977;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU87928998 = -657818164;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU74459562 = -689491420;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU73478348 = -523843183;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU70377701 = -103898052;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU82220625 = -572490437;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU16941436 = -518555128;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU69533220 = -929961195;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU46810622 = -501199900;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU21465571 = -676664286;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU3887677 = -499728150;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU43385870 = -298106043;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU64007348 = 18456344;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU73297182 = -775174580;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU93095353 = -646393487;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU11262408 = -175055798;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU51799994 = -901353793;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU94703426 = -203061360;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU40679546 = -618870494;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU17289251 = 28768372;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU87385042 = -265646157;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU52550219 = -256914307;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU11041256 = 77608722;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU15944113 = -618955745;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42059377 = -891529999;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU67963065 = -180177949;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU64822759 = -324625719;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU32147421 = -373507670;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU46093092 = -904307903;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU70958166 = -706650710;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU23165105 = -616516023;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU4742941 = -214030352;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU50379883 = -852406260;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97420311 = -834365940;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU79105414 = -198020761;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU80061093 = -569227362;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97624290 = -844076256;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU60910651 = -642068865;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU20082107 = -235199185;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU74689065 = -974262060;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU37707574 = -328908114;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU87981495 = -713800550;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU78475444 = -118819933;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97962054 = -568487027;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU50015603 = -845206665;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU31079081 = -566987100;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97694476 = -488259099;    int TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU22419820 = -380466324;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU90002676 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42593;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42593 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42760386;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42760386 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU98505452;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU98505452 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU21990652;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU21990652 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU99322630;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU99322630 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU57723137;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU57723137 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU21667808;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU21667808 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU35982145;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU35982145 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU77610406;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU77610406 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU24506850;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU24506850 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU61085445;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU61085445 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU83346260;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU83346260 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU86188993;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU86188993 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU85163234;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU85163234 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97589235;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97589235 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU71938260;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU71938260 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU44899758;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU44899758 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU77836285;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU77836285 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU30468881;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU30468881 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU69847393;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU69847393 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU16524328;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU16524328 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU29664891;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU29664891 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU60539761;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU60539761 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU81564017;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU81564017 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU52457432;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU52457432 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU52512008;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU52512008 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU36257566;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU36257566 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU17780131;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU17780131 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU92596274;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU92596274 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU13603058;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU13603058 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU51209668;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU51209668 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU67990091;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU67990091 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU72083852;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU72083852 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU34389000;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU34389000 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU90459807;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU90459807 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU56909690;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU56909690 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU54649009;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU54649009 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU57514715;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU57514715 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU25286067;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU25286067 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU19427626;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU19427626 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU53903280;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU53903280 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU74464951;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU74464951 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU61701825;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU61701825 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU95717002;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU95717002 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU49416597;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU49416597 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU6364340;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU6364340 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU81553841;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU81553841 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU13092462;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU13092462 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU13037191;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU13037191 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42216391;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42216391 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU16182746;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU16182746 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU72104253;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU72104253 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU87928998;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU87928998 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU74459562;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU74459562 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU73478348;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU73478348 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU70377701;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU70377701 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU82220625;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU82220625 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU16941436;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU16941436 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU69533220;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU69533220 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU46810622;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU46810622 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU21465571;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU21465571 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU3887677;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU3887677 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU43385870;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU43385870 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU64007348;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU64007348 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU73297182;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU73297182 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU93095353;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU93095353 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU11262408;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU11262408 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU51799994;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU51799994 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU94703426;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU94703426 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU40679546;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU40679546 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU17289251;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU17289251 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU87385042;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU87385042 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU52550219;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU52550219 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU11041256;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU11041256 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU15944113;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU15944113 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42059377;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU42059377 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU67963065;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU67963065 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU64822759;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU64822759 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU32147421;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU32147421 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU46093092;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU46093092 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU70958166;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU70958166 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU23165105;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU23165105 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU4742941;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU4742941 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU50379883;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU50379883 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97420311;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97420311 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU79105414;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU79105414 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU80061093;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU80061093 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97624290;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97624290 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU60910651;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU60910651 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU20082107;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU20082107 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU74689065;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU74689065 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU37707574;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU37707574 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU87981495;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU87981495 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU78475444;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU78475444 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97962054;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97962054 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU50015603;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU50015603 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU31079081;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU31079081 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97694476;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU97694476 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU22419820;     TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU22419820 = TUosPaEeEJdhilzXupBdWvaICJGcGabweLpeRBIU90002676;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void BMWVsTIeSmhJLwjYDZnwpr22388680() {     int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM55995092 = -190480976;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM25647728 = -377903583;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM87981568 = -972463980;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM55811694 = -572162212;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75619378 = -116303508;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM1252070 = -72806380;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM81411831 = -433510652;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM51245623 = -959287471;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM6127912 = -810963343;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15424517 = -381229290;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM3385170 = -583540728;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM54586060 = -354387488;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM73246018 = -105864082;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM42452762 = 34944739;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM21538262 = -956821606;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM21273751 = -80043750;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM7848893 = -868991098;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM39847065 = -407813347;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM98644668 = -311797233;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75676357 = -373561087;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM50560828 = -737336329;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM60389703 = -578958251;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM22797666 = -350298808;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75698510 = -354267718;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM96267807 = -627177109;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM29244623 = -849834821;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM36449056 = -190534838;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM17343435 = -310358127;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM69533777 = -858843554;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM19400364 = -880339423;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM94029034 = -314667486;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM53272411 = -539883693;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM97368893 = -43947682;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM43005063 = -599487850;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM89677608 = 10518989;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM95247666 = -55152497;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM59952714 = -134659117;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM96902518 = -854094338;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM61763553 = -477052842;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75307639 = -561393360;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM14433260 = -857577956;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM34984859 = -752135859;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM2644249 = -980689567;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM78639650 = -835821393;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM44700537 = -381664867;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM30809806 = -629238857;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM86795175 = -269769694;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM55278428 = -523999787;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM65184939 = -873901633;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM41657082 = -704405374;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM95236703 = -576995405;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM29582544 = 93816489;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM27038169 = -413119068;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM78428248 = -996753065;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM71827851 = -222198111;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM95605389 = -611522725;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM2850062 = 72395224;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM12283058 = -518196262;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM59543887 = -944985103;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM46374756 = -266468688;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM64803014 = -882271543;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM64068396 = -23152525;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM81711846 = -443917;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM86727548 = -930623921;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM21395483 = 33438196;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM50112758 = 56342965;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM57217167 = -210439807;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM30240956 = -506376233;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM52775154 = -975574250;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM26290595 = -801669110;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM61321037 = -945384633;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM10946375 = 85103239;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM78083512 = -930760505;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM23337030 = -750403873;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM61243098 = -515983131;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15575969 = -985200470;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM57745455 = -598268684;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM44158015 = -514477416;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM30997974 = -972602852;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM65458001 = -997938252;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM42449447 = -480065127;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM81170627 = -666535051;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM52158496 = -436456495;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM27876696 = -54438181;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM24163660 = -203344018;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM64446490 = -308483975;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM26234243 = -26764626;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM18940645 = -47194618;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM71177211 = -277289739;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM94072218 = -377958286;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM92397605 = -27547722;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM47669657 = -616462856;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM37358632 = -909109235;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15388797 = -110584154;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM10504626 = -679121818;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM50364863 = -734425431;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM53273013 = -651691942;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15916700 = 49934353;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM57244168 = -769259589;    int NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM94587778 = -190480976;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM55995092 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM25647728;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM25647728 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM87981568;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM87981568 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM55811694;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM55811694 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75619378;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75619378 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM1252070;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM1252070 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM81411831;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM81411831 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM51245623;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM51245623 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM6127912;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM6127912 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15424517;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15424517 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM3385170;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM3385170 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM54586060;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM54586060 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM73246018;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM73246018 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM42452762;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM42452762 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM21538262;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM21538262 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM21273751;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM21273751 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM7848893;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM7848893 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM39847065;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM39847065 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM98644668;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM98644668 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75676357;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75676357 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM50560828;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM50560828 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM60389703;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM60389703 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM22797666;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM22797666 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75698510;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75698510 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM96267807;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM96267807 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM29244623;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM29244623 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM36449056;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM36449056 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM17343435;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM17343435 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM69533777;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM69533777 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM19400364;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM19400364 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM94029034;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM94029034 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM53272411;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM53272411 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM97368893;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM97368893 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM43005063;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM43005063 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM89677608;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM89677608 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM95247666;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM95247666 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM59952714;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM59952714 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM96902518;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM96902518 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM61763553;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM61763553 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75307639;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM75307639 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM14433260;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM14433260 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM34984859;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM34984859 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM2644249;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM2644249 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM78639650;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM78639650 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM44700537;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM44700537 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM30809806;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM30809806 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM86795175;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM86795175 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM55278428;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM55278428 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM65184939;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM65184939 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM41657082;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM41657082 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM95236703;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM95236703 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM29582544;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM29582544 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM27038169;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM27038169 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM78428248;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM78428248 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM71827851;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM71827851 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM95605389;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM95605389 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM2850062;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM2850062 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM12283058;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM12283058 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM59543887;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM59543887 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM46374756;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM46374756 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM64803014;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM64803014 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM64068396;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM64068396 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM81711846;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM81711846 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM86727548;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM86727548 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM21395483;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM21395483 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM50112758;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM50112758 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM57217167;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM57217167 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM30240956;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM30240956 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM52775154;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM52775154 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM26290595;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM26290595 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM61321037;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM61321037 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM10946375;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM10946375 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM78083512;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM78083512 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM23337030;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM23337030 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM61243098;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM61243098 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15575969;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15575969 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM57745455;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM57745455 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM44158015;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM44158015 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM30997974;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM30997974 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM65458001;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM65458001 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM42449447;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM42449447 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM81170627;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM81170627 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM52158496;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM52158496 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM27876696;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM27876696 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM24163660;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM24163660 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM64446490;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM64446490 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM26234243;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM26234243 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM18940645;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM18940645 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM71177211;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM71177211 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM94072218;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM94072218 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM92397605;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM92397605 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM47669657;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM47669657 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM37358632;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM37358632 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15388797;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15388797 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM10504626;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM10504626 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM50364863;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM50364863 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM53273013;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM53273013 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15916700;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM15916700 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM57244168;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM57244168 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM94587778;     NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM94587778 = NOPOpwRuqhFCmUQjZiEARpIydEVuDuMlIJyHFddM55995092;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void CVQpkpKoPQLhgpbHEdseUF70484174() {     int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM99593919 = -238615807;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM5477679 = -895980483;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM5746684 = -989695056;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83191107 = -160737111;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM39913954 = 94160573;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM23103825 = -358635738;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM81492121 = -66345201;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM74403630 = -367249989;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM61850711 = -197141884;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM58114556 = -300194062;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM65042235 = -475537810;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM6475405 = -320069034;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27990509 = 93954153;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM9945998 = -780288976;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM66350122 = -406719755;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM75266900 = 54407381;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM49788933 = -261622077;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM51818489 = -851547723;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM98599690 = -29540469;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM14441313 = -838969582;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM10060580 = -129761164;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM18736126 = -306518931;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM49515514 = -133494163;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM8007582 = -25245865;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM3874040 = -780323464;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM34302896 = -889876631;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM43518265 = -799681339;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27921379 = -434667810;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27073309 = -734322828;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM13137143 = -659685562;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM63576885 = -660325654;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM82517821 = 59698944;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM31161448 = -633450560;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM54820423 = -217962906;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM51094889 = -8607477;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM1170847 = -535578127;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM81497393 = -89271165;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM55447607 = -888362641;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM53017855 = -621979324;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM77016390 = -975974545;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM68537190 = 45229167;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM13255708 = -495220295;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM85556713 = -567885663;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM55365254 = -661440825;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM9718857 = -751854138;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM44530702 = -82635476;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM82626406 = -72612946;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM59787921 = -382275093;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM41475902 = 28194528;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM93238650 = -982668250;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM52647169 = -473747010;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83678342 = -423273027;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79106028 = -465184937;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM18891225 = -491927008;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM60423594 = -471099965;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM80857793 = -932096876;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM55962165 = -662486320;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM97739101 = -864449191;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79317067 = -380413648;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM5611058 = -15962796;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79585560 = -558954400;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM53570743 = -631677391;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM47330321 = -632927162;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM48713568 = -537456322;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94537671 = -639868409;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM82524414 = -435236755;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM75313956 = -686618474;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM73170086 = -688082941;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM58851108 = -671681500;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM65179275 = -871141628;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM93769507 = -856321454;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94341326 = -373259436;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM98800633 = -129568400;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM21583301 = -53565924;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM45904123 = -784198749;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM96804872 = -634540870;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM33179413 = -738633269;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94150259 = -472053339;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM98288724 = -273391727;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM59343338 = -597687988;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM51676490 = -717263686;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83730343 = -317406247;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM86445477 = -362862339;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM33834659 = -751654578;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM60489974 = -85938553;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79898542 = -137052627;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM3411793 = -475116119;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM12270223 = -41523553;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94396828 = -746862942;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM70237095 = -76510601;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM45208681 = -873091808;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83758291 = -224821974;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM76130539 = -407948993;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM47406798 = -506016528;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM97430830 = -317020146;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM14966447 = -323093442;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM65925386 = -862293133;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM36843145 = 69570659;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM60827583 = 78427583;    int PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27194443 = -238615807;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM99593919 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM5477679;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM5477679 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM5746684;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM5746684 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83191107;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83191107 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM39913954;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM39913954 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM23103825;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM23103825 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM81492121;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM81492121 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM74403630;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM74403630 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM61850711;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM61850711 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM58114556;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM58114556 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM65042235;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM65042235 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM6475405;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM6475405 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27990509;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27990509 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM9945998;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM9945998 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM66350122;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM66350122 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM75266900;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM75266900 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM49788933;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM49788933 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM51818489;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM51818489 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM98599690;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM98599690 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM14441313;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM14441313 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM10060580;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM10060580 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM18736126;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM18736126 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM49515514;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM49515514 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM8007582;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM8007582 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM3874040;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM3874040 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM34302896;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM34302896 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM43518265;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM43518265 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27921379;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27921379 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27073309;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27073309 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM13137143;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM13137143 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM63576885;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM63576885 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM82517821;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM82517821 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM31161448;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM31161448 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM54820423;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM54820423 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM51094889;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM51094889 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM1170847;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM1170847 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM81497393;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM81497393 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM55447607;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM55447607 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM53017855;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM53017855 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM77016390;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM77016390 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM68537190;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM68537190 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM13255708;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM13255708 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM85556713;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM85556713 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM55365254;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM55365254 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM9718857;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM9718857 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM44530702;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM44530702 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM82626406;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM82626406 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM59787921;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM59787921 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM41475902;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM41475902 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM93238650;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM93238650 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM52647169;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM52647169 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83678342;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83678342 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79106028;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79106028 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM18891225;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM18891225 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM60423594;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM60423594 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM80857793;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM80857793 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM55962165;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM55962165 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM97739101;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM97739101 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79317067;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79317067 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM5611058;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM5611058 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79585560;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79585560 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM53570743;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM53570743 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM47330321;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM47330321 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM48713568;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM48713568 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94537671;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94537671 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM82524414;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM82524414 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM75313956;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM75313956 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM73170086;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM73170086 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM58851108;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM58851108 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM65179275;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM65179275 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM93769507;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM93769507 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94341326;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94341326 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM98800633;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM98800633 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM21583301;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM21583301 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM45904123;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM45904123 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM96804872;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM96804872 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM33179413;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM33179413 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94150259;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94150259 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM98288724;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM98288724 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM59343338;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM59343338 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM51676490;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM51676490 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83730343;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83730343 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM86445477;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM86445477 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM33834659;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM33834659 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM60489974;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM60489974 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79898542;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM79898542 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM3411793;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM3411793 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM12270223;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM12270223 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94396828;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM94396828 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM70237095;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM70237095 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM45208681;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM45208681 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83758291;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM83758291 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM76130539;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM76130539 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM47406798;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM47406798 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM97430830;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM97430830 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM14966447;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM14966447 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM65925386;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM65925386 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM36843145;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM36843145 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM60827583;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM60827583 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27194443;     PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM27194443 = PXmuOxXjwebUEpYToomHaNKyWPHgygvVUwGtDqbM99593919;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void fpIZnKZAQxVQxtQozFdiSe43332020() {     int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp9188399 = -710503220;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp41626608 = -716784649;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp18076374 = -778118132;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp75336830 = -163483196;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp53417206 = -473435285;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp29482304 = -141753614;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp20987439 = -147196903;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp92532426 = -97505694;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp46349196 = -933225901;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp40298950 = -975654634;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp95417318 = -316948268;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp44719525 = -898959874;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp56708301 = -642638984;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp56780891 = -220735586;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp24950955 = -89924489;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp65662292 = -109164422;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp99713226 = -694742000;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp97236952 = 54848267;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp59148961 = -873155665;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp62376863 = -4384348;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp10439055 = -440398582;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp31799791 = -51418780;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp50926938 = -837528703;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp33650347 = -109814233;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp61962717 = -618134517;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp57861322 = -451545584;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp49413731 = -224361264;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp1883429 = -658291148;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30027264 = -410433022;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp45633077 = -625526648;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp96844372 = -852318291;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp21464046 = 94525506;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp51606592 = -388883486;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp37415574 = -514017270;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp26621760 = -821645944;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp90467790 = -42176146;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp50114413 = -131963144;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp21287364 = -831630700;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30864198 = -793856194;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp42810268 = -877213415;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp23718920 = -170418404;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp79759303 = -548609734;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp16506796 = -991113056;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp69412734 = -974596675;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp81711685 = -41487057;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp19430823 = -3590803;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp45039577 = -634788768;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp50330210 = -592218660;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp10530147 = -421684057;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp63417398 = -100676932;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp56448261 = -154493986;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp43900310 = -765052720;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp98383630 = -953146893;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp44728315 = -610075926;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp32892966 = -374258871;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp77388607 = -559084441;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp90699669 = -879255947;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp84426026 = -568303900;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp13374114 = -545348680;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp95555883 = 78110299;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp80068573 = -917392351;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp19104010 = -488905756;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp62505163 = -687072672;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp716119 = -207699253;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp43454577 = -23336343;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp73953272 = -311473775;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp93112933 = -410076388;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp19292727 = -28621714;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30159131 = -399089643;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp34483165 = 52251656;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp15547879 = -977201279;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp78425862 = -863111300;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp66372755 = -151295539;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp16338694 = -995942251;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp38657943 = -833965944;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30679751 = -891788849;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp15292996 = -60305725;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp81514204 = -862932028;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp51938662 = 31672824;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp42531894 = -514543715;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp12821746 = -816756817;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp99083520 = -632142605;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp91353282 = -136607091;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp66609865 = -209756090;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp89184815 = -371032663;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp52944063 = 12734428;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp23080416 = 47672399;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp6878277 = -778807561;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp4522609 = -39758399;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp49233152 = -162561504;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp99768120 = -162920199;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp65688386 = -563659244;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp7913251 = -186282021;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp35308314 = -771966494;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp62741695 = -959821065;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp4614911 = -681512648;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp17254141 = -861537062;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp15790677 = -683413803;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp25958157 = -851260332;    int MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp7758414 = -710503220;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp9188399 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp41626608;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp41626608 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp18076374;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp18076374 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp75336830;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp75336830 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp53417206;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp53417206 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp29482304;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp29482304 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp20987439;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp20987439 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp92532426;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp92532426 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp46349196;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp46349196 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp40298950;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp40298950 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp95417318;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp95417318 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp44719525;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp44719525 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp56708301;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp56708301 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp56780891;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp56780891 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp24950955;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp24950955 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp65662292;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp65662292 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp99713226;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp99713226 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp97236952;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp97236952 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp59148961;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp59148961 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp62376863;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp62376863 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp10439055;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp10439055 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp31799791;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp31799791 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp50926938;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp50926938 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp33650347;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp33650347 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp61962717;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp61962717 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp57861322;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp57861322 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp49413731;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp49413731 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp1883429;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp1883429 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30027264;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30027264 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp45633077;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp45633077 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp96844372;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp96844372 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp21464046;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp21464046 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp51606592;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp51606592 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp37415574;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp37415574 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp26621760;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp26621760 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp90467790;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp90467790 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp50114413;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp50114413 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp21287364;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp21287364 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30864198;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30864198 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp42810268;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp42810268 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp23718920;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp23718920 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp79759303;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp79759303 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp16506796;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp16506796 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp69412734;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp69412734 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp81711685;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp81711685 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp19430823;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp19430823 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp45039577;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp45039577 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp50330210;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp50330210 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp10530147;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp10530147 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp63417398;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp63417398 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp56448261;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp56448261 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp43900310;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp43900310 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp98383630;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp98383630 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp44728315;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp44728315 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp32892966;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp32892966 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp77388607;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp77388607 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp90699669;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp90699669 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp84426026;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp84426026 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp13374114;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp13374114 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp95555883;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp95555883 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp80068573;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp80068573 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp19104010;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp19104010 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp62505163;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp62505163 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp716119;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp716119 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp43454577;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp43454577 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp73953272;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp73953272 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp93112933;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp93112933 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp19292727;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp19292727 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30159131;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30159131 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp34483165;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp34483165 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp15547879;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp15547879 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp78425862;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp78425862 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp66372755;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp66372755 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp16338694;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp16338694 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp38657943;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp38657943 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30679751;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp30679751 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp15292996;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp15292996 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp81514204;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp81514204 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp51938662;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp51938662 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp42531894;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp42531894 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp12821746;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp12821746 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp99083520;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp99083520 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp91353282;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp91353282 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp66609865;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp66609865 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp89184815;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp89184815 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp52944063;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp52944063 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp23080416;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp23080416 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp6878277;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp6878277 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp4522609;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp4522609 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp49233152;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp49233152 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp99768120;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp99768120 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp65688386;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp65688386 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp7913251;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp7913251 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp35308314;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp35308314 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp62741695;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp62741695 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp4614911;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp4614911 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp17254141;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp17254141 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp15790677;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp15790677 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp25958157;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp25958157 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp7758414;     MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp7758414 = MWcnCjciaVxkxJchOLDcUrPEBRvslDeZJAdlwAHp9188399;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void oKHVWihntrXKWAZyECMyhb39515180() {     int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV68784495 = -939259597;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43132457 = -526940034;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV55077762 = -852259055;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV71212589 = 63905926;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV64710432 = -373942312;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV27159425 = -13288;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV18345921 = -576914489;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43357710 = -451717069;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV60162640 = -365898400;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV23323465 = -916913487;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV20712250 = -718490707;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV79390727 = -993981123;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV27462864 = -548817502;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV15154730 = -124893934;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV22258761 = -882451010;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV62416546 = 85462686;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV35674331 = -622958280;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV61905284 = -314487838;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV39591164 = 87724705;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV42293972 = -666793001;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV90900172 = -273419406;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV289390 = 56179343;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43118763 = -601823782;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV98380586 = -774152469;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV37940722 = -74272107;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV52276229 = -586163056;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV62753801 = -673841262;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV66994597 = -179672738;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV79811606 = -200025637;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV84106543 = -672509890;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV21758691 = -397537619;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV64229306 = -322692491;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV688631 = -368830359;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV19940017 = -15901202;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV31559121 = -469855930;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV69057687 = -353832728;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV40746091 = -424741778;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV19647702 = -776083090;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV49882140 = -512562711;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV15635923 = -51094363;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV81936733 = -639080001;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV49838484 = -553551152;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV57386038 = -724557885;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43652239 = -298511414;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV82700001 = -587805126;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV84223951 = -246534962;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV50528299 = -526644435;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV97026604 = -924971889;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV49919794 = -705621677;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV78584790 = -421929393;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV6934512 = 59397790;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV50485463 = -736295975;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV73799144 = -93095346;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV18002839 = -870244881;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV48615008 = -338192959;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV68495106 = -895438940;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV13695 = -925116253;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV56697176 = 21893414;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV33271868 = -861821967;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV12434203 = -787779257;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV64405623 = -326172027;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV51351323 = -297241752;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV63546104 = -151691433;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV76056096 = -693388510;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV1564774 = -419375869;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV56482943 = -295798217;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV78702096 = -525150765;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV7522848 = -432916301;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV83595609 = -655038005;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV53201074 = -428618283;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV21670456 = -489795536;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV16026629 = -846875191;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV12023144 = -801925127;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV23955242 = -861180932;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV60357238 = 72287000;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV41061688 = -719868255;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV42903352 = -219262773;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV99466523 = -203312369;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV15680585 = -86347344;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV53716770 = -827737146;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV1747931 = 40481379;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV65727197 = -748869373;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV17074804 = -474051062;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV1226817 = -778096244;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV77172032 = -631907681;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV71273228 = -661241644;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV90430161 = -129597145;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV82685792 = -498585478;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV71325009 = -677708244;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV63064015 = -574416990;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV69043992 = -428716475;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV84048915 = -346635193;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV86375834 = -914261123;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV37447938 = -724783454;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV51230299 = -724922337;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV30585410 = -241838249;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV86292380 = -301859720;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV81329941 = 68830625;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV42087465 = -879135545;    int QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV26217058 = -939259597;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV68784495 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43132457;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43132457 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV55077762;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV55077762 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV71212589;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV71212589 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV64710432;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV64710432 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV27159425;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV27159425 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV18345921;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV18345921 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43357710;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43357710 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV60162640;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV60162640 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV23323465;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV23323465 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV20712250;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV20712250 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV79390727;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV79390727 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV27462864;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV27462864 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV15154730;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV15154730 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV22258761;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV22258761 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV62416546;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV62416546 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV35674331;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV35674331 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV61905284;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV61905284 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV39591164;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV39591164 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV42293972;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV42293972 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV90900172;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV90900172 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV289390;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV289390 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43118763;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43118763 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV98380586;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV98380586 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV37940722;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV37940722 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV52276229;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV52276229 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV62753801;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV62753801 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV66994597;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV66994597 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV79811606;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV79811606 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV84106543;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV84106543 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV21758691;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV21758691 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV64229306;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV64229306 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV688631;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV688631 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV19940017;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV19940017 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV31559121;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV31559121 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV69057687;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV69057687 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV40746091;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV40746091 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV19647702;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV19647702 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV49882140;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV49882140 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV15635923;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV15635923 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV81936733;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV81936733 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV49838484;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV49838484 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV57386038;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV57386038 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43652239;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV43652239 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV82700001;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV82700001 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV84223951;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV84223951 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV50528299;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV50528299 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV97026604;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV97026604 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV49919794;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV49919794 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV78584790;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV78584790 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV6934512;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV6934512 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV50485463;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV50485463 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV73799144;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV73799144 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV18002839;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV18002839 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV48615008;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV48615008 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV68495106;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV68495106 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV13695;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV13695 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV56697176;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV56697176 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV33271868;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV33271868 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV12434203;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV12434203 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV64405623;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV64405623 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV51351323;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV51351323 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV63546104;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV63546104 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV76056096;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV76056096 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV1564774;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV1564774 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV56482943;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV56482943 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV78702096;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV78702096 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV7522848;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV7522848 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV83595609;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV83595609 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV53201074;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV53201074 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV21670456;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV21670456 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV16026629;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV16026629 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV12023144;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV12023144 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV23955242;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV23955242 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV60357238;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV60357238 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV41061688;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV41061688 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV42903352;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV42903352 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV99466523;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV99466523 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV15680585;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV15680585 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV53716770;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV53716770 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV1747931;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV1747931 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV65727197;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV65727197 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV17074804;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV17074804 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV1226817;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV1226817 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV77172032;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV77172032 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV71273228;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV71273228 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV90430161;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV90430161 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV82685792;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV82685792 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV71325009;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV71325009 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV63064015;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV63064015 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV69043992;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV69043992 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV84048915;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV84048915 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV86375834;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV86375834 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV37447938;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV37447938 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV51230299;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV51230299 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV30585410;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV30585410 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV86292380;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV86292380 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV81329941;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV81329941 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV42087465;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV42087465 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV26217058;     QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV26217058 = QwiAuLpWmxjSqlbWZufagWuvqenRvuzCqMtLmVoV68784495;}
// Junk Finished
